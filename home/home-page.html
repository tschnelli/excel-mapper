<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Excel Template Mapper</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.4/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            // Excel green color palette
            excel: {
              50: '#eef9f1',
              100: '#d5f0db',
              200: '#ace1b7',
              300: '#7bca8e',
              400: '#4fb06a',
              500: '#217346', // Main Excel green
              600: '#1e6a40',
              700: '#1a5a38',
              800: '#154a2e',
              900: '#113c25',
            }
          }
        }
      }
    }
  </script>
  <style>
    /* Add base styles for dark mode */
    .dark {
      color-scheme: dark;
    }

    /* Fix for file input */
    input[type="file"]::-webkit-file-upload-button {
      cursor: pointer;
      height: 100%;
    }

    /* Custom scrollbar for better UX */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    
    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 4px;
    }
    
    .dark ::-webkit-scrollbar-thumb {
      background: #475569;
    }

    /* Enhanced Tooltip styles - update to trigger only on info icon */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltip-text {
      /* Size and shape */
      width: 280px;
      max-width: 90vw;
      border-radius: 8px;
      
      /* Positioning */
      position: absolute;
      z-index: 50;
      top: 125%;
      left: 0;
      
      /* Colors and borders */
      background-color: #217346; /* Excel green */
      color: #ffffff;
      border: 1px solid #1a5a38;
      
      /* Text formatting */
      font-size: 0.875rem;
      line-height: 1.5;
      text-align: left;
      
      /* Spacing and shadow */
      padding: 10px 12px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      
      /* Visibility and transition */
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      transform: translateY(-10px);
      
      /* Content overflow */
      overflow-wrap: break-word;
      word-wrap: break-word;
    }

    /* Arrow pointer for tooltip */
    .tooltip .tooltip-text::before {
      content: "";
      position: absolute;
      top: -8px;
      left: 15px;
      border-width: 0 8px 8px 8px;
      border-style: solid;
      border-color: transparent transparent #217346 transparent;
    }

    /* Only show tooltip when hovering over the info icon */
    .tooltip .info-icon:hover + .tooltip-text {
      visibility: visible;
      opacity: 1;
      transform: translateY(0);
    }

    /* Dark mode tooltip style */
    .dark .tooltip .tooltip-text {
      background-color: #1a5a38;
      border: 1px solid #154a2e;
      color: #ffffff;
    }

    .dark .tooltip .tooltip-text::before {
      border-color: transparent transparent #1a5a38 transparent;
    }

    /* For tooltips with longer content */
    .tooltip .tooltip-text.large {
      max-height: 200px;
      overflow-y: auto;
      padding-right: 15px;
    }

    /* Custom scrollbar for tooltip content */
    .tooltip .tooltip-text::-webkit-scrollbar {
      width: 6px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Styled tooltip content */
    .tooltip .tooltip-text h4 {
      margin: 0 0 5px 0;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 5px;
    }

    .tooltip .tooltip-text p {
      margin: 0 0 8px 0;
    }

    .tooltip .tooltip-text .highlight {
      background-color: rgba(255, 255, 255, 0.2);
      padding: 1px 3px;
      border-radius: 2px;
    }

    /* Column header styling */
    .has-notes {
      padding-bottom: 1px;
    }

    .tooltip .info-icon {
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #217346;
      color: white;
      margin-left: 5px;
      vertical-align: text-top;
      cursor: help;
    }

    .dark .tooltip .info-icon {
      background-color: #4fb06a;
    }

    /* Custom dropdown styles */
    .custom-select-container {
      position: relative;
      width: 100%;
    }

    .custom-select-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      background-color: white;
      cursor: pointer;
      user-select: none;
    }

    .dark .custom-select-header {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }

    .custom-select-header.error {
      border-color: #ef4444;
    }

    .custom-select-header .arrow {
      transition: transform 0.2s;
    }

    .custom-select-header.open .arrow {
      transform: rotate(180deg);
    }

    .custom-select-dropdown {
      position: absolute;
      left: 0;
      right: 0;
      margin-top: 4px;
      max-height: 250px;
      overflow-y: auto;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      z-index: 30;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      display: none;
    }

    .custom-select-dropdown.open {
      display: block;
    }

    .dark .custom-select-dropdown {
      background-color: #1f2937;
      border-color: #374151;
    }

    .custom-select-option {
      padding: 8px 12px;
      cursor: pointer;
      transition: background-color 0.1s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .custom-select-option:hover {
      background-color: #f3f4f6;
    }

    .dark .custom-select-option:hover {
      background-color: #374151;
    }

    .custom-select-option.selected {
      background-color: #f9fafb;
      font-weight: 500;
    }

    .dark .custom-select-option.selected {
      background-color: #2a3441;
    }

    .custom-select-option.suggested {
      color: #4b5563;
      font-style: italic;
    }

    .dark .custom-select-option.suggested {
      color: #9ca3af;
    }

    /* Sample preview styles */
    .sample-preview {
      position: absolute;
      z-index: 40;
      width: 280px;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
    }

    .sample-preview.visible {
      opacity: 1;
      visibility: visible;
    }

    .dark .sample-preview {
      background-color: #1f2937;
      border-color: #374151;
      color: white;
    }

    .sample-preview-header {
      padding: 10px 12px;
      background-color: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .dark .sample-preview-header {
      background-color: #374151;
      border-color: #4b5563;
    }

    .sample-preview-body {
      max-height: 180px;
      overflow-y: auto;
    }

    .sample-preview-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f3f4f6;
    }

    .sample-preview-item:last-child {
      border-bottom: none;
    }

    .dark .sample-preview-item {
      border-color: #374151;
    }

    .sample-preview-footer {
      padding: 8px 12px;
      background-color: #f9fafb;
      border-top: 1px solid #e5e7eb;
      font-size: 0.75rem;
      color: #6b7280;
      font-style: italic;
    }

    .dark .sample-preview-footer {
      background-color: #374151;
      border-color: #4b5563;
      color: #9ca3af;
    }

    /* Custom tooltip for dropdown options */
    .dropdown-tooltip {
      position: relative;
    }

    .dropdown-tooltip .tooltip-text {
      /* Fixed positioning for dropdown tooltips to escape overflow constraints */
      position: fixed;
      z-index: 100; /* Higher z-index to appear above all dropdowns */
      
      /* Sizing and spacing */
      width: 280px;
      max-width: 90vw;
      padding: 10px 12px;
      
      /* Remove standard positioning */
      left: auto;
      right: auto;
      top: auto;
      bottom: auto;
      
      /* Will be positioned via JavaScript */
      transform: none;
      
      /* Better shadow for dropdown tooltips */
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }

    /* Hide the standard arrow for dropdown tooltips */
    .dropdown-tooltip .tooltip-text::before {
      display: none;
    }
    
    /* Auto-mapping suggestion panel */
    .mapping-suggestion-panel {
      margin-bottom: 1.5rem;
      background-color: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 0.375rem;
      padding: 1rem;
    }
    
    .dark .mapping-suggestion-panel {
      background-color: rgba(14, 165, 233, 0.1);
      border-color: rgba(14, 165, 233, 0.2);
    }
    
    .mapping-suggestion {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      border-radius: 0.25rem;
      background-color: #fff;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }
    
    .dark .mapping-suggestion {
      background-color: #1f2937;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1);
    }
    
    .mapping-suggestion:last-child {
      margin-bottom: 0;
    }
    
    .mapping-confidence {
      display: inline-block;
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    .confidence-high {
      background-color: #dcfce7;
      color: #166534;
    }
    
    .dark .confidence-high {
      background-color: rgba(22, 101, 52, 0.3);
      color: #4ade80;
    }
    
    .confidence-medium {
      background-color: #fef9c3;
      color: #854d0e;
    }
    
    .dark .confidence-medium {
      background-color: rgba(133, 77, 14, 0.3);
      color: #facc15;
    }
    
    .confidence-low {
      background-color: #fee2e2;
      color: #b91c1c;
    }
    
    .dark .confidence-low {
      background-color: rgba(185, 28, 28, 0.3);
      color: #f87171;
    }

    /* Badge styles */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .worksheet-badge {
      background-color: #e0f2fe;
      color: #0369a1;
      border: 1px solid #bae6fd;
    }

    .dark .worksheet-badge {
      background-color: rgba(14, 165, 233, 0.2);
      border-color: rgba(14, 165, 233, 0.3);
      color: #38bdf8;
    }

    /* Category mapping styles */
    .category-mapping-item {
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      margin-bottom: 0.75rem;
      background-color: white;
    }

    .dark .category-mapping-item {
      background-color: #1f2937;
      border-color: #374151;
    }

    .category-mapping-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      background-color: #f9fafb;
      border-top-left-radius: 0.375rem;
      border-top-right-radius: 0.375rem;
    }

    .dark .category-mapping-header {
      background-color: #374151;
      border-color: #4b5563;
    }

    .category-mapping-body {
      padding: 1rem;
    }

    /* Tab selector styles */
    .tab-selector {
      display: flex;
      overflow-x: auto;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 1rem;
    }

    .dark .tab-selector {
      border-color: #4b5563;
    }

    .tab-item {
      padding: 0.5rem 1rem;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      white-space: nowrap;
      font-weight: 500;
    }

    .tab-item:hover {
      color: #4b5563;
    }

    .dark .tab-item:hover {
      color: #9ca3af;
    }

    .tab-item.active {
      border-bottom-color: #217346;
      color: #217346;
    }

    .dark .tab-item.active {
      border-bottom-color: #4fb06a;
      color: #4fb06a;
    }

    /* Worksheet tab selector */
    .worksheet-tab-selector {
      display: flex;
      overflow-x: auto;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background-color: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
    }

    .dark .worksheet-tab-selector {
      background-color: #1f2937;
      border-color: #374151;
    }

    .worksheet-tab-item {
      padding: 0.375rem 0.75rem;
      margin-right: 0.5rem;
      border-radius: 0.375rem;
      cursor: pointer;
      white-space: nowrap;
      font-size: 0.875rem;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .worksheet-tab-item:hover {
      background-color: #f3f4f6;
    }

    .dark .worksheet-tab-item:hover {
      background-color: #374151;
    }

    .worksheet-tab-item.active {
      background-color: #eef9f1;
      border-color: #ace1b7;
      color: #217346;
      font-weight: 500;
    }

    .dark .worksheet-tab-item.active {
      background-color: rgba(79, 176, 106, 0.1);
      border-color: rgba(79, 176, 106, 0.3);
      color: #4fb06a;
    }

    .worksheet-tab-item.main {
      background-color: #f0f9ff;
      border-color: #bae6fd;
      color: #0369a1;
    }

    .dark .worksheet-tab-item.main {
      background-color: rgba(14, 165, 233, 0.1);
      border-color: rgba(14, 165, 233, 0.3);
      color: #38bdf8;
    }

    .worksheet-tab-item.main.active {
      background-color: #e0f7fa;
      border-color: #67e8f9;
      color: #0e7490;
    }

    .dark .worksheet-tab-item.main.active {
      background-color: rgba(8, 145, 178, 0.2);
      border-color: rgba(8, 145, 178, 0.4);
      color: #06b6d4;
    }

    /* Sheet selection styles */
    .sheet-checkbox {
      margin-right: 8px;
    }
    
    .sheet-selection-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    
    .sheet-selection-item {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
    }
    
    .dark .sheet-selection-item {
      background-color: #374151;
      border-color: #4b5563;
    }
    
    .sheet-selection-item.selected {
      border-color: #217346;
      background-color: #eef9f1;
    }
    
    .dark .sheet-selection-item.selected {
      border-color: #4fb06a;
      background-color: rgba(79, 176, 106, 0.1);
    }
    
    /* Format preservation notice */
    .format-preservation-notice {
      display: flex;
      align-items: flex-start;
      margin-top: 16px;
      padding: 12px;
      background-color: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 6px;
    }
    
    .dark .format-preservation-notice {
      background-color: rgba(14, 165, 233, 0.1);
      border-color: rgba(14, 165, 233, 0.2);
    }
    
    .format-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    
    .format-icon {
      margin-right: 6px;
      color: #217346;
    }
    
    .dark .format-icon {
      color: #4fb06a;
    }
    
    /* Worksheet header preview */
    .worksheet-preview {
      margin-top: 16px;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
    }
    
    .dark .worksheet-preview {
      border-color: #4b5563;
    }
    
    .worksheet-preview-header {
      padding: 10px 12px;
      background-color: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
    }
    
    .dark .worksheet-preview-header {
      background-color: #374151;
      border-color: #4b5563;
    }
    
    .worksheet-preview-content {
      padding: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .worksheet-header-item {
      display: flex;
      align-items: center;
      padding: 8px;
      margin-bottom: 4px;
      border-radius: 4px;
      background-color: #f3f4f6;
    }
    
    .dark .worksheet-header-item {
      background-color: #1f2937;
    }

    /* Per-worksheet configuration table */
    .worksheet-config-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 0.875rem;
    }

    .worksheet-config-table th {
      text-align: left;
      padding: 8px;
      background-color: #f3f4f6;
      border: 1px solid #e5e7eb;
    }

    .dark .worksheet-config-table th {
      background-color: #374151;
      border-color: #4b5563;
    }

    .worksheet-config-table td {
      padding: 8px;
      border: 1px solid #e5e7eb;
    }

    .dark .worksheet-config-table td {
      border-color: #4b5563;
    }

    .worksheet-config-table input {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #e5e7eb;
      border-radius: 0.25rem;
    }

    .dark .worksheet-config-table input {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }

    .worksheet-config-table tr:nth-child(even) {
      background-color: #f9fafb;
    }

    .dark .worksheet-config-table tr:nth-child(even) {
      background-color: #1f2937;
    }

    /* Multi-sheet tag styles */
    .sheet-tag {
      display: inline-flex;
      align-items: center;
      background-color: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      padding: 0.25rem 0.5rem;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
    }

    .dark .sheet-tag {
      background-color: #374151;
      border-color: #4b5563;
      color: #e5e7eb;
    }

    .sheet-tag-main {
      background-color: #eef9f1;
      border-color: #ace1b7;
      color: #217346;
    }

    .dark .sheet-tag-main {
      background-color: rgba(79, 176, 106, 0.2);
      border-color: rgba(79, 176, 106, 0.4);
      color: #4fb06a;
    }

    .sheet-tag .remove-btn {
      margin-left: 0.5rem;
      font-size: 0.75rem;
      padding: 0.125rem 0.25rem;
      color: #6b7280;
      cursor: pointer;
      border-radius: 0.25rem;
    }

    .sheet-tag .remove-btn:hover {
      background-color: rgba(0, 0, 0, 0.1);
      color: #ef4444;
    }

    .dark .sheet-tag .remove-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: #f87171;
    }

    /* Sheet suggestions */
    .sheet-suggestions {
      margin-top: 0.5rem;
    }

    .sheet-suggestion-item {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
      background-color: #f9fafb;
      border: 1px dashed #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .sheet-suggestion-item:hover {
      background-color: #eef9f1;
      border-color: #ace1b7;
      color: #217346;
    }

    .dark .sheet-suggestion-item {
      background-color: #1f2937;
      border-color: #4b5563;
    }

    .dark .sheet-suggestion-item:hover {
      background-color: rgba(79, 176, 106, 0.1);
      border-color: rgba(79, 176, 106, 0.3);
      color: #4fb06a;
    }

    .sheet-suggestion-score {
      margin-left: 0.5rem;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .dark .sheet-suggestion-score {
      color: #9ca3af;
    }

    /* For highlighting the main tab in preview */
    .main-tab-highlight {
      background-color: #e0f2fe;
      border-left: 3px solid #0ea5e9;
    }

    .dark .main-tab-highlight {
      background-color: rgba(14, 165, 233, 0.1);
      border-left: 3px solid #0ea5e9;
    }

    /* Badge for main tab in preview */
    .main-tab-badge {
      display: inline-block;
      padding: 2px 6px;
      background-color: #0ea5e9;
      color: white;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      margin-left: 6px;
      text-transform: uppercase;
    }

    .dark .main-tab-badge {
      background-color: #0284c7;
    }

    /* Export options panel */
    .export-options-panel {
      margin-top: 20px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      background-color: #f9fafb;
    }

    .dark .export-options-panel {
      background-color: #1f2937;
      border-color: #374151;
    }

    .export-options-title {
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
    }

    .export-options-title svg {
      margin-right: 8px;
    }

    .export-option-group {
      margin-bottom: 16px;
    }

    .export-option-label {
      display: flex;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .export-option-label input {
      margin-top: 2px;
      margin-right: 8px;
    }

    .export-option-description {
      font-size: 0.875rem;
      color: #4b5563;
    }

    .dark .export-option-description {
      color: #9ca3af;
    }
  </style>
</head>
<body>
  <div id="excel-mapper-root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Check for dark mode preference
    const initDarkMode = () => {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.classList.add('dark');
        return true;
      }
      return false;
    };

    // Custom Select Component with hover preview support and descriptions
    const CustomSelect = ({ 
      options, 
      value, 
      onChange, 
      placeholder = "-- Select an option --", 
      isError = false,
      suggestedValue = null,
      columnSamples = {},
      columnDescriptions = {}
    }) => {
      const [isOpen, setIsOpen] = useState(false);
      const [previewVisible, setPreviewVisible] = useState(false);
      const [previewHeader, setPreviewHeader] = useState(null);
      const [previewPos, setPreviewPos] = useState({ top: 0, left: 0 });
      const previewTimerRef = useRef(null);
      const dropdownRef = useRef(null);
      const containerRef = useRef(null);
      
      // Handle click outside to close dropdown
      useEffect(() => {
        const handleClickOutside = (event) => {
          if (containerRef.current && !containerRef.current.contains(event.target)) {
            setIsOpen(false);
          }
        };
        
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
          document.removeEventListener('mousedown', handleClickOutside);
        };
      }, []);
      
      // Clean up preview timer
      useEffect(() => {
        return () => {
          if (previewTimerRef.current) {
            clearTimeout(previewTimerRef.current);
          }
        };
      }, []);

      const handleToggle = () => {
        setIsOpen(!isOpen);
      };
      
      const handleSelect = (optionValue) => {
        onChange(optionValue);
        setIsOpen(false);
      };
      
      const handleOptionMouseEnter = (e, optionValue) => {
        // Clear any existing timer
        if (previewTimerRef.current) {
          clearTimeout(previewTimerRef.current);
        }
        
        // Set a timer to show preview after 1.5 seconds
        if (columnSamples[optionValue] && columnSamples[optionValue].length > 0) {
          previewTimerRef.current = setTimeout(() => {
            // Calculate position
            const rect = e.currentTarget.getBoundingClientRect();
            
            setPreviewHeader(optionValue);
            setPreviewPos({
              top: rect.top,
              left: rect.right + 10 // 10px right of the option
            });
            setPreviewVisible(true);
          }, 1500);
        }
      };
      
      const handleOptionMouseLeave = () => {
        if (previewTimerRef.current) {
          clearTimeout(previewTimerRef.current);
          previewTimerRef.current = null;
        }
        setPreviewVisible(false);
      };
      
      // Find the selected option's label
      const selectedOption = options.find(opt => opt.value === value);
      const displayValue = selectedOption ? selectedOption.label : placeholder;
      
      // Helper to check if a column has a description
      const hasDescription = (optionValue) => {
        return columnDescriptions[optionValue] && columnDescriptions[optionValue].trim() !== '';
      };
      
      return (
        <div ref={containerRef} className="custom-select-container">
          <div 
            className={`custom-select-header ${isOpen ? 'open' : ''} ${isError ? 'error' : ''}`} 
            onClick={handleToggle}
          >
            <span className={!selectedOption ? 'text-gray-400 dark:text-gray-500' : 'flex items-center'}>
              {displayValue}
              {value && hasDescription(value) && (
                <div className="tooltip ml-1">
                  <span className="info-icon text-xs">i</span>
                  <span 
                    className={`tooltip-text ${columnDescriptions[value] && columnDescriptions[value].length > 150 ? 'large' : ''}`}
                    dangerouslySetInnerHTML={{ __html: columnDescriptions[value] }}
                  />
                </div>
              )}
            </span>
            <span className="arrow">▼</span>
          </div>
          
          <div 
            ref={dropdownRef} 
            className={`custom-select-dropdown ${isOpen ? 'open' : ''}`}
          >
            {options.map((option) => (
              <div
                key={option.value || 'empty'}
                className={`custom-select-option ${option.value === value ? 'selected' : ''} ${option.value === suggestedValue ? 'suggested' : ''}`}
                onClick={() => handleSelect(option.value)}
                onMouseEnter={(e) => handleOptionMouseEnter(e, option.value)}
                onMouseLeave={handleOptionMouseLeave}
              >
                <div className="flex justify-between w-full items-center">
                  <div className="flex items-center">
                    <span className="mr-1">{option.label}</span>
                    {hasDescription(option.value) && (
                      <div className="dropdown-tooltip tooltip">
                        <span className="info-icon text-xs" 
                          onMouseEnter={(e) => {
                            // Get tooltip element (next sibling)
                            const tooltip = e.target.nextSibling;
                            if (tooltip) {
                              // Calculate position - above the icon
                              const rect = e.target.getBoundingClientRect();
                              tooltip.style.top = `${rect.top - 10 - tooltip.offsetHeight}px`;
                              tooltip.style.left = `${rect.left - tooltip.offsetWidth + 20}px`;
                              tooltip.style.visibility = 'visible';
                              tooltip.style.opacity = '1';
                            }
                          }}
                          onMouseLeave={(e) => {
                            // Hide tooltip on mouse leave
                            const tooltip = e.target.nextSibling;
                            if (tooltip) {
                              tooltip.style.visibility = 'hidden';
                              tooltip.style.opacity = '0';
                            }
                          }}
                        >i</span>
                        <span 
                          className={`tooltip-text ${columnDescriptions[option.value] && columnDescriptions[option.value].length > 150 ? 'large' : ''}`}
                          dangerouslySetInnerHTML={{ __html: columnDescriptions[option.value] }}
                        />
                      </div>
                    )}
                  </div>
                  
                  {option.value === suggestedValue && (
                    <span className="text-sm text-gray-500 dark:text-gray-400">(Suggested)</span>
                  )}
                </div>
              </div>
            ))}
          </div>
          
          {/* Sample preview popup */}
          {previewVisible && columnSamples[previewHeader] && (
            <div 
              className={`sample-preview ${previewVisible ? 'visible' : ''}`}
              style={{ top: `${previewPos.top}px`, left: `${previewPos.left}px` }}
            >
              <div className="sample-preview-header">
                Sample data: <span className="text-excel-600 dark:text-excel-400">{previewHeader}</span>
              </div>
              <div className="sample-preview-body">
                {columnSamples[previewHeader].map((sample, index) => (
                  <div key={index} className="sample-preview-item">
                    {typeof sample === 'undefined' || sample === null ? 
                      <span className="text-gray-400 dark:text-gray-500">Empty</span> : 
                      String(sample)
                    }
                  </div>
                ))}
              </div>
              <div className="sample-preview-footer">
                Showing {columnSamples[previewHeader].length} sample values from this column
              </div>
            </div>
          )}
        </div>
      );
    };

    const ExcelMapper = () => {
      const [template, setTemplate] = useState(null);
      const [data, setData] = useState(null);
      const [templateFile, setTemplateFile] = useState(null);
      const [dataFile, setDataFile] = useState(null);
      const [templateHeaders, setTemplateHeaders] = useState([]);
      const [dataHeaders, setDataHeaders] = useState([]);
      const [mappings, setMappings] = useState({});
      const [suggestedMappings, setSuggestedMappings] = useState({});
      const [mappingScores, setMappingScores] = useState({});
      const [mappedData, setMappedData] = useState(null);
      const [step, setStep] = useState(1);
      const [isDarkMode, setIsDarkMode] = useState(initDarkMode());
      const [isLoading, setIsLoading] = useState({
        template: false,
        data: false,
        mapping: false,
        headerLoad: false,
        export: false
      });
      
      // Sheet selection states
      const [templateSheets, setTemplateSheets] = useState([]);
      const [dataSheets, setDataSheets] = useState([]);
      const [selectedTemplateSheet, setSelectedTemplateSheet] = useState('');
      const [selectedDataSheet, setSelectedDataSheet] = useState('');
      const [templateHeaderRow, setTemplateHeaderRow] = useState(1);
      const [dataHeaderRow, setDataHeaderRow] = useState(1);
      
      // Required/Optional field states
      const [requirementRowAvailable, setRequirementRowAvailable] = useState(false);
      const [templateRequirementRow, setTemplateRequirementRow] = useState(2);
      const [fieldRequirements, setFieldRequirements] = useState({});
      
      // Template header notes state from data validation or comments
      const [templateHeaderNotes, setTemplateHeaderNotes] = useState({});
      const [dataHeaderDescriptions, setDataHeaderDescriptions] = useState({});
      const [debugInfo, setDebugInfo] = useState("");
      
      // Column data samples for preview
      const [columnSamples, setColumnSamples] = useState({});
      
      // State to track if suggestions have been reviewed
      const [suggestionsReviewed, setSuggestionsReviewed] = useState(false);
      
      // States for multi-tab mapping
      const [enableMultiTabMapping, setEnableMultiTabMapping] = useState(false);
      const [categoryColumn, setCategoryColumn] = useState('');
      const [categoryValues, setCategoryValues] = useState([]);
      // Modified to store arrays of worksheets instead of single worksheet
      const [categoryWorksheetMappings, setCategoryWorksheetMappings] = useState({});
      const [activeTab, setActiveTab] = useState(null);
      const [activeWorksheet, setActiveWorksheet] = useState(null);
      
      // Enhanced tabSpecificMappings to store per-worksheet mappings within each category
      // Format: { category1: { worksheet1: {templateHeader: dataHeader, ...}, worksheet2: {...} }, category2: {...} }
      const [worksheetMappings, setWorksheetMappings] = useState({});
      
      // Worksheet suggestions based on fuzzy matching
      const [worksheetSuggestions, setWorksheetSuggestions] = useState({});
      // Option to always include main tab
      const [includeMainTab, setIncludeMainTab] = useState(true);
      const [mainTabSelection, setMainTabSelection] = useState("");

      // States for sheet-specific header mappings
      const [useSheetSpecificHeaders, setUseSheetSpecificHeaders] = useState(true);
      const [selectedWorksheets, setSelectedWorksheets] = useState([]);
      const [worksheetHeadersMap, setWorksheetHeadersMap] = useState({});
      const [worksheetRequirementsMap, setWorksheetRequirementsMap] = useState({});
      const [worksheetNotesMap, setWorksheetNotesMap] = useState({});
      const [preserveFormatting, setPreserveFormatting] = useState(true);
      
      // States for per-worksheet configuration
      const [worksheetHeaderRows, setWorksheetHeaderRows] = useState({});
      const [worksheetRequirementRows, setWorksheetRequirementRows] = useState({});
      
      // Export options
      const [exportOptions, setExportOptions] = useState({
        preserveFormulas: true,
        preserveFormatting: true,
        preserveStyles: true,
        applyColumnFormats: true,
        preserveValidation: true,
        includeMacros: false // Default to false
      });
      
      // Listen for dark mode changes
      useEffect(() => {
        const darkModeListener = (e) => {
          const isDark = e.matches;
          setIsDarkMode(isDark);
          if (isDark) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        };
        
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        mediaQuery.addEventListener('change', darkModeListener);
        
        return () => mediaQuery.removeEventListener('change', darkModeListener);
      }, []);

      // Function to handle file uploads
      const handleFileUpload = (e, fileType) => {
        const file = e.target.files[0];
        if (!file) return;
        
        setIsLoading(prev => ({ ...prev, [fileType]: true }));
        
        const reader = new FileReader();
        
        reader.onload = (evt) => {
          try {
            const binaryString = evt.target.result;
            const workbook = XLSX.read(binaryString, { 
              type: 'binary', 
              cellFormula: true, 
              cellNF: true, 
              cellDates: true, 
              cellStyles: true,
              bookVBA: true, // Preserve VBA and macros
              bookFiles: true // Preserve embedded files/objects
            });
            
            if (fileType === 'template') {
              setTemplateFile(file);
              setTemplateSheets(workbook.SheetNames);
              setSelectedTemplateSheet(workbook.SheetNames[0]);
              
              // Set the main tab to the first sheet by default
              if (workbook.SheetNames.length > 0) {
                setMainTabSelection(workbook.SheetNames[0]);
              }
              
              // Initialize selected worksheets with the first sheet
              if (workbook.SheetNames.length > 0) {
                setSelectedWorksheets([workbook.SheetNames[0]]);
                
                // Initialize header and requirement rows for each worksheet
                const initialHeaderRows = {};
                const initialRequirementRows = {};
                
                workbook.SheetNames.forEach(sheet => {
                  initialHeaderRows[sheet] = templateHeaderRow;
                  initialRequirementRows[sheet] = templateRequirementRow;
                });
                
                setWorksheetHeaderRows(initialHeaderRows);
                setWorksheetRequirementRows(initialRequirementRows);
              }
            } else {
              setDataFile(file);
              setDataSheets(workbook.SheetNames);
              setSelectedDataSheet(workbook.SheetNames[0]);
            }
          } catch (error) {
            console.error(`Error reading ${fileType} file:`, error);
          } finally {
            setIsLoading(prev => ({ ...prev, [fileType]: false }));
          }
        };
        
        reader.onerror = () => {
          console.error(`Error reading ${fileType} file`);
          setIsLoading(prev => ({ ...prev, [fileType]: false }));
        };
        
        reader.readAsBinaryString(file);
      };

      // Process the selected worksheet with headers and requirement info
      const processSheet = (fileType) => {
        const file = fileType === 'template' ? templateFile : dataFile;
        if (!file) return;
        
        setIsLoading(prev => ({ ...prev, [fileType]: true }));
        
        const reader = new FileReader();
        
        reader.onload = (evt) => {
          try {
            const binaryString = evt.target.result;
            // Include cellStyles to access cell formatting information
            const workbook = XLSX.read(binaryString, { 
              type: 'binary', 
              cellFormula: true,  // Get formulas
              cellStyles: true,   // Get cell styles
              cellDates: true,    // Get dates
              cellNF: true,       // Get number formats
              cellText: false,    // Don't get text
              bookVBA: true,      // Preserve VBA and macros
              bookFiles: true     // Preserve embedded files/objects
            });
            
            if (fileType === 'template') {
              if (useSheetSpecificHeaders && selectedWorksheets.length > 0) {
                // Process each selected worksheet to get its headers
                const headerMap = {};
                const requirementsMap = {};
                const notesMap = {};
                
                // Set loading state for header loading
                setIsLoading(prev => ({ ...prev, headerLoad: true }));
                
                selectedWorksheets.forEach(sheetName => {
                  const worksheet = workbook.Sheets[sheetName];
                  const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                  
                  // Extract headers from specified row (convert to 0-based index)
                  const headerRowIndex = (worksheetHeaderRows[sheetName] || templateHeaderRow) - 1;
                  const headers = jsonData[headerRowIndex] || [];
                  
                  // Process requirement row if enabled
                  let requirements = {};
                  if (requirementRowAvailable) {
                    const reqRowIndex = (worksheetRequirementRows[sheetName] || templateRequirementRow) - 1;
                    const reqRow = jsonData[reqRowIndex] || [];
                    
                    headers.forEach((header, index) => {
                      if (header) {
                        // Check if the requirement cell contains any indicator of being required
                        const reqValue = reqRow[index];
                        const isRequired = 
                          reqValue && 
                          String(reqValue).toLowerCase().match(/required|mandatory|req|r|yes|y|\*/i) !== null;
                        
                        requirements[header] = isRequired ? 'Required' : 'Optional';
                      }
                    });
                  } else {
                    // Default all fields to optional if no requirement row specified
                    headers.forEach(header => {
                      if (header) {
                        requirements[header] = 'Optional';
                      }
                    });
                  }
                  
                  // Extract notes and validation messages for this worksheet
                  const notes = {};
                  let validationCount = 0;
                  let commentCount = 0;
                  
                  // Iterate over header cells to find validation messages or comments
                  headers.forEach((header, index) => {
                    if (!header) return;
                    
                    // Calculate the cell reference for this header
                    const colLetter = XLSX.utils.encode_col(index);
                    const cellRef = `${colLetter}${headerRowIndex + 1}`;
                    
                    let foundNote = "";
                    
                    // Try to get data validation input message
                    if (worksheet['!dataValidations']) {
                      const validations = worksheet['!dataValidations'];
                      for (let i = 0; i < validations.length; i++) {
                        const validation = validations[i];
                        // Check if validation applies to this cell
                        if (validation.sqref === cellRef || validation.sqref.includes(cellRef)) {
                          if (validation.prompt) {
                            foundNote = validation.prompt;
                            validationCount++;
                            break;
                          }
                        }
                      }
                    }
                    
                    // If validation message not found, try fallback methods
                    if (!foundNote) {
                      // Check for comments/notes as fallback
                      if (worksheet[cellRef] && worksheet[cellRef].c && worksheet[cellRef].c.length > 0) {
                        foundNote = worksheet[cellRef].c[0].t || "";
                        commentCount++;
                      }
                      else if (worksheet[cellRef] && worksheet[cellRef].cm) {
                        foundNote = typeof worksheet[cellRef].cm === 'string' ? 
                          worksheet[cellRef].cm : 
                          (worksheet[cellRef].cm.t || worksheet[cellRef].cm.text || "");
                        commentCount++;
                      }
                      else if (worksheet.comments && worksheet.comments[cellRef]) {
                        foundNote = worksheet.comments[cellRef].t || worksheet.comments[cellRef].text || "";
                        commentCount++;
                      }
                    }
                    
                    // Store the note (empty string if none found)
                    notes[header] = foundNote;
                  });
                  
                  // Add fallback demo notes for demonstration if no real messages found
                  if (validationCount === 0 && commentCount === 0) {
                    headers.forEach((header, index) => {
                      if (!header) return;
                      
                      // Add formatted demo notes with more detailed examples
                      if (index % 4 === 0) {
                        notes[header] = `<h4>Input Guidelines</h4><p>Enter data for <span class="highlight">${header}</span> in the correct format to ensure data integrity.</p>`;
                      } else if (index % 4 === 1) {
                        notes[header] = `<h4>${header}</h4><p>This field should contain ${header.toLowerCase()} information that follows these rules:</p><ul><li>Must be properly formatted</li><li>Should be accurate and verified</li></ul>`;
                      } else if (index % 4 === 2) {
                        notes[header] = `<h4>Format Required</h4><p>The <span class="highlight">${header}</span> field expects data in a specific format. Please ensure your data matches this expectation.</p>`;
                      } else if (index % 4 === 3 && requirements[header] === 'Required') {
                        notes[header] = `<h4>Required Field</h4><p>The <span class="highlight">${header}</span> field must be completed. Missing data will cause validation errors.</p>`;
                      }
                    });
                  }
                  
                  // Store headers, requirements, and notes for this worksheet
                  headerMap[sheetName] = headers;
                  requirementsMap[sheetName] = requirements;
                  notesMap[sheetName] = notes;
                });
                
                // Store all worksheet-specific header information
                setWorksheetHeadersMap(headerMap);
                setWorksheetRequirementsMap(requirementsMap);
                setWorksheetNotesMap(notesMap);
                
                // Use the headers from the first selected worksheet for single-sheet view
                if (selectedWorksheets.length > 0) {
                  const firstSheet = selectedWorksheets[0];
                  setTemplateHeaders(headerMap[firstSheet] || []);
                  setFieldRequirements(requirementsMap[firstSheet] || {});
                  setTemplateHeaderNotes(notesMap[firstSheet] || {});
                  
                  // Combined dataset for the initially selected worksheet
                  const worksheet = workbook.Sheets[firstSheet];
                  const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                  const headerRowIndex = (worksheetHeaderRows[firstSheet] || templateHeaderRow) - 1;
                  const headers = jsonData[headerRowIndex] || [];
                  const dataRows = jsonData.slice(headerRowIndex + 1);
                  const fullData = [headers, ...dataRows];
                  
                  setTemplate({ 
                    workbook, 
                    sheet: firstSheet, 
                    headers, 
                    data: fullData,
                    worksheetHeaders: headerMap,
                    worksheetRequirements: requirementsMap,
                    worksheetNotes: notesMap
                  });
                }
                
                // Create debug info summarizing what we found
                let totalHeaderCount = 0;
                Object.values(headerMap).forEach(headers => {
                  totalHeaderCount += headers.filter(Boolean).length;
                });
                
                setDebugInfo(`Loaded ${totalHeaderCount} columns across ${selectedWorksheets.length} worksheets.`);
                setIsLoading(prev => ({ ...prev, headerLoad: false }));
              } else {
                // Process the traditional single selected worksheet
                const selectedSheet = selectedTemplateSheet;
                const worksheet = workbook.Sheets[selectedSheet];
                
                // Get all data as array of arrays
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                
                // Extract headers from specified row (convert to 0-based index)
                const headerRowIndex = templateHeaderRow - 1;
                const headers = jsonData[headerRowIndex] || [];
                
                // Process requirement row if enabled
                let requirements = {};
                if (requirementRowAvailable) {
                  const reqRowIndex = templateRequirementRow - 1;
                  const reqRow = jsonData[reqRowIndex] || [];
                  
                  headers.forEach((header, index) => {
                    if (header) {
                      // Check if the requirement cell contains any indicator of being required
                      const reqValue = reqRow[index];
                      const isRequired = 
                        reqValue && 
                        String(reqValue).toLowerCase().match(/required|mandatory|req|r|yes|y|\*/i) !== null;
                      
                      requirements[header] = isRequired ? 'Required' : 'Optional';
                    }
                  });
                } else {
                  // Default all fields to optional if no requirement row specified
                  headers.forEach(header => {
                    if (header) {
                      requirements[header] = 'Optional';
                    }
                  });
                }
                
                setFieldRequirements(requirements);
                
                // This will hold all the notes/tooltips found for headers
                const notes = {};
                let validationCount = 0;
                let commentCount = 0;
                
                // Try to extract validation input messages
                // In SheetJS, data validations might be found in the dataValidation property
                const hasValidations = worksheet['!dataValidations'] || 
                                      (worksheet.Workbook && worksheet.Workbook.Sheets && 
                                       worksheet.Workbook.Sheets[0] && 
                                       worksheet.Workbook.Sheets[0].DataValidations);
                
                // Iterate over header cells to find validation messages or comments
                headers.forEach((header, index) => {
                  if (!header) return;
                  
                  // Calculate the cell reference for this header
                  const colLetter = XLSX.utils.encode_col(index);
                  const cellRef = `${colLetter}${headerRowIndex + 1}`;
                  
                  let foundNote = "";
                  
                  // Try to get data validation input message
                  if (worksheet['!dataValidations']) {
                    const validations = worksheet['!dataValidations'];
                    for (let i = 0; i < validations.length; i++) {
                      const validation = validations[i];
                      // Check if validation applies to this cell
                      if (validation.sqref === cellRef || validation.sqref.includes(cellRef)) {
                        if (validation.prompt) {
                          foundNote = validation.prompt;
                          validationCount++;
                          break;
                        }
                      }
                    }
                  }
                  
                  // If validation message not found, try fallback methods
                  if (!foundNote) {
                    // Check for comments/notes as fallback
                    if (worksheet[cellRef] && worksheet[cellRef].c && worksheet[cellRef].c.length > 0) {
                      foundNote = worksheet[cellRef].c[0].t || "";
                      commentCount++;
                    }
                    else if (worksheet[cellRef] && worksheet[cellRef].cm) {
                      foundNote = typeof worksheet[cellRef].cm === 'string' ? 
                        worksheet[cellRef].cm : 
                        (worksheet[cellRef].cm.t || worksheet[cellRef].cm.text || "");
                      commentCount++;
                    }
                    else if (worksheet.comments && worksheet.comments[cellRef]) {
                      foundNote = worksheet.comments[cellRef].t || worksheet.comments[cellRef].text || "";
                      commentCount++;
                    }
                  }
                  
                  // Store the note (empty string if none found)
                  notes[header] = foundNote;
                });
                
                // Create debug info
                let debugText = `Found ${validationCount} validation input messages and ${commentCount} comments.`;
                setDebugInfo(debugText);
                
                // Add fallback demo notes for demonstration if no real messages found
                if (validationCount === 0 && commentCount === 0) {
                  headers.forEach((header, index) => {
                    if (!header) return;
                    
                    // Add formatted demo notes with more detailed examples
                    if (index % 4 === 0) {
                      notes[header] = `<h4>Input Guidelines</h4><p>Enter data for <span class="highlight">${header}</span> in the correct format to ensure data integrity.</p>`;
                    } else if (index % 4 === 1) {
                      notes[header] = `<h4>${header}</h4><p>This field should contain ${header.toLowerCase()} information that follows these rules:</p><ul><li>Must be properly formatted</li><li>Should be accurate and verified</li></ul>`;
                    } else if (index % 4 === 2) {
                      notes[header] = `<h4>Format Required</h4><p>The <span class="highlight">${header}</span> field expects data in a specific format. Please ensure your data matches this expectation.</p>`;
                    } else if (index % 4 === 3 && requirements[header] === 'Required') {
                      notes[header] = `<h4>Required Field</h4><p>The <span class="highlight">${header}</span> field must be completed. Missing data will cause validation errors.</p>`;
                    }
                  });
                  setDebugInfo("Using demo validation messages for illustration (no real validation data found in Excel file).");
                }
                
                setTemplateHeaderNotes(notes);
                
                // Get data rows (all rows after the header row)
                const dataRows = jsonData.slice(headerRowIndex + 1);
                
                // Combine headers with dataRows for complete dataset
                const fullData = [headers, ...dataRows];
                
                setTemplate({ workbook, sheet: selectedSheet, headers, data: fullData });
                setTemplateHeaders(headers);
              }
              
              // Reset suggestions reviewed state when loading a new template
              setSuggestionsReviewed(false);
              
              // Reset multi-tab mapping settings
              setEnableMultiTabMapping(false);
              setCategoryColumn('');
              setCategoryValues([]);
              setCategoryWorksheetMappings({});
              setActiveTab(null);
              setActiveWorksheet(null);
              setWorksheetMappings({});
            } else {
              // Process data file normally (unchanged)
              const selectedSheet = selectedDataSheet;
              const worksheet = workbook.Sheets[selectedSheet];
              
              // Get all data as array of arrays
              const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
              
              const headerRowIndex = dataHeaderRow - 1;
              const headers = jsonData[headerRowIndex] || [];
              
              // Generate demo descriptions for data headers
              const descriptions = {};
              headers.forEach((header, index) => {
                if (!header) return;
                
                // Create descriptive text based on header name
                const words = header.split(/[\s_.-]+/);
                const formattedHeader = words.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');
                
                if (index % 5 === 0) {
                  descriptions[header] = `<h4>${formattedHeader}</h4><p>Contains unique identifier values for each record. Use this for reference or linking to other systems.</p>`;
                } else if (index % 5 === 1) {
                  descriptions[header] = `<h4>${formattedHeader}</h4><p>This column stores ${formattedHeader.toLowerCase()} values from the source system. <span class="highlight">Important for data integrity</span>.</p>`;
                } else if (index % 5 === 2) {
                  descriptions[header] = `<h4>About ${formattedHeader}</h4><p>Contains formatted text data with ${formattedHeader.toLowerCase()} information. This data is used for reporting and analytics.</p>`;
                } else if (index % 5 === 3) {
                  descriptions[header] = `<h4>${formattedHeader} Details</h4><p>This column provides metadata about each record, including things like:</p><ul><li>Source system information</li><li>Last update timestamp</li><li>Validation status</li></ul>`;
                } else {
                  descriptions[header] = `<h4>${formattedHeader} Column</h4><p>This field contains supplementary information that may be useful for specific reporting needs. The content is <span class="highlight">variable in format</span>.</p>`;
                }
              });
              
              setDataHeaderDescriptions(descriptions);
              
              // Get data rows (all rows after the header row)
              const dataRows = jsonData.slice(headerRowIndex + 1);
              
              // Combine headers with dataRows for complete dataset
              const fullData = [headers, ...dataRows];
              
              setData({ workbook, sheet: selectedSheet, headers, data: fullData });
              setDataHeaders(headers);
              
              // Extract sample data for each column (up to 5 unique non-empty values)
              const samples = {};
              headers.forEach((header, colIndex) => {
                if (!header) return;
                
                const columnData = new Set();
                // Loop through the first 20 rows to find samples
                for (let rowIndex = 0; rowIndex < Math.min(dataRows.length, 20); rowIndex++) {
                  const row = dataRows[rowIndex];
                  if (row && colIndex < row.length && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== '') {
                    columnData.add(row[colIndex]);
                    if (columnData.size >= 5) break; // Collect up to 5 samples
                  }
                }
                
                // Convert Set to Array
                samples[header] = Array.from(columnData);
                
                // If we don't have enough samples, try to get more including empty values
                if (samples[header].length < 3 && dataRows.length > 0) {
                  samples[header] = [];
                  for (let rowIndex = 0; rowIndex < Math.min(dataRows.length, 5); rowIndex++) {
                    const row = dataRows[rowIndex];
                    if (row && colIndex < row.length) {
                      samples[header].push(row[colIndex]);
                    }
                  }
                }
              });
              
              setColumnSamples(samples);
              
              // If template headers already exist, generate suggested mappings
              if (templateHeaders.length > 0) {
                const { suggestions, scores } = generateFuzzyMappings(templateHeaders, headers);
                setSuggestedMappings(suggestions);
                setMappingScores(scores);
                setMappings(suggestions);
                
                // Reset suggestions reviewed state when loading new data
                setSuggestionsReviewed(false);
              }
              
              // Get unique values for category column if one is selected
              if (enableMultiTabMapping && categoryColumn) {
                updateCategoryValues(headers, dataRows, categoryColumn);
              }
            }
          } catch (error) {
            console.error(`Error processing ${fileType} sheet:`, error);
            setDebugInfo(`Error: ${error.message}`);
          } finally {
            setIsLoading(prev => ({ ...prev, [fileType]: false }));
          }
        };
        
        reader.onerror = () => {
          console.error(`Error reading ${fileType} file for processing`);
          setIsLoading(prev => ({ ...prev, [fileType]: false }));
        };
        
        reader.readAsBinaryString(file);
      };

      // Handle worksheet selection for multi-sheet processing
      const handleWorksheetSelection = (worksheet) => {
        setSelectedWorksheets(prev => {
          if (prev.includes(worksheet)) {
            // If already selected, remove it (unselect)
            return prev.filter(sheet => sheet !== worksheet);
          } else {
            // If not selected, add it
            return [...prev, worksheet];
          }
        });
      };

      // Select all worksheets
      const selectAllWorksheets = () => {
        setSelectedWorksheets(templateSheets);
      };

      // Clear all worksheet selections
      const clearWorksheetSelections = () => {
        setSelectedWorksheets([]);
      };
      
      // Handle changing header row for a specific worksheet
      const handleWorksheetHeaderRowChange = (worksheet, value) => {
        const newValue = Math.max(1, parseInt(value) || 1);
        setWorksheetHeaderRows(prev => ({
          ...prev,
          [worksheet]: newValue
        }));
      };
      
      // Handle changing requirement row for a specific worksheet
      const handleWorksheetRequirementRowChange = (worksheet, value) => {
        const newValue = Math.max(1, parseInt(value) || 1);
        setWorksheetRequirementRows(prev => ({
          ...prev,
          [worksheet]: newValue
        }));
      };

      // Enhanced fuzzy matching function
      const fuzzyMatch = (str1, str2) => {
        if (!str1 || !str2) return 0;
        
        // Normalize strings: lowercase, remove special chars, trim whitespace
        const cleanStr1 = String(str1).toLowerCase().replace(/[^a-z0-9]/gi, '');
        const cleanStr2 = String(str2).toLowerCase().replace(/[^a-z0-9]/gi, '');
        
        // Exact match after normalization is a perfect score
        if (cleanStr1 === cleanStr2) return 1.0;
        
        // Calculate Levenshtein distance-based similarity
        const len1 = cleanStr1.length;
        const len2 = cleanStr2.length;
        
        // If either string is empty, similarity is 0
        if (len1 === 0 || len2 === 0) return 0;
        
        // Check for containment (one string is part of the other)
        if (cleanStr1.includes(cleanStr2) || cleanStr2.includes(cleanStr1)) {
          // Length ratio determines strength of the match
          const containmentScore = Math.min(len1, len2) / Math.max(len1, len2);
          // Boost score for containment
          return Math.min(1.0, containmentScore + 0.3);
        }
        
        // Character by character matching, giving more weight to matching prefixes
        let matchScore = 0;
        const maxLen = Math.max(len1, len2);
        const minLen = Math.min(len1, len2);
        
        for (let i = 0; i < minLen; i++) {
          // Characters match
          if (cleanStr1[i] === cleanStr2[i]) {
            // Earlier matches are more important (prefix bonus)
            matchScore += 1 - (i / (2 * maxLen));
          }
        }
        
        // Normalize score
        return matchScore / maxLen;
      };

      // Generate suggested mappings based on enhanced fuzzy matching
      const generateFuzzyMappings = (templateHeaders, dataHeaders) => {
        const suggestions = {};
        const scores = {};
        
        templateHeaders.forEach(templateHeader => {
          if (!templateHeader) return;
          
          // Track all matches for this template header
          let matches = [];
          
          dataHeaders.forEach(dataHeader => {
            if (!dataHeader) return;
            
            const score = fuzzyMatch(templateHeader, dataHeader);
            if (score > 0.3) { // Consider any match above 30% similarity
              matches.push({ header: dataHeader, score });
            }
          });
          
          // Sort matches by score (highest first)
          matches.sort((a, b) => b.score - a.score);
          
          // Store scores for all potential matches
          scores[templateHeader] = matches;
          
          // Only use the best match if it's good enough (above 60% similarity)
          if (matches.length > 0 && matches[0].score > 0.6) {
            suggestions[templateHeader] = matches[0].header;
          }
        });
        
        return { suggestions, scores };
      };

      // Find worksheet suggestions for category values
      const findWorksheetSuggestions = (categoryValue) => {
        if (!categoryValue || !templateSheets.length) return [];
        
        // Get fuzzy matches between the category value and worksheet names
        const suggestions = [];
        
        templateSheets.forEach(sheet => {
          const score = fuzzyMatch(categoryValue, sheet);
          if (score > 0.3) { // Consider any match above 30% similarity
            suggestions.push({ sheet, score });
          }
        });
        
        // Sort by score (highest first)
        suggestions.sort((a, b) => b.score - a.score);
        
        return suggestions;
      };

      // Handle mapping change with enhanced for per-worksheet mapping
      const handleMappingChange = (templateHeader, dataHeader, category = null, worksheet = null) => {
        if (enableMultiTabMapping && category && worksheet) {
          // Update worksheet-specific mappings
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // Initialize nested objects if they don't exist
            if (!newMappings[category]) {
              newMappings[category] = {};
            }
            if (!newMappings[category][worksheet]) {
              newMappings[category][worksheet] = {};
            }
            
            // Update the mapping
            newMappings[category][worksheet][templateHeader] = dataHeader;
            return newMappings;
          });
        } else {
          // Update shared mappings
          setMappings(prev => ({
            ...prev,
            [templateHeader]: dataHeader
          }));
        }
      };

      // Update category values when category column changes
      const updateCategoryValues = (headers, dataRows, categoryCol) => {
        // Find the index of the category column
        const colIndex = headers.indexOf(categoryCol);
        
        if (colIndex === -1) {
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setWorksheetSuggestions({});
          return;
        }
        
        // Get unique values from the category column
        const uniqueValues = new Set();
        dataRows.forEach(row => {
          if (row && colIndex < row.length && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== '') {
            uniqueValues.add(String(row[colIndex]));
          }
        });
        
        const valueArray = Array.from(uniqueValues).sort();
        
        // Update state with the unique values
        setCategoryValues(valueArray);
        
        // Find worksheet suggestions for each category value
        const allSuggestions = {};
        
        // Initialize worksheet mappings for each category value (now as arrays)
        const initialMappings = {};
        
        valueArray.forEach(value => {
          // Get suggestions for this category value
          const suggestions = findWorksheetSuggestions(value);
          allSuggestions[value] = suggestions;
          
          // Initialize with the best match or first worksheet
          const bestMatch = suggestions.length > 0 ? suggestions[0].sheet : null;
          const initialSheets = [];
          
          // Add the best match if found
          if (bestMatch) {
            initialSheets.push(bestMatch);
          }
          
          // Add the main tab if selected and it's different from the best match
          if (includeMainTab && mainTabSelection && mainTabSelection !== bestMatch) {
            initialSheets.push(mainTabSelection);
          }
          
          // If no sheets selected yet, use the first available worksheet
          if (initialSheets.length === 0 && templateSheets.length > 0) {
            initialSheets.push(templateSheets[0]);
          }
          
          initialMappings[value] = initialSheets;
        });
        
        setCategoryWorksheetMappings(initialMappings);
        setWorksheetSuggestions(allSuggestions);
        
        // Set the first category value as the active tab
        if (valueArray.length > 0) {
          setActiveTab(valueArray[0]);
          // Set the first worksheet as active for this category
          if (initialMappings[valueArray[0]] && initialMappings[valueArray[0]].length > 0) {
            setActiveWorksheet(initialMappings[valueArray[0]][0]);
          }
        }
        
        // Initialize worksheet mappings for each category and worksheet
        const initialWorksheetMappings = {};
        
        // For each category and its worksheets, initialize mappings with suggested mappings
        Object.entries(initialMappings).forEach(([category, worksheets]) => {
          initialWorksheetMappings[category] = {};
          
          worksheets.forEach(worksheet => {
            // For the main tab, use the suggested mappings
            if (worksheet === mainTabSelection) {
              initialWorksheetMappings[category][worksheet] = { ...suggestedMappings };
            } else {
              // For other worksheets, initialize with empty mappings
              initialWorksheetMappings[category][worksheet] = {};
            }
          });
        });
        
        setWorksheetMappings(initialWorksheetMappings);
      };

      // Handle category column change
      const handleCategoryColumnChange = (column) => {
        setCategoryColumn(column);
        
        if (!column) {
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setWorksheetSuggestions({});
          setActiveTab(null);
          setActiveWorksheet(null);
          return;
        }
        
        // Retrieve the data rows
        if (!data || !data.data || data.data.length <= 1) return;
        
        const dataRows = data.data.slice(1); // Skip header row
        
        updateCategoryValues(data.headers, dataRows, column);
      };

      // Add a worksheet to a category's mapping
      const addWorksheetToCategory = (categoryValue, worksheet, isMain = false) => {
        setCategoryWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          // Initialize array if needed
          if (!newMappings[categoryValue]) {
            newMappings[categoryValue] = [];
          }
          
          // Add worksheet if not already included
          if (!newMappings[categoryValue].includes(worksheet)) {
            if (isMain) {
              // Add as first item if it's the main tab
              newMappings[categoryValue] = [worksheet, ...newMappings[categoryValue]];
            } else {
              // Add to the end otherwise
              newMappings[categoryValue] = [...newMappings[categoryValue], worksheet];
            }
          }
          
          return newMappings;
        });
        
        // Initialize worksheet mappings for this category and worksheet
        setWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          // Initialize nested objects if they don't exist
          if (!newMappings[categoryValue]) {
            newMappings[categoryValue] = {};
          }
          
          // Only initialize if it doesn't exist yet
          if (!newMappings[categoryValue][worksheet]) {
            // For main tab, use suggested mappings; otherwise empty
            if (worksheet === mainTabSelection) {
              newMappings[categoryValue][worksheet] = { ...suggestedMappings };
            } else {
              newMappings[categoryValue][worksheet] = {};
            }
          }
          
          return newMappings;
        });
      };

      // Remove a worksheet from a category's mapping
      const removeWorksheetFromCategory = (categoryValue, worksheet) => {
        setCategoryWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          if (newMappings[categoryValue]) {
            newMappings[categoryValue] = newMappings[categoryValue].filter(sheet => sheet !== worksheet);
          }
          
          return newMappings;
        });
        
        // Clean up mappings for this worksheet
        setWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          if (newMappings[categoryValue] && newMappings[categoryValue][worksheet]) {
            delete newMappings[categoryValue][worksheet];
          }
          
          return newMappings;
        });
        
        // If the active worksheet is being removed, select another one
        if (activeTab === categoryValue && activeWorksheet === worksheet) {
          // Find another worksheet for this category
          const remainingWorksheets = categoryWorksheetMappings[categoryValue]?.filter(
            sheet => sheet !== worksheet
          ) || [];
          
          if (remainingWorksheets.length > 0) {
            setActiveWorksheet(remainingWorksheets[0]);
          } else {
            setActiveWorksheet(null);
          }
        }
      };

      // Handle main tab selection change
      const handleMainTabChange = (tabName) => {
        setMainTabSelection(tabName);
        
        // If including main tab is enabled, update all category mappings
        if (includeMainTab && categoryValues.length > 0) {
          setCategoryWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // For each category
            Object.keys(newMappings).forEach(category => {
              // Remove previous main tab if it exists
              if (mainTabSelection && newMappings[category].includes(mainTabSelection)) {
                newMappings[category] = newMappings[category].filter(sheet => sheet !== mainTabSelection);
              }
              
              // Add new main tab if not already included (at the beginning of the array)
              if (tabName && !newMappings[category].includes(tabName)) {
                newMappings[category] = [tabName, ...newMappings[category]];
              }
            });
            
            return newMappings;
          });
          
          // Update worksheet mappings too
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // For each category
            Object.keys(prev).forEach(category => {
              // If the old main tab had mappings, and the new main tab doesn't,
              // copy those mappings to the new main tab
              if (prev[category] && prev[category][mainTabSelection] && tabName) {
                if (!newMappings[category]) {
                  newMappings[category] = {};
                }
                
                // Initialize new main tab with suggested mappings or old mappings
                newMappings[category][tabName] = { ...prev[category][mainTabSelection] };
                
                // Clean up old main tab if not in the category's worksheet list
                if (!categoryWorksheetMappings[category]?.includes(mainTabSelection)) {
                  delete newMappings[category][mainTabSelection];
                }
              }
            });
            
            return newMappings;
          });
        }
      };

      // Handle changing the active worksheet for the current category
      const handleWorksheetTabChange = (worksheet) => {
        setActiveWorksheet(worksheet);
      };

      // Toggle including main tab
      const toggleIncludeMainTab = (e) => {
        const include = e.target.checked;
        setIncludeMainTab(include);
        
        // Update all category mappings
        if (categoryValues.length > 0) {
          setCategoryWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // For each category
            Object.keys(newMappings).forEach(category => {
              if (include) {
                // Add main tab if not already included
                if (mainTabSelection && !newMappings[category].includes(mainTabSelection)) {
                  newMappings[category] = [mainTabSelection, ...newMappings[category]];
                }
              } else {
                // Remove main tab if it exists
                if (mainTabSelection && newMappings[category].includes(mainTabSelection)) {
                  newMappings[category] = newMappings[category].filter(sheet => sheet !== mainTabSelection);
                }
              }
            });
            
            return newMappings;
          });
          
          // Clear active worksheet if it was the main tab
          if (!include && activeWorksheet === mainTabSelection) {
            // Find another worksheet for this category
            const remainingWorksheets = categoryWorksheetMappings[activeTab]?.filter(
              sheet => sheet !== mainTabSelection
            ) || [];
            
            if (remainingWorksheets.length > 0) {
              setActiveWorksheet(remainingWorksheets[0]);
            } else {
              setActiveWorksheet(null);
            }
          }
        }
      };

      // Accept all suggestions for the current worksheet mapping
      const acceptAllSuggestions = () => {
        if (enableMultiTabMapping && activeTab && activeWorksheet) {
          // Update worksheet-specific mappings with suggestions
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // Initialize nested objects if they don't exist
            if (!newMappings[activeTab]) {
              newMappings[activeTab] = {};
            }
            if (!newMappings[activeTab][activeWorksheet]) {
              newMappings[activeTab][activeWorksheet] = {};
            }
            
            // Apply all suggested mappings
            Object.entries(suggestedMappings).forEach(([templateHeader, dataHeader]) => {
              newMappings[activeTab][activeWorksheet][templateHeader] = dataHeader;
            });
            
            return newMappings;
          });
        } else {
          // Update shared mappings
          setMappings(suggestedMappings);
        }
        
        setSuggestionsReviewed(true);
      };
      
      // Accept a specific mapping suggestion
      const acceptSuggestion = (templateHeader) => {
        if (!suggestedMappings[templateHeader]) return;
        
        if (enableMultiTabMapping && activeTab && activeWorksheet) {
          // Update worksheet-specific mapping
          handleMappingChange(templateHeader, suggestedMappings[templateHeader], activeTab, activeWorksheet);
        } else {
          // Update shared mappings
          setMappings(prev => ({
            ...prev,
            [templateHeader]: suggestedMappings[templateHeader]
          }));
        }
      };
      
      // Clear a specific mapping
      const clearMapping = (templateHeader, category = null, worksheet = null) => {
        if (enableMultiTabMapping && category && worksheet) {
          // Update worksheet-specific mappings
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            if (newMappings[category] && 
                newMappings[category][worksheet] && 
                newMappings[category][worksheet][templateHeader]) {
              delete newMappings[category][worksheet][templateHeader];
            }
            
            return newMappings;
          });
        } else {
          // Update shared mappings
          setMappings(prev => {
            const newMappings = { ...prev };
            delete newMappings[templateHeader];
            return newMappings;
          });
        }
      };

      // Validate mappings before proceeding
      const validateMappings = (category = null, worksheet = null) => {
        // Determine which mappings to check
        let mappingsToCheck;
        
        if (enableMultiTabMapping && category && worksheet && 
            worksheetMappings[category] && worksheetMappings[category][worksheet]) {
          mappingsToCheck = worksheetMappings[category][worksheet];
        } else {
          mappingsToCheck = mappings;
        }
        
        const missingRequiredFields = [];
        
        // Get the relevant headers and requirements for this worksheet
        let headers, requirements;
        
        if (worksheet && useSheetSpecificHeaders && worksheetHeadersMap[worksheet]) {
          headers = worksheetHeadersMap[worksheet] || [];
          requirements = worksheetRequirementsMap[worksheet] || {};
        } else {
          headers = templateHeaders;
          requirements = fieldRequirements;
        }
        
        headers.forEach(header => {
          if (!header) return;
          
          const isRequired = requirements[header] === 'Required';
          const isMapped = mappingsToCheck[header] && mappingsToCheck[header] !== '';
          
          if (isRequired && !isMapped) {
            missingRequiredFields.push(header);
          }
        });
        
        return {
          valid: missingRequiredFields.length === 0,
          missingFields: missingRequiredFields
        };
      };

      // Map data based on current mappings
      const mapData = () => {
        if (!template || !data) return;
        
        setIsLoading(prev => ({ ...prev, mapping: true }));
        
        try {
          if (enableMultiTabMapping) {
            // Handle multi-tab mapping with worksheet-specific mappings
            const mappedDataByKey = {};
            
            // Find the index of the category column
            const categoryColIndex = data.headers.indexOf(categoryColumn);
            
            if (categoryColIndex === -1) {
              throw new Error("Category column not found in data headers");
            }
            
            // Process all data rows (including handling the main tab specially)
            const allDataRows = data.data.slice(1); // Skip header row
            
            // Check if we should map all data to the main tab
            if (includeMainTab && mainTabSelection) {
              // Get the correct headers for the main tab
              const mainTabHeaders = useSheetSpecificHeaders 
                ? worksheetHeadersMap[mainTabSelection] || template.headers
                : template.headers;
              
              const mainTabMappedRows = [mainTabHeaders]; // Start with main tab headers
              
              // Create a mapping key for the main tab (use "ALL" as category to distinguish)
              const mainTabKey = `ALL:${mainTabSelection}`;
              
              // Get the main tab mappings from any category that uses it, or fall back to default mappings
              let mainTabMappings = {}; 
              
              // Find the first category that uses the main tab
              const categoryWithMainTab = Object.keys(categoryWorksheetMappings).find(
                catKey => categoryWorksheetMappings[catKey].includes(mainTabSelection)
              );
              
              if (categoryWithMainTab && 
                  worksheetMappings[categoryWithMainTab] && 
                  worksheetMappings[categoryWithMainTab][mainTabSelection]) {
                mainTabMappings = worksheetMappings[categoryWithMainTab][mainTabSelection];
              } else {
                // Fall back to shared mappings
                mainTabMappings = mappings;
              }
              
              // Map ALL data rows to the main tab
              allDataRows.forEach(dataRow => {
                const mappedRow = new Array(mainTabHeaders.length).fill('');
                
                // For each template header
                mainTabHeaders.forEach((templateHeader, templateColIndex) => {
                  if (!templateHeader) return;
                  
                  const dataHeader = mainTabMappings[templateHeader];
                  
                  if (dataHeader) {
                    // Find the index of this header in the data
                    const dataColIndex = data.headers.indexOf(dataHeader);
                    
                    if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                      mappedRow[templateColIndex] = dataRow[dataColIndex];
                    }
                  }
                });
                
                mainTabMappedRows.push(mappedRow);
              });
              
              // Store mapped data for the main tab (all data)
              mappedDataByKey[mainTabKey] = {
                category: "All Data",
                worksheet: mainTabSelection,
                data: mainTabMappedRows,
                isMainTab: true,
                headers: mainTabHeaders,
                requirements: useSheetSpecificHeaders 
                  ? worksheetRequirementsMap[mainTabSelection] || {}
                  : fieldRequirements,
                headerRow: useSheetSpecificHeaders
                  ? worksheetHeaderRows[mainTabSelection] || templateHeaderRow
                  : templateHeaderRow
              };
            }
            
            // Group data rows by category for category-specific worksheets
            const groupedData = {};
            
            // Process each data row
            allDataRows.forEach(dataRow => {
              // Ensure the row has data in the category column
              if (dataRow && categoryColIndex < dataRow.length) {
                const categoryValue = String(dataRow[categoryColIndex] || "");
                
                // Create array for this category if it doesn't exist
                if (!groupedData[categoryValue]) {
                  groupedData[categoryValue] = [];
                }
                
                // Add row to the appropriate category
                groupedData[categoryValue].push(dataRow);
              }
            });
            
            // Process each category group and its target worksheets
            Object.keys(groupedData).forEach(categoryValue => {
              const targetWorksheets = categoryWorksheetMappings[categoryValue] || [];
              
              if (targetWorksheets.length === 0) {
                console.warn(`No target worksheets defined for category: ${categoryValue}`);
                return;
              }
              
              const rows = groupedData[categoryValue];
              
              // For each target worksheet, create a separate mapping
              targetWorksheets.forEach(targetWorksheet => {
                // Skip main tab here if we already processed it - avoiding duplicate mapping
                if (includeMainTab && targetWorksheet === mainTabSelection) {
                  return;
                }
                
                // Get the correct headers for this worksheet
                const templateHeadersArr = useSheetSpecificHeaders 
                  ? worksheetHeadersMap[targetWorksheet] || template.headers
                  : template.headers;
                
                const mappedRows = [templateHeadersArr]; // Start with template headers
                
                // Get the correct mappings for this category/worksheet
                let currentMappings;
                
                // Use worksheet-specific mappings if available
                if (worksheetMappings[categoryValue] && worksheetMappings[categoryValue][targetWorksheet]) {
                  currentMappings = worksheetMappings[categoryValue][targetWorksheet];
                } else {
                  // Fall back to shared mappings
                  currentMappings = mappings;
                }
                
                // Map each data row
                rows.forEach(dataRow => {
                  const mappedRow = new Array(templateHeadersArr.length).fill('');
                  
                  // For each template header
                  templateHeadersArr.forEach((templateHeader, templateColIndex) => {
                    if (!templateHeader) return;
                    
                    const dataHeader = currentMappings[templateHeader];
                    
                    if (dataHeader) {
                      // Find the index of this header in the data
                      const dataColIndex = data.headers.indexOf(dataHeader);
                      
                      if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                        mappedRow[templateColIndex] = dataRow[dataColIndex];
                      }
                    }
                  });
                  
                  mappedRows.push(mappedRow);
                });
                
                // Unique key for category + worksheet combination
                const mappingKey = `${categoryValue}:${targetWorksheet}`;
                
                // Store mapped data for this category-worksheet combination
                mappedDataByKey[mappingKey] = {
                  category: categoryValue,
                  worksheet: targetWorksheet,
                  data: mappedRows,
                  // Store info about headers and requirements for validation
                  headers: templateHeadersArr,
                  requirements: useSheetSpecificHeaders 
                    ? worksheetRequirementsMap[targetWorksheet] || {}
                    : fieldRequirements,
                  // Store the header row information for the target worksheet
                  headerRow: useSheetSpecificHeaders
                    ? worksheetHeaderRows[targetWorksheet] || templateHeaderRow
                    : templateHeaderRow
                };
              });
            });
            
            // Set the mapped data with all category mappings
            setMappedData(mappedDataByKey);
          } else {
            // Standard single-worksheet mapping
            const mappedRows = [];
            const templateHeadersArr = template.headers;
            
            // Start with a row containing template headers
            mappedRows.push(templateHeadersArr);
            
            // For each data row (skip header)
            for (let i = 1; i < data.data.length; i++) {
              const dataRow = data.data[i];
              const mappedRow = new Array(templateHeadersArr.length).fill('');
              
              // For each template header
              templateHeadersArr.forEach((templateHeader, templateColIndex) => {
                if (!templateHeader) return;
                
                const dataHeader = mappings[templateHeader];
                
                if (dataHeader) {
                  // Find the index of this header in the data
                  const dataColIndex = data.headers.indexOf(dataHeader);
                  
                  if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                    mappedRow[templateColIndex] = dataRow[dataColIndex];
                  }
                }
              });
              
              mappedRows.push(mappedRow);
            }
            
            setMappedData(mappedRows);
          }
          
          setStep(3);
        } catch (error) {
          console.error('Error mapping data:', error);
          setDebugInfo(`Error mapping data: ${error.message}`);
        } finally {
          setIsLoading(prev => ({ ...prev, mapping: false }));
        }
      };

      // Update export options
      const handleExportOptionChange = (option, value) => {
        setExportOptions(prev => ({
          ...prev,
          [option]: value
        }));
      };

      // Export data directly into a copy of the original template
      const exportExcel = () => {
        if (!mappedData || !template || !templateFile) return;
        
        setIsLoading(prev => ({ ...prev, export: true }));
        
        try {
          // Read the template file again to get a fresh copy
          const reader = new FileReader();
          
          reader.onload = (evt) => {
            try {
              const binaryString = evt.target.result;
              
              // Create a new workbook from the template file with select options for better compatibility
              const readOpts = { 
                type: 'binary', 
                cellFormula: true, 
                cellDates: true,
                cellNF: true
              };
              
              // Only add certain options if they are enabled
              if (exportOptions.preserveStyles) {
                readOpts.cellStyles = true;
              }
              
              if (exportOptions.includeMacros) {
                readOpts.bookVBA = true;
                readOpts.bookFiles = true;
              }
              
              const workbook = XLSX.read(binaryString, readOpts);
              
              // IMPORTANT: Store the source styles, formats, and template info to be referenced later
              const templateInfo = {};
              
              // Process all worksheets to build a comprehensive style library
              workbook.SheetNames.forEach(sheetName => {
                const worksheet = workbook.Sheets[sheetName];
                
                templateInfo[sheetName] = {
                  merges: worksheet['!merges'] ? [...worksheet['!merges']] : [],
                  styles: {},
                  formats: {},
                  formulas: {},
                  validations: worksheet['!dataValidations'] ? [...worksheet['!dataValidations']] : []
                };
                
                // Extract cell styles, formats, and formulas
                Object.keys(worksheet).forEach(cellRef => {
                  if (cellRef[0] === '!') return; // Skip metadata
                  
                  const cell = worksheet[cellRef];
                  
                  // Store cell info for reference
                  if (cell) {
                    // Deep clone style objects to avoid reference issues
                    if (exportOptions.preserveStyles && cell.s) {
                      templateInfo[sheetName].styles[cellRef] = JSON.parse(JSON.stringify(cell.s));
                    }
                    
                    // Store number format
                    if (exportOptions.applyColumnFormats && cell.z) {
                      templateInfo[sheetName].formats[cellRef] = cell.z;
                    }
                    
                    // Store formulas if enabled
                    if (exportOptions.preserveFormulas && cell.f) {
                      templateInfo[sheetName].formulas[cellRef] = cell.f;
                    }
                  }
                });
              });
              
              // Function to apply styles and formatting to cells
              const applyTemplateStyles = (worksheetName, worksheet, cellRef, value, rowOffset = 0) => {
                // Create the cell if it doesn't exist
                if (!worksheet[cellRef]) {
                  worksheet[cellRef] = { v: value };
                } else {
                  worksheet[cellRef].v = value;
                }
                
                // Determine appropriate data type
                if (typeof value === 'number') {
                  worksheet[cellRef].t = 'n';
                } else if (typeof value === 'boolean') {
                  worksheet[cellRef].t = 'b';
                } else if (value instanceof Date) {
                  worksheet[cellRef].t = 'd';
                } else {
                  worksheet[cellRef].t = 's';
                }
                
                if (!templateInfo[worksheetName]) return;
                
                const decodedCell = XLSX.utils.decode_cell(cellRef);
                const colIndex = decodedCell.c;
                
                // Find column style reference - look for the same column in the template
                // First try header row, then template data rows
                const colLetter = XLSX.utils.encode_col(colIndex);
                
                // Try to find style from the template using the same column
                if (exportOptions.preserveStyles) {
                  // First look for exact cell style
                  if (templateInfo[worksheetName].styles[cellRef]) {
                    worksheet[cellRef].s = JSON.parse(JSON.stringify(templateInfo[worksheetName].styles[cellRef]));
                  } else {
                    // Look for any cell style in the same column (for new rows)
                    // Check sample cells from the template in the same column
                    let foundStyle = false;
                    
                    // Try header row first
                    const headerCellRef = colLetter + '1';
                    if (templateInfo[worksheetName].styles[headerCellRef]) {
                      worksheet[cellRef].s = JSON.parse(JSON.stringify(templateInfo[worksheetName].styles[headerCellRef]));
                      foundStyle = true;
                    }
                    
                    // If no style found yet, look for any data row with a style in this column
                    if (!foundStyle) {
                      for (let r = 2; r < 10; r++) { // Check first few rows
                        const dataRowCellRef = colLetter + r;
                        if (templateInfo[worksheetName].styles[dataRowCellRef]) {
                          worksheet[cellRef].s = JSON.parse(JSON.stringify(templateInfo[worksheetName].styles[dataRowCellRef]));
                          break;
                        }
                      }
                    }
                  }
                }
                
                // Apply number format if enabled
                if (exportOptions.applyColumnFormats) {
                  // First look for exact cell format
                  if (templateInfo[worksheetName].formats[cellRef]) {
                    worksheet[cellRef].z = templateInfo[worksheetName].formats[cellRef];
                  } else {
                    // Look for any cell format in the same column
                    for (const templateCellRef in templateInfo[worksheetName].formats) {
                      const templateCell = XLSX.utils.decode_cell(templateCellRef);
                      if (templateCell.c === colIndex) {
                        worksheet[cellRef].z = templateInfo[worksheetName].formats[templateCellRef];
                        break;
                      }
                    }
                  }
                }
                
                // Apply formulas if enabled - adjust row references where needed
                if (exportOptions.preserveFormulas) {
                  const baseRow = decodedCell.r - rowOffset; // Calculate base row to check template formulas
                  
                  // Try to find a matching formula from the template
                  if (baseRow >= 0) {
                    const templateCellRef = XLSX.utils.encode_cell({c: colIndex, r: baseRow});
                    
                    if (templateInfo[worksheetName].formulas[templateCellRef]) {
                      let formula = templateInfo[worksheetName].formulas[templateCellRef];
                      
                      // For formulas that reference other cells, adjust row references
                      // This is a simplified approach - complex formulas might need more sophisticated adjustment
                      if (rowOffset > 0) {
                        // Replace cell references like A1, B2, etc. with adjusted row numbers
                        formula = formula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                          const newRow = parseInt(row) + rowOffset;
                          return `${col}${newRow}`;
                        });
                      }
                      
                      worksheet[cellRef].f = formula;
                    }
                  }
                }
              };
              
              // Function to update worksheet with mapped data
              const updateWorksheet = (worksheetName, mappedRows, headerRowIndex = 0) => {
                // Get or create the worksheet
                let worksheet = workbook.Sheets[worksheetName];
                
                if (!worksheet) {
                  console.warn(`Worksheet ${worksheetName} not found in template, creating new worksheet`);
                  worksheet = {};
                  workbook.Sheets[worksheetName] = worksheet;
                  workbook.SheetNames.push(worksheetName);
                }
                
                // Calculate start row where data should be inserted
                const dataStartRow = headerRowIndex + 1; // Row after header
                
                // Clear existing data in the worksheet to prevent conflicts
                // First find the existing range
                if (worksheet['!ref']) {
                  const range = XLSX.utils.decode_range(worksheet['!ref']);
                  
                  // Clear cells after the header row (preserve header)
                  for (let r = dataStartRow; r <= range.e.r; r++) {
                    for (let c = range.s.c; c <= range.e.c; c++) {
                      const cellRef = XLSX.utils.encode_cell({r, c});
                      delete worksheet[cellRef];
                    }
                  }
                }
                
                // Now add the mapped data
                // Start with row after header
                for (let rowIndex = 1; rowIndex < mappedRows.length; rowIndex++) {
                  const dataRow = mappedRows[rowIndex];
                  const targetRowIndex = dataStartRow + (rowIndex - 1); // -1 because we skip header
                  
                  for (let colIndex = 0; colIndex < dataRow.length; colIndex++) {
                    const value = dataRow[colIndex];
                    
                    // Skip undefined or null values
                    if (value === undefined || value === null) continue;
                    
                    // Calculate cell reference
                    const cellRef = XLSX.utils.encode_cell({r: targetRowIndex, c: colIndex});
                    
                    // Add cell with styles from template
                    applyTemplateStyles(worksheetName, worksheet, cellRef, value, targetRowIndex - dataStartRow);
                  }
                }
                
                // Update the range to include all added data
                const maxRow = dataStartRow + mappedRows.length - 2; // -2 to account for header skip
                const maxCol = mappedRows[0].length - 1;
                
                // Get current range or default to first cell
                let rangeStart = {r: 0, c: 0};
                let rangeEnd = {r: maxRow, c: maxCol};
                
                if (worksheet['!ref']) {
                  const currentRange = XLSX.utils.decode_range(worksheet['!ref']);
                  rangeStart = {r: currentRange.s.r, c: currentRange.s.c};
                  rangeEnd = {
                    r: Math.max(currentRange.e.r, maxRow),
                    c: Math.max(currentRange.e.c, maxCol)
                  };
                }
                
                worksheet['!ref'] = XLSX.utils.encode_range({
                  s: rangeStart,
                  e: rangeEnd
                });
                
                // Restore merges if available and enabled
                if (exportOptions.preserveStyles && templateInfo[worksheetName] && templateInfo[worksheetName].merges) {
                  worksheet['!merges'] = [...templateInfo[worksheetName].merges];
                }
                
                // Restore data validations if available and enabled
                if (exportOptions.preserveValidation && templateInfo[worksheetName] && templateInfo[worksheetName].validations) {
                  worksheet['!dataValidations'] = [...templateInfo[worksheetName].validations];
                }
              };
              
              // Process all mapped data
              if (enableMultiTabMapping) {
                // Multi-tab export
                Object.keys(mappedData).forEach(mappingKey => {
                  const { worksheet: worksheetName, data: mappedRows, headerRow = templateHeaderRow } = mappedData[mappingKey];
                  
                  // Update the worksheet with this data
                  updateWorksheet(worksheetName, mappedRows, headerRow - 1); // Convert to 0-based
                });
              } else {
                // Single worksheet export
                updateWorksheet(template.sheet, mappedData, templateHeaderRow - 1); // Convert to 0-based
              }
              
              // Clean up options to minimize compatibility issues
              const writeOpts = {
                bookType: 'xlsx',
                type: 'binary'
              };
              
              // Generate a filename based on the template
              const filename = templateFile.name.replace(/\.[^/.]+$/, '') + '_filled.xlsx';
              
              // Write the workbook to a file
              const wbout = XLSX.write(workbook, writeOpts);
              
              // Convert binary string to ArrayBuffer for more reliable download
              const buf = new ArrayBuffer(wbout.length);
              const view = new Uint8Array(buf);
              for (let i = 0; i < wbout.length; i++) {
                view[i] = wbout.charCodeAt(i) & 0xFF;
              }
              
              // Create Blob and download
              const blob = new Blob([buf], {type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = filename;
              a.click();
              
              // Clean up
              setTimeout(() => {
                URL.revokeObjectURL(url);
              }, 100);
              
              alert("Export complete! The file will download with your template's formatting preserved.");
            } catch (error) {
              console.error('Error processing template for export:', error);
              setDebugInfo(`Error exporting: ${error.message}`);
              alert(`Error during export: ${error.message}`);
            } finally {
              setIsLoading(prev => ({ ...prev, export: false }));
            }
          };
          
          reader.onerror = () => {
            console.error('Error reading template file for export');
            setIsLoading(prev => ({ ...prev, export: false }));
          };
          
          reader.readAsBinaryString(templateFile);
        } catch (error) {
          console.error('Error exporting Excel file:', error);
          setIsLoading(prev => ({ ...prev, export: false }));
        }
      };

      // Continue to mapping step
      const proceedToMapping = () => {
        if (template && data) {
          setStep(2);
        }
      };

      // Toggle requirement row availability
      const toggleRequirementRow = (e) => {
        setRequirementRowAvailable(e.target.checked);
      };
      
      // Toggle multi-tab mapping
      const toggleMultiTabMapping = (e) => {
        const enabled = e.target.checked;
        setEnableMultiTabMapping(enabled);
        
        if (!enabled) {
          setCategoryColumn('');
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setWorksheetSuggestions({});
          setActiveTab(null);
          setActiveWorksheet(null);
          setWorksheetMappings({});
        }
      };
      
      // Toggle sheet-specific headers
      const toggleSheetSpecificHeaders = (e) => {
        setUseSheetSpecificHeaders(e.target.checked);
      };
      
      // Toggle format preservation
      const toggleFormatPreservation = (e) => {
        setPreserveFormatting(e.target.checked);
      };

      // Helper function to check if a header has notes
      const headerHasNotes = (header, sheetName = null) => {
        if (sheetName && useSheetSpecificHeaders && worksheetNotesMap[sheetName]) {
          return worksheetNotesMap[sheetName][header] && worksheetNotesMap[sheetName][header].trim() !== '';
        }
        
        return templateHeaderNotes[header] && templateHeaderNotes[header].trim() !== '';
      };

      // Helper to get the header note text for a specific header
      const getHeaderNote = (header, sheetName = null) => {
        if (sheetName && useSheetSpecificHeaders && worksheetNotesMap[sheetName]) {
          return worksheetNotesMap[sheetName][header] || '';
        }
        
        return templateHeaderNotes[header] || '';
      };

      // Helper to get the requirement for a specific header
      const getHeaderRequirement = (header, sheetName = null) => {
        if (sheetName && useSheetSpecificHeaders && worksheetRequirementsMap[sheetName]) {
          return worksheetRequirementsMap[sheetName][header] || 'Optional';
        }
        
        return fieldRequirements[header] || 'Optional';
      };

      // Dynamically check if any notes are available
      const hasAnyNotes = Object.values(templateHeaderNotes).some(note => note && note.trim() !== '');
      
      // Check if any data descriptions are available
      const hasAnyDataDescriptions = Object.values(dataHeaderDescriptions).some(
        desc => desc && desc.trim() !== ''
      );

      // Function to determine if a note needs the "large" class
      const isLargeNote = (note) => {
        return note && note.length > 150;
      };
      
      // Get confidence level label based on score
      const getConfidenceLevel = (score) => {
        if (score >= 0.8) return 'High';
        if (score >= 0.6) return 'Medium';
        return 'Low';
      };
      
      // Get confidence level class based on score
      const getConfidenceClass = (score) => {
        if (score >= 0.8) return 'confidence-high';
        if (score >= 0.6) return 'confidence-medium';
        return 'confidence-low';
      };
      
      // Get the number of unmapped required fields for a specific worksheet
      const getUnmappedRequiredFieldsCount = (category = null, worksheet = null) => {
        // Get the mappings to check
        let currentMappings;
        
        if (enableMultiTabMapping && category && worksheet && 
            worksheetMappings[category] && worksheetMappings[category][worksheet]) {
          currentMappings = worksheetMappings[category][worksheet];
        } else {
          currentMappings = mappings;
        }
        
        // Get the headers and requirements for this worksheet
        let headers, requirements;
        
        if (worksheet && useSheetSpecificHeaders && worksheetHeadersMap[worksheet]) {
          headers = worksheetHeadersMap[worksheet];
          requirements = worksheetRequirementsMap[worksheet] || {};
        } else {
          headers = templateHeaders;
          requirements = fieldRequirements;
        }
        
        return headers.filter(header => {
          return (
            header && 
            requirements[header] === 'Required' && 
            (!currentMappings[header] || currentMappings[header] === '')
          );
        }).length;
      };

      // Get current mappings based on active category and worksheet
      const getCurrentMappings = () => {
        if (enableMultiTabMapping && activeTab && activeWorksheet && 
            worksheetMappings[activeTab] && worksheetMappings[activeTab][activeWorksheet]) {
          return worksheetMappings[activeTab][activeWorksheet];
        }
        return mappings;
      };

      return (
        <div className={`min-h-screen transition-colors duration-200 ${isDarkMode ? 'dark bg-gray-900' : 'bg-gray-50'}`}>
          <div className="p-4 md:p-6 max-w-5xl mx-auto">
            <h1 className="text-2xl md:text-3xl font-bold mb-6 text-center dark:text-white flex justify-center items-center">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-8 h-8 mr-2 text-excel-500">
                <path d="M18.375 2.25c-1.035 0-1.875.84-1.875 1.875v15.75c0 1.035.84 1.875 1.875 1.875h.75c1.035 0 1.875-.84 1.875-1.875V4.125c0-1.036-.84-1.875-1.875-1.875h-.75zM9.75 8.625c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v11.25c0 1.035-.84 1.875-1.875 1.875h-.75a1.875 1.875 0 01-1.875-1.875V8.625zM3 13.125c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v6.75c0 1.035-.84 1.875-1.875 1.875h-.75A1.875 1.875 0 013 19.875v-6.75z" />
              </svg>
              Excel Template Mapper
            </h1>
            
            <div className="mb-8 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm dark:text-gray-200">
              <h2 className="text-lg md:text-xl font-semibold mb-2 text-excel-600 dark:text-excel-400">How it works:</h2>
              <ol className="list-decimal pl-6">
                <li className="mb-1">Upload your Excel template file and select the worksheet(s), header row, and required fields row (if available)</li>
                <li className="mb-1">Upload your data Excel file and select the worksheet and header row</li>
                <li className="mb-1">Review and adjust the column mappings if needed</li>
                <li className="mb-1">Generate your mapped Excel file with all formatting preserved</li>
              </ol>
            </div>
            
            <div className="flex mb-6 overflow-x-auto pb-1">
              <div className={`px-4 py-2 rounded-t-lg mr-2 transition-colors duration-150 ${step === 1 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 1: Upload Files
              </div>
              <div className={`px-4 py-2 rounded-t-lg mr-2 transition-colors duration-150 ${step === 2 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 2: Map Columns
              </div>
              <div className={`px-4 py-2 rounded-t-lg transition-colors duration-150 ${step === 3 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 3: Export
              </div>
            </div>
            
            {step === 1 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <div className="mb-8 border-b pb-6 dark:border-gray-700">
                  <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">1. Template Excel File</h2>
                  
                  <div className="mb-4">
                    <label className="block mb-2 text-gray-700 dark:text-gray-300">Upload Template File</label>
                    <div className="relative">
                      <input
                        type="file"
                        accept=".xlsx, .xls"
                        onChange={(e) => handleFileUpload(e, 'template')}
                        className="block w-full text-base text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded p-2 
                          file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold
                          file:bg-excel-50 file:text-excel-700 dark:file:bg-gray-700 dark:file:text-gray-300
                          hover:file:bg-excel-100 dark:hover:file:bg-gray-600"
                      />
                      {isLoading.template && (
                        <div className="absolute inset-0 bg-white/70 dark:bg-gray-800/70 flex items-center justify-center">
                          <svg className="animate-spin h-5 w-5 text-excel-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {templateSheets.length > 0 && (
                    <>
                      <div className="mb-4 p-4 border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/20 rounded-md">
                        <h3 className="font-medium text-blue-800 dark:text-blue-300 mb-2">Template Worksheets</h3>
                        
                        <div className="flex items-center mb-3 space-x-2">
                          <div className="flex items-center">
                            <input
                              type="checkbox"
                              id="useSheetSpecificHeaders"
                              checked={useSheetSpecificHeaders}
                              onChange={toggleSheetSpecificHeaders}
                              className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                            />
                            <label htmlFor="useSheetSpecificHeaders" className="text-gray-700 dark:text-gray-300 font-medium">
                              Map using worksheet-specific headers
                            </label>
                          </div>
                          
                          <div className="flex items-center">
                            <input
                              type="checkbox"
                              id="preserveFormatting"
                              checked={preserveFormatting}
                              onChange={toggleFormatPreservation}
                              className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                            />
                            <label htmlFor="preserveFormatting" className="text-gray-700 dark:text-gray-300 font-medium">
                              Preserve template formatting
                            </label>
                          </div>
                        </div>
                        
                        {useSheetSpecificHeaders && (
                          <div className="mb-3">
                            <div className="flex justify-between mb-2">
                              <label className="text-gray-700 dark:text-gray-300">Select worksheets to use:</label>
                              <div className="flex space-x-2">
                                <button
                                  onClick={selectAllWorksheets}
                                  className="text-xs px-2 py-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded"
                                >
                                  Select All
                                </button>
                                <button
                                  onClick={clearWorksheetSelections}
                                  className="text-xs px-2 py-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded"
                                >
                                  Clear All
                                </button>
                              </div>
                            </div>
                            
                            <div className="sheet-selection-group">
                              {templateSheets.map((sheet, index) => (
                                <div
                                  key={index}
                                  className={`sheet-selection-item ${selectedWorksheets.includes(sheet) ? 'selected' : ''}`}
                                  onClick={() => handleWorksheetSelection(sheet)}
                                >
                                  <input
                                    type="checkbox"
                                    checked={selectedWorksheets.includes(sheet)}
                                    onChange={() => {}} // Handled by the div click handler
                                    className="sheet-checkbox"
                                  />
                                  <span>{sheet}</span>
                                </div>
                              ))}
                            </div>
                            
                            {selectedWorksheets.length > 0 && (
                              <div className="mt-4">
                                <h4 className="text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">
                                  Configure header rows for each worksheet:
                                </h4>
                                <div className="overflow-x-auto">
                                  <table className="worksheet-config-table">
                                    <thead>
                                      <tr>
                                        <th>Worksheet</th>
                                        <th>Header Row</th>
                                        {requirementRowAvailable && <th>Requirement Row</th>}
                                      </tr>
                                    </thead>
                                    <tbody>
                                      {selectedWorksheets.map((sheet, index) => (
                                        <tr key={index}>
                                          <td>{sheet}</td>
                                          <td>
                                            <input
                                              type="number"
                                              min="1"
                                              value={worksheetHeaderRows[sheet] || templateHeaderRow}
                                              onChange={(e) => handleWorksheetHeaderRowChange(sheet, e.target.value)}
                                              className="text-base"
                                            />
                                          </td>
                                          {requirementRowAvailable && (
                                            <td>
                                              <input
                                                type="number"
                                                min="1"
                                                value={worksheetRequirementRows[sheet] || templateRequirementRow}
                                                onChange={(e) => handleWorksheetRequirementRowChange(sheet, e.target.value)}
                                                className="text-base"
                                              />
                                            </td>
                                          )}
                                        </tr>
                                      ))}
                                    </tbody>
                                  </table>
                                </div>
                                <p className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                                  Note: Different worksheets can have headers on different rows. Configure each one accurately.
                                </p>
                              </div>
                            )}
                          </div>
                        )}
                        
                        {!useSheetSpecificHeaders && (
                          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                              <label className="block mb-2 text-gray-700 dark:text-gray-300">Select Primary Worksheet</label>
                              <select
                                value={selectedTemplateSheet}
                                onChange={(e) => setSelectedTemplateSheet(e.target.value)}
                                className="block w-full p-2 text-base border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                              >
                                {templateSheets.map((sheet, index) => (
                                  <option key={index} value={sheet}>{sheet}</option>
                                ))}
                              </select>
                            </div>
                          </div>
                        )}
                      </div>
                    
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        {!useSheetSpecificHeaders && (
                          <>
                            <div>
                              <label className="block mb-2 text-gray-700 dark:text-gray-300">Header Row Number</label>
                              <input
                                type="number"
                                min="1"
                                value={templateHeaderRow}
                                onChange={(e) => setTemplateHeaderRow(Math.max(1, parseInt(e.target.value) || 1))}
                                className="block w-full p-2 text-base border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                              />
                            </div>

                            <div>
                              <div className="flex items-center mb-2">
                                <input
                                  type="checkbox"
                                  id="requirementRow"
                                  checked={requirementRowAvailable}
                                  onChange={toggleRequirementRow}
                                  className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                                />
                                <label htmlFor="requirementRow" className="text-gray-700 dark:text-gray-300">
                                  Template includes a row indicating required fields
                                </label>
                              </div>
                              
                              {requirementRowAvailable && (
                                <div>
                                  <label className="block mb-2 text-gray-700 dark:text-gray-300">Required Fields Row Number</label>
                                  <input
                                    type="number"
                                    min="1"
                                    value={templateRequirementRow}
                                    onChange={(e) => setTemplateRequirementRow(Math.max(1, parseInt(e.target.value) || 1))}
                                    className="block w-full p-2 text-base border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                  />
                                  <p className="mt-1 text-sm text-gray-500 dark:text-gray-400">
                                    This row should contain indicators like "Required", "Optional", "R", "O", "*", etc.
                                  </p>
                                </div>
                              )}
                            </div>
                          </>
                        )}
                        
                        {useSheetSpecificHeaders && requirementRowAvailable && (
                          <div>
                            <div className="flex items-center mb-2">
                              <input
                                type="checkbox"
                                id="requirementRow"
                                checked={requirementRowAvailable}
                                onChange={toggleRequirementRow}
                                className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                              />
                              <label htmlFor="requirementRow" className="text-gray-700 dark:text-gray-300">
                                Templates include rows indicating required fields
                              </label>
                            </div>
                            <p className="text-sm text-gray-500 dark:text-gray-400">
                              Configure requirement row numbers for each worksheet in the table above.
                            </p>
                          </div>
                        )}
                        
                        {useSheetSpecificHeaders && !requirementRowAvailable && (
                          <div>
                            <div className="flex items-center mb-2">
                              <input
                                type="checkbox"
                                id="requirementRow"
                                checked={requirementRowAvailable}
                                onChange={toggleRequirementRow}
                                className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                              />
                              <label htmlFor="requirementRow" className="text-gray-700 dark:text-gray-300">
                                Templates include rows indicating required fields
                              </label>
                            </div>
                          </div>
                        )}
                      </div>
                    </>
                  )}
                  
                  {templateSheets.length > 0 && (
                    <button
                      onClick={() => processSheet('template')}
                      disabled={isLoading.template || isLoading.headerLoad || (useSheetSpecificHeaders && selectedWorksheets.length === 0)}
                      className={`px-4 py-2 rounded transition-colors ${
                        isLoading.template || isLoading.headerLoad || (useSheetSpecificHeaders && selectedWorksheets.length === 0)
                          ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                          : 'bg-excel-500 hover:bg-excel-600 text-white'
                      }`}
                    >
                      {isLoading.template || isLoading.headerLoad ? (
                        <span className="flex items-center">
                          <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                          {isLoading.headerLoad ? 'Loading Headers...' : 'Processing...'}
                        </span>
                      ) : (
                        useSheetSpecificHeaders 
                          ? `Load Headers from ${selectedWorksheets.length} ${selectedWorksheets.length === 1 ? 'Worksheet' : 'Worksheets'}`
                          : 'Load Template Headers'
                      )}
                    </button>
                  )}
                  
                  {templateHeaders.length > 0 && debugInfo && (
                    <div className="mt-2 mb-2 text-gray-500 dark:text-gray-400 text-sm italic">
                      Note: {debugInfo}
                    </div>
                  )}
                  
                  {templateHeaders.length > 0 && (
                    <div className="mt-4">
                      <p className="text-excel-600 dark:text-excel-400">✓ Template loaded with {templateHeaders.filter(Boolean).length} columns</p>
                      
                      {useSheetSpecificHeaders && Object.keys(worksheetHeadersMap).length > 0 && (
                        <div className="mt-2 mb-4">
                          <div className="worksheet-preview">
                            <div className="worksheet-preview-header">
                              Worksheet Header Summary
                            </div>
                            <div className="worksheet-preview-content">
                              {Object.entries(worksheetHeadersMap).map(([sheetName, headers], index) => (
                                <div key={index} className="mb-3">
                                  <h4 className="font-medium mb-1 text-excel-600 dark:text-excel-400">
                                    {sheetName} (Header Row: {worksheetHeaderRows[sheetName] || templateHeaderRow})
                                  </h4>
                                  <div className="text-sm text-gray-600 dark:text-gray-300 mb-2">
                                    {headers.filter(Boolean).length} columns detected
                                  </div>
                                  <div className="flex flex-wrap gap-2">
                                    {headers.filter(Boolean).slice(0, 5).map((header, i) => (
                                      <div key={i} className="worksheet-header-item">
                                        <span>{header}</span>
                                        {getHeaderRequirement(header, sheetName) === 'Required' && (
                                          <span className="ml-1 text-red-500 dark:text-red-400">*</span>
                                        )}
                                      </div>
                                    ))}
                                    {headers.filter(Boolean).length > 5 && (
                                      <div className="worksheet-header-item opacity-60">
                                        +{headers.filter(Boolean).length - 5} more
                                      </div>
                                    )}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        </div>
                      )}
                      
                      {preserveFormatting && (
                        <div className="format-preservation-notice mb-4">
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-3 flex-shrink-0 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                          </svg>
                          <div>
                            <h4 className="font-medium text-blue-800 dark:text-blue-300 mb-1">Template formatting will be preserved</h4>
                            <div className="text-blue-700 dark:text-blue-400 text-sm">
                              <div className="format-item">
                                <span className="format-icon">✓</span> Colors, fonts, and borders
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Formulas and calculations
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Conditional formatting
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Data validation rules
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Hyperlinks and styles
                              </div>
                            </div>
                          </div>
                        </div>
                      )}
                      
                      <div className="mt-2 overflow-x-auto">
                        <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 text-sm rounded-md">
                          <thead>
                            <tr className="bg-gray-50 dark:bg-gray-700">
                              <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Column Name</th>
                              <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Requirement</th>
                              <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Has Validation Message</th>
                            </tr>
                          </thead>
                          <tbody>
                            {templateHeaders.filter(Boolean).map((header, index) => (
                              <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                                <td className="py-1 px-3 border-b dark:border-gray-600">
                                  <div className="tooltip flex items-center">
                                    <span className="has-notes">{header}</span>
                                    {headerHasNotes(header) && (
                                      <>
                                        <span className="info-icon ml-1">i</span>
                                        <span 
                                          className={`tooltip-text ${isLargeNote(templateHeaderNotes[header]) ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: templateHeaderNotes[header] }}
                                        />
                                      </>
                                    )}
                                  </div>
                                </td>
                                <td className={`py-1 px-3 border-b dark:border-gray-600 ${fieldRequirements[header] === 'Required' ? 'text-red-500 dark:text-red-400 font-medium' : 'text-excel-500 dark:text-excel-400'}`}>
                                  {fieldRequirements[header] || 'Optional'}
                                </td>
                                <td className="py-1 px-3 border-b dark:border-gray-600">
                                  {headerHasNotes(header) ? (
                                    <span className="text-excel-500 dark:text-excel-400">Yes</span>
                                  ) : (
                                    <span className="text-gray-400 dark:text-gray-500">No</span>
                                  )}
                                </td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}
                </div>
                
                <div className="mb-6">
                  <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">2. Data Excel File</h2>
                  
                  <div className="mb-4">
                    <label className="block mb-2 text-gray-700 dark:text-gray-300">Upload Data File</label>
                    <div className="relative">
                      <input
                        type="file"
                        accept=".xlsx, .xls"
                        onChange={(e) => handleFileUpload(e, 'data')}
                        className="block w-full text-base text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded p-2 
                          file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold
                          file:bg-excel-50 file:text-excel-700 dark:file:bg-gray-700 dark:file:text-gray-300
                          hover:file:bg-excel-100 dark:hover:file:bg-gray-600"
                      />
                      {isLoading.data && (
                        <div className="absolute inset-0 bg-white/70 dark:bg-gray-800/70 flex items-center justify-center">
                          <svg className="animate-spin h-5 w-5 text-excel-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {dataSheets.length > 0 && (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Select Worksheet</label>
                        <select
                          value={selectedDataSheet}
                          onChange={(e) => setSelectedDataSheet(e.target.value)}
                          className="block w-full p-2 text-base border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        >
                          {dataSheets.map((sheet, index) => (
                            <option key={index} value={sheet}>{sheet}</option>
                          ))}
                        </select>
                      </div>
                      
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Header Row Number</label>
                        <input
                          type="number"
                          min="1"
                          value={dataHeaderRow}
                          onChange={(e) => setDataHeaderRow(Math.max(1, parseInt(e.target.value) || 1))}
                          className="block w-full p-2 text-base border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        />
                      </div>
                    </div>
                  )}
                  
                  {dataSheets.length > 0 && (
                    <button
                      onClick={() => processSheet('data')}
                      disabled={isLoading.data}
                      className={`px-4 py-2 rounded transition-colors ${
                        isLoading.data 
                          ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                          : 'bg-excel-500 hover:bg-excel-600 text-white'
                      }`}
                    >
                      {isLoading.data ? (
                        <span className="flex items-center">
                          <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                          Processing...
                        </span>
                      ) : 'Load Data Headers'}
                    </button>
                  )}
                  
                  {dataHeaders.length > 0 && (
                    <div className="mt-4">
                      <p className="text-excel-600 dark:text-excel-400">✓ Data loaded with {dataHeaders.filter(Boolean).length} columns</p>
                      <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 max-h-24 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded p-2">
                        Headers: {dataHeaders.filter(Boolean).join(', ')}
                      </div>
                    </div>
                  )}
                </div>
                
                <button
                  disabled={!template || !data}
                  onClick={proceedToMapping}
                  className={`w-full md:w-auto px-4 py-2 rounded transition-colors ${
                    !template || !data 
                      ? 'bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed' 
                      : 'bg-excel-500 text-white hover:bg-excel-600'
                  }`}
                >
                  Continue to Column Mapping
                </button>
              </div>
            )}
            
            {step === 2 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">Map Template Columns to Data Columns</h2>
                <p className="mb-4 text-gray-600 dark:text-gray-300">
                  We've automatically matched columns based on name similarity. Please review and adjust as needed.
                  <span className="text-red-500 dark:text-red-400 ml-2 font-medium">Required fields must be mapped.</span>
                </p>
                
                {/* Multi-tab mapping option */}
                <div className="mb-6 border dark:border-gray-700 rounded-lg p-4 bg-gray-50 dark:bg-gray-900/50">
                  <div className="flex items-center mb-3">
                    <input
                      type="checkbox"
                      id="enableMultiTabMapping"
                      checked={enableMultiTabMapping}
                      onChange={toggleMultiTabMapping}
                      className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                    />
                    <label htmlFor="enableMultiTabMapping" className="text-gray-700 dark:text-gray-300 font-medium">
                      Enable Category-Based Multi-Tab Mapping
                    </label>
                  </div>
                  
                  {enableMultiTabMapping && (
                    <div className="pl-6">
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                        Map your data to different worksheets in the template based on a category column.
                        Each worksheet can have its own column mappings.
                      </p>
                      
                      <div className="mb-3">
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Select Category Column</label>
                        <CustomSelect
                          options={[
                            { value: '', label: '-- Select a column --' },
                            ...dataHeaders.filter(Boolean).map(header => ({
                              value: header,
                              label: header
                            }))
                          ]}
                          value={categoryColumn}
                          onChange={handleCategoryColumnChange}
                          columnSamples={columnSamples}
                          columnDescriptions={dataHeaderDescriptions}
                        />
                      </div>
                      
                      {categoryColumn && (
                        <div className="mb-4">
                          <div className="flex items-center mb-2">
                            <input
                              type="checkbox"
                              id="includeMainTab"
                              checked={includeMainTab}
                              onChange={toggleIncludeMainTab}
                              className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                            />
                            <label htmlFor="includeMainTab" className="text-gray-700 dark:text-gray-300 font-medium">
                              Include Main Tab for all categories
                            </label>
                          </div>
                          
                          {includeMainTab && (
                            <div className="ml-6 mt-2">
                              <label className="block mb-1 text-gray-700 dark:text-gray-300">Select Main Tab</label>
                              <select
                                value={mainTabSelection}
                                onChange={(e) => handleMainTabChange(e.target.value)}
                                className="block w-full p-2 text-base border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                              >
                                {templateSheets.map((sheet, index) => (
                                  <option key={index} value={sheet}>{sheet}</option>
                                ))}
                              </select>
                              <p className="text-xs mt-1 text-gray-500 dark:text-gray-400">
                                Data from all categories will be copied to this tab in addition to category-specific tabs
                              </p>
                            </div>
                          )}
                        </div>
                      )}
                      
                      {categoryColumn && categoryValues.length > 0 && (
                        <>
                          <div className="mb-3">
                            <div className="flex items-center justify-between mb-2">
                              <label className="text-gray-700 dark:text-gray-300">Category to Worksheet Mapping</label>
                              <span className="text-sm text-gray-500 dark:text-gray-400">
                                {categoryValues.length} unique values found
                              </span>
                            </div>
                            
                            <div className="border dark:border-gray-700 rounded overflow-hidden">
                              <div className="overflow-y-auto max-h-96">
                                <div className="p-4 divide-y dark:divide-gray-700 space-y-4">
                                  {categoryValues.map((value, index) => {
                                    // Get worksheet suggestions for this category
                                    const suggestions = worksheetSuggestions[value] || [];
                                    
                                    return (
                                      <div key={index} className="pt-4 first:pt-0">
                                        <div className="flex justify-between items-center mb-2">
                                          <span className="font-medium text-gray-800 dark:text-gray-200">{value}</span>
                                          <span className="text-sm text-gray-500 dark:text-gray-400">
                                            {categoryWorksheetMappings[value]?.length || 0} target {(categoryWorksheetMappings[value]?.length || 0) === 1 ? 'worksheet' : 'worksheets'}
                                          </span>
                                        </div>
                                        
                                        {/* Display selected worksheets as tags */}
                                        <div className="flex flex-wrap mb-2">
                                          {categoryWorksheetMappings[value]?.map((sheet, sheetIndex) => (
                                            <div 
                                              key={sheetIndex} 
                                              className={`sheet-tag ${sheet === mainTabSelection ? 'sheet-tag-main' : ''}`}
                                            >
                                              <span>{sheet}</span>
                                              {(sheet !== mainTabSelection || !includeMainTab) && (
                                                <button 
                                                  className="remove-btn" 
                                                  onClick={() => removeWorksheetFromCategory(value, sheet)}
                                                  title="Remove worksheet"
                                                >
                                                  ×
                                                </button>
                                              )}
                                              {sheet === mainTabSelection && includeMainTab && (
                                                <span className="text-xs ml-1">(main)</span>
                                              )}
                                            </div>
                                          ))}
                                        </div>
                                        
                                        {/* Display suggestions with scores */}
                                        {suggestions.length > 0 && (
                                          <div className="sheet-suggestions">
                                            <div className="text-xs text-gray-500 dark:text-gray-400 mb-1">
                                              Suggested worksheets:
                                            </div>
                                            {suggestions.map((suggestion, sugIndex) => {
                                              // Skip if already selected
                                              if (categoryWorksheetMappings[value]?.includes(suggestion.sheet)) {
                                                return null;
                                              }
                                              
                                              return (
                                                <div 
                                                  key={sugIndex} 
                                                  className="sheet-suggestion-item"
                                                  onClick={() => addWorksheetToCategory(value, suggestion.sheet)}
                                                  title="Add this worksheet"
                                                >
                                                  <span>{suggestion.sheet}</span>
                                                  <span className="sheet-suggestion-score">
                                                    {Math.round(suggestion.score * 100)}%
                                                  </span>
                                                </div>
                                              );
                                            })}
                                          </div>
                                        )}
                                        
                                        {/* Add more worksheets dropdown */}
                                        <div className="mt-2">
                                          <select
                                            value=""
                                            onChange={(e) => {
                                              if (e.target.value) {
                                                addWorksheetToCategory(value, e.target.value);
                                                e.target.value = "";
                                              }
                                            }}
                                            className="block w-full p-2 text-sm border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                          >
                                            <option value="">+ Add another worksheet</option>
                                            {templateSheets
                                              .filter(sheet => !categoryWorksheetMappings[value]?.includes(sheet))
                                              .map((sheet, sheetIndex) => (
                                                <option key={sheetIndex} value={sheet}>{sheet}</option>
                                              ))
                                            }
                                          </select>
                                        </div>
                                      </div>
                                    );
                                  })}
                                </div>
                              </div>
                            </div>
                          </div>
                          
                          {/* Category tabs */}
                          <div className="mb-3">
                            <label className="block mb-2 text-gray-700 dark:text-gray-300">
                              Configure Mappings For Category:
                            </label>
                            <div className="tab-selector mb-3">
                              {categoryValues.map((value, index) => (
                                <div
                                  key={index}
                                  className={`tab-item ${activeTab === value ? 'active' : ''}`}
                                  onClick={() => {
                                    setActiveTab(value);
                                    // Also set active worksheet to the first worksheet of this category
                                    if (categoryWorksheetMappings[value] && categoryWorksheetMappings[value].length > 0) {
                                      setActiveWorksheet(categoryWorksheetMappings[value][0]);
                                    }
                                  }}
                                >
                                  <div className="flex items-center">
                                    <span>{value}</span>
                                    <span className="badge worksheet-badge ml-2 text-xs">
                                      {categoryWorksheetMappings[value]?.length || 0} sheet{(categoryWorksheetMappings[value]?.length || 0) !== 1 ? 's' : ''}
                                    </span>
                                  </div>
                                </div>
                              ))}
                            </div>
                            
                            {/* Worksheet tabs for the active category */}
                            {activeTab && categoryWorksheetMappings[activeTab] && categoryWorksheetMappings[activeTab].length > 0 && (
                              <div className="worksheet-tab-selector">
                                <div className="text-sm text-gray-500 dark:text-gray-400 mr-3 self-center">
                                  Worksheet:
                                </div>
                                {categoryWorksheetMappings[activeTab].map((worksheet, wsIndex) => (
                                  <div
                                    key={wsIndex}
                                    className={`worksheet-tab-item ${activeWorksheet === worksheet ? 'active' : ''} ${worksheet === mainTabSelection ? 'main' : ''}`}
                                    onClick={() => handleWorksheetTabChange(worksheet)}
                                  >
                                    {worksheet}
                                    {worksheet === mainTabSelection && (
                                      <span className="text-xs ml-1">(main)</span>
                                    )}
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        </>
                      )}
                    </div>
                  )}
                </div>
                
                {!suggestionsReviewed && Object.keys(suggestedMappings).length > 0 && (
                  <div className="mapping-suggestion-panel mb-6 dark:bg-blue-950/20">
                    <div className="flex items-center justify-between mb-3">
                      <h3 className="font-medium text-blue-800 dark:text-blue-300">Suggested Column Mappings</h3>
                      <button 
                        onClick={acceptAllSuggestions}
                        className="px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white text-sm rounded transition-colors"
                      >
                        Accept All
                      </button>
                    </div>
                    
                    <div className="overflow-x-auto">
                      <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 text-sm rounded-md">
                        <thead className="bg-gray-50 dark:bg-gray-700">
                          <tr>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Template Column</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Suggested Data Column</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Confidence</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Action</th>
                          </tr>
                        </thead>
                        <tbody>
                          {Object.entries(suggestedMappings).map(([templateHeader, dataHeader], index) => {
                            // Get the match score for this suggestion
                            const matchScores = mappingScores[templateHeader] || [];
                            const matchInfo = matchScores.find(m => m.header === dataHeader);
                            const score = matchInfo ? matchInfo.score : 0;
                            const confidenceLevel = getConfidenceLevel(score);
                            const confidenceClass = getConfidenceClass(score);
                            
                            return (
                              <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="tooltip flex items-center">
                                    <span className="has-notes">{templateHeader}</span>
                                    {headerHasNotes(templateHeader) && (
                                      <>
                                        <span className="info-icon ml-1">i</span>
                                        <span 
                                          className={`tooltip-text ${isLargeNote(templateHeaderNotes[templateHeader]) ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: templateHeaderNotes[templateHeader] }}
                                        />
                                      </>
                                    )}
                                  </div>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="flex items-center">
                                    <span>{dataHeader}</span>
                                    {dataHeaderDescriptions[dataHeader] && (
                                      <div className="tooltip ml-1">
                                        <span className="info-icon text-xs">i</span>
                                        <span 
                                          className={`tooltip-text ${dataHeaderDescriptions[dataHeader] && dataHeaderDescriptions[dataHeader].length > 150 ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: dataHeaderDescriptions[dataHeader] }}
                                        />
                                      </div>
                                    )}
                                  </div>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <span className={`mapping-confidence ${confidenceClass}`}>
                                    {confidenceLevel}
                                  </span>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="flex space-x-2">
                                    <button
                                      onClick={() => acceptSuggestion(templateHeader)}
                                      className="px-2 py-0.5 bg-green-500 hover:bg-green-600 text-white text-sm rounded"
                                      title="Accept this mapping"
                                    >
                                      ✓
                                    </button>
                                    <button
                                      onClick={() => clearMapping(templateHeader, activeTab, activeWorksheet)}
                                      className="px-2 py-0.5 bg-red-500 hover:bg-red-600 text-white text-sm rounded"
                                      title="Reject this mapping"
                                    >
                                      ✗
                                    </button>
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </tbody>
                      </table>
                    </div>
                    
                    <div className="mt-3">
                      <button 
                        onClick={() => setSuggestionsReviewed(true)}
                        className="text-blue-600 dark:text-blue-400 text-sm hover:underline"
                      >
                        Dismiss suggestions
                      </button>
                    </div>
                  </div>
                )}
                
                <div className="mb-4 flex flex-col sm:flex-row gap-2 text-sm">
                  {hasAnyNotes && (
                    <div className="text-excel-600 dark:text-excel-400 border border-excel-200 dark:border-excel-800 bg-excel-50 dark:bg-excel-900/30 p-3 rounded flex items-start flex-1">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                      </svg>
                      <span><span className="font-medium">Tip:</span> Hover over the "i" icons next to template column names to see input guidance from the Excel template.</span>
                    </div>
                  )}
                  
                  <div className="text-blue-600 dark:text-blue-400 border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/30 p-3 rounded flex items-start flex-1">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                    </svg>
                    <span><span className="font-medium">Tip:</span> Hover over the "i" icons next to data column names to see descriptions, or hover on any cell for 1.5 seconds to see sample data.</span>
                  </div>
                </div>
                
                {enableMultiTabMapping && activeTab && activeWorksheet && (
                  <div className="py-2 px-4 bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300 mb-4 rounded-md">
                    Currently configuring mappings for:
                    <span className="font-medium ml-2">{activeTab}</span>
                    <span className="mx-2">→</span>
                    <span className="font-medium">{activeWorksheet}</span>
                    {activeWorksheet === mainTabSelection && (
                      <span className="ml-1 text-sm">(main tab)</span>
                    )}
                    <span className="ml-2 text-sm">
                      {getUnmappedRequiredFieldsCount(activeTab, activeWorksheet) > 0 && (
                        <span className="bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 px-2 py-0.5 rounded-full">
                          {getUnmappedRequiredFieldsCount(activeTab, activeWorksheet)} unmapped required
                        </span>
                      )}
                    </span>
                  </div>
                )}
                
                <div className="overflow-x-auto mb-6">
                  <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                    <thead className="bg-gray-50 dark:bg-gray-700">
                      <tr>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Template Column</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Requirement</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Data Column</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left w-16">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {(() => {
                        // Get the appropriate headers based on the context
                        let headers, requirements;
                        
                        if (enableMultiTabMapping && activeWorksheet && useSheetSpecificHeaders && worksheetHeadersMap[activeWorksheet]) {
                          headers = worksheetHeadersMap[activeWorksheet];
                          requirements = worksheetRequirementsMap[activeWorksheet] || {};
                        } else {
                          headers = templateHeaders;
                          requirements = fieldRequirements;
                        }
                        
                        // Get the current mappings
                        const currentMappings = getCurrentMappings();
                        
                        return headers.filter(Boolean).map((header, index) => (
                          <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              <div className="tooltip flex items-center">
                                <span className="has-notes">{header}</span>
                                {headerHasNotes(header, activeWorksheet) && (
                                  <>
                                    <span className="info-icon ml-1">i</span>
                                    <span 
                                      className={`tooltip-text ${isLargeNote(getHeaderNote(header, activeWorksheet)) ? 'large' : ''}`}
                                      dangerouslySetInnerHTML={{ __html: getHeaderNote(header, activeWorksheet) }}
                                    />
                                  </>
                                )}
                              </div>
                            </td>
                            <td className={`py-2 px-4 border-b dark:border-gray-600 ${
                              getHeaderRequirement(header, activeWorksheet) === 'Required' 
                                ? 'text-red-500 dark:text-red-400 font-medium' 
                                : 'text-excel-500 dark:text-excel-400'
                            }`}>
                              {getHeaderRequirement(header, activeWorksheet) || 'Optional'}
                            </td>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              <CustomSelect
                                options={[
                                  { value: '', label: '-- Not Mapped --' },
                                  ...dataHeaders.filter(Boolean).map(dataHeader => ({
                                    value: dataHeader,
                                    label: dataHeader
                                  }))
                                ]}
                                value={currentMappings[header] || ''}
                                onChange={(value) => handleMappingChange(header, value, activeTab, activeWorksheet)}
                                isError={getHeaderRequirement(header, activeWorksheet) === 'Required' && (!currentMappings[header] || currentMappings[header] === '')}
                                suggestedValue={suggestedMappings[header] || null}
                                columnSamples={columnSamples}
                                columnDescriptions={dataHeaderDescriptions}
                              />
                            </td>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              {currentMappings[header] && (
                                <button
                                  onClick={() => clearMapping(header, activeTab, activeWorksheet)}
                                  className="p-1 bg-red-100 hover:bg-red-200 dark:bg-red-900/30 dark:hover:bg-red-900/50 text-red-700 dark:text-red-400 rounded"
                                  title="Clear this mapping"
                                >
                                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                                  </svg>
                                </button>
                              )}
                            </td>
                          </tr>
                        ));
                      })()}
                    </tbody>
                  </table>
                </div>
                
                <div className="mt-6 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                  <button
                    onClick={() => setStep(1)}
                    className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  >
                    Back
                  </button>
                  <button
                    onClick={mapData}
                    disabled={isLoading.mapping}
                    className={`px-4 py-2 rounded transition-colors ${
                      isLoading.mapping 
                        ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                        : 'bg-excel-500 hover:bg-excel-600 text-white'
                    }`}
                  >
                    {isLoading.mapping ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Mapping Data...
                      </span>
                    ) : (
                      <>
                        Map Data
                        {!enableMultiTabMapping && getUnmappedRequiredFieldsCount() > 0 && (
                          <span className="ml-2 bg-red-500 text-white text-xs px-1.5 py-0.5 rounded-full">
                            {getUnmappedRequiredFieldsCount()} unmapped required
                          </span>
                        )}
                        {enableMultiTabMapping && activeTab && activeWorksheet && 
                         getUnmappedRequiredFieldsCount(activeTab, activeWorksheet) > 0 && (
                          <span className="ml-2 bg-red-500 text-white text-xs px-1.5 py-0.5 rounded-full">
                            {getUnmappedRequiredFieldsCount(activeTab, activeWorksheet)} unmapped required
                          </span>
                        )}
                      </>
                    )}
                  </button>
                </div>
              </div>
            )}
            
            {step === 3 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">Data Successfully Mapped</h2>
                
                <div className="mb-6">
                  <p className="text-excel-600 dark:text-excel-400 mb-2 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    {enableMultiTabMapping ? (
                      <>
                        Mapping complete for {Object.keys(mappedData).length} mapped combinations across multiple worksheets
                      </>
                    ) : (
                      <>
                        Mapping complete for {mappedData.length - 1} rows of data
                      </>
                    )}
                  </p>
                  
                  {preserveFormatting && (
                    <div className="format-preservation-notice mb-4">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-3 flex-shrink-0 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                      </svg>
                      <div>
                        <h4 className="font-medium text-blue-800 dark:text-blue-300 mb-1">Template formatting will be preserved</h4>
                        <div className="text-blue-700 dark:text-blue-400 text-sm">
                          <p>Your exported file will maintain all formatting, including:</p>
                          <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 mt-2">
                            <div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Colors, fonts, and borders
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Formulas and calculations
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Conditional formatting
                              </div>
                            </div>
                            <div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Data validation rules
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Hyperlinks and styles
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Cell formatting and alignment
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  <div className="export-options-panel">
                    <div className="export-options-title">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                      </svg>
                      Export Options
                    </div>
                    
                    <div className="export-option-group">
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="preserveFormulas" 
                          checked={exportOptions.preserveFormulas}
                          onChange={(e) => handleExportOptionChange('preserveFormulas', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="preserveFormulas" className="font-medium">Preserve Formulas</label>
                          <p className="export-option-description">
                            Keep Excel formulas from the template (recommended for calculated fields)
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="preserveStyles" 
                          checked={exportOptions.preserveStyles}
                          onChange={(e) => handleExportOptionChange('preserveStyles', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="preserveStyles" className="font-medium">Preserve Cell Styles</label>
                          <p className="export-option-description">
                            Keep colors, fonts, borders and cell styles from the template
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="applyColumnFormats" 
                          checked={exportOptions.applyColumnFormats}
                          onChange={(e) => handleExportOptionChange('applyColumnFormats', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="applyColumnFormats" className="font-medium">Apply Column Formats</label>
                          <p className="export-option-description">
                            Apply number, date, and text formats from the template columns
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="preserveValidation" 
                          checked={exportOptions.preserveValidation}
                          onChange={(e) => handleExportOptionChange('preserveValidation', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="preserveValidation" className="font-medium">Preserve Data Validation</label>
                          <p className="export-option-description">
                            Keep dropdown lists and validation rules from the template
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="includeMacros" 
                          checked={exportOptions.includeMacros}
                          onChange={(e) => handleExportOptionChange('includeMacros', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="includeMacros" className="font-medium">Include Macros (VBA)</label>
                          <p className="export-option-description">
                            Try to include macros from template (if present). May cause compatibility issues in some cases.
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>

                  {enableMultiTabMapping ? (
                    <div className="mt-4 mb-6">
                      <div className="tab-selector mb-3">
                        {Object.keys(mappedData).map((mappingKey, index) => {
                          const { category, worksheet, isMainTab } = mappedData[mappingKey];
                          return (
                            <div
                              key={index}
                              className={`tab-item ${activeTab === mappingKey ? 'active' : ''}`}
                              onClick={() => setActiveTab(mappingKey)}
                            >
                              <div className="flex items-center">
                                <span>{isMainTab ? "All Data" : category}</span>
                                <span className="badge worksheet-badge ml-2 text-xs">
                                  {worksheet}
                                </span>
                                <span className="ml-1 text-xs text-gray-500 dark:text-gray-400">
                                  ({mappedData[mappingKey].data.length - 1} rows)
                                </span>
                                {isMainTab && (
                                  <span className="main-tab-badge ml-1">Main</span>
                                )}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                      
                      {activeTab && mappedData[activeTab] && (
                        <div className="overflow-x-auto">
                          <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                            <thead className="bg-gray-50 dark:bg-gray-700">
                              <tr>
                                {mappedData[activeTab].data[0].map((header, index) => {
                                  // Get the target worksheet for this category
                                  const targetWorksheet = mappedData[activeTab].worksheet;
                                  // Determine if this header has notes based on the target worksheet
                                  const hasNotes = headerHasNotes(header, targetWorksheet);
                                  // Get the note content if available
                                  const noteContent = getHeaderNote(header, targetWorksheet);
                                  // Get requirement status
                                  const isRequired = getHeaderRequirement(header, targetWorksheet) === 'Required';
                                  
                                  return (
                                    <th key={index} className="py-2 px-4 border-b dark:border-gray-600 text-left">
                                      <div className="tooltip flex items-center">
                                        <span className={hasNotes ? "has-notes" : ""}>
                                          {header || '(Empty Column)'}
                                          {header && isRequired && (
                                            <span className="ml-1 text-red-500 dark:text-red-400">*</span>
                                          )}
                                        </span>
                                        {header && hasNotes && (
                                          <>
                                            <span className="info-icon ml-1">i</span>
                                            <span 
                                              className={`tooltip-text ${isLargeNote(noteContent) ? 'large' : ''}`}
                                              dangerouslySetInnerHTML={{ __html: noteContent }}
                                            />
                                          </>
                                        )}
                                      </div>
                                    </th>
                                  );
                                })}
                              </tr>
                            </thead>
                            <tbody>
                              {mappedData[activeTab].data.slice(1, Math.min(6, mappedData[activeTab].data.length)).map((row, rowIndex) => (
                                <tr 
                                  key={rowIndex} 
                                  className={`${rowIndex % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'} ${mappedData[activeTab].isMainTab ? 'main-tab-highlight' : ''}`}
                                >
                                  {row.map((cell, cellIndex) => (
                                    <td key={cellIndex} className="py-2 px-4 border-b dark:border-gray-600">
                                      {cell === undefined || cell === null ? '' : String(cell)}
                                    </td>
                                  ))}
                                </tr>
                              ))}
                            </tbody>
                          </table>
                          {mappedData[activeTab].data.length > 6 && (
                            <p className="mt-2 text-gray-500 dark:text-gray-400 text-sm">
                              Showing first 5 rows of {mappedData[activeTab].data.length - 1} total rows
                              for {mappedData[activeTab].isMainTab ? "All Data" : mappedData[activeTab].category} → {mappedData[activeTab].worksheet}
                            </p>
                          )}
                          <p className="mt-2 text-sm text-blue-600 dark:text-blue-400">
                            Will be inserted in worksheet "{mappedData[activeTab].worksheet}" starting at row {mappedData[activeTab].headerRow || templateHeaderRow}
                            {mappedData[activeTab].isMainTab && (
                              <span className="ml-2 font-medium">(Main tab with ALL data)</span>
                            )}
                          </p>
                        </div>
                      )}
                      
                      <div className="mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-900/30 rounded-md text-yellow-800 dark:text-yellow-200">
                        <div className="flex">
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                          </svg>
                          <div>
                            <p className="font-medium mb-1">Multi-tab mapping summary:</p>
                            <ul className="list-disc list-inside text-sm ml-2">
                              <li>
                                {Object.keys(mappedData).filter(key => !mappedData[key].isMainTab).length} category-worksheet combinations mapped
                              </li>
                              <li>
                                {includeMainTab && mainTabSelection ? "Main tab includes ALL data rows regardless of category" : "No main tab selected"}
                              </li>
                              <li>
                                Data spread across {new Set(Object.values(mappedData).map(item => item.worksheet)).size} different worksheets
                              </li>
                              <li>
                                Total rows to be exported: {Object.values(mappedData).reduce((total, item) => total + item.data.length - 1, 0)}
                              </li>
                              <li>
                                Each worksheet uses its specific column mappings and header row configuration
                              </li>
                              <li>
                                Click on each mapping tab above to preview the data that will be exported
                              </li>
                            </ul>
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div className="overflow-x-auto mt-4 mb-6">
                      <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                        <thead className="bg-gray-50 dark:bg-gray-700">
                          <tr>
                            {mappedData[0].map((header, index) => (
                              <th key={index} className="py-2 px-4 border-b dark:border-gray-600 text-left">
                                <div className="tooltip flex items-center">
                                  <span className={header && headerHasNotes(header) ? "has-notes" : ""}>
                                    {header || '(Empty Column)'}
                                    {header && fieldRequirements[header] === 'Required' && (
                                      <span className="ml-1 text-red-500 dark:text-red-400">*</span>
                                    )}
                                  </span>
                                  {header && headerHasNotes(header) && (
                                    <>
                                      <span className="info-icon ml-1">i</span>
                                      <span 
                                        className={`tooltip-text ${isLargeNote(templateHeaderNotes[header]) ? 'large' : ''}`}
                                        dangerouslySetInnerHTML={{ __html: templateHeaderNotes[header] }}
                                      />
                                    </>
                                  )}
                                </div>
                              </th>
                            ))}
                          </tr>
                        </thead>
                        <tbody>
                          {mappedData.slice(1, Math.min(6, mappedData.length)).map((row, rowIndex) => (
                            <tr key={rowIndex} className={rowIndex % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                              {row.map((cell, cellIndex) => (
                                <td key={cellIndex} className="py-2 px-4 border-b dark:border-gray-600">
                                  {cell === undefined || cell === null ? '' : String(cell)}
                                </td>
                              ))}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                      {mappedData.length > 6 && (
                        <p className="mt-2 text-gray-500 dark:text-gray-400 text-sm">Showing first 5 rows of {mappedData.length - 1} total rows</p>
                      )}
                    </div>
                  )}
                </div>
                
                <div className="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                  <button
                    onClick={() => setStep(2)}
                    className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  >
                    Back to Mapping
                  </button>
                  <button
                    onClick={exportExcel}
                    disabled={isLoading.export}
                    className={`px-4 py-2 ${isLoading.export ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' : 'bg-excel-500 hover:bg-excel-600'} text-white rounded transition-colors flex items-center justify-center`}
                  >
                    {isLoading.export ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Exporting Excel File...
                      </span>
                    ) : (
                      <>
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        {enableMultiTabMapping ? 'Download Multi-Tab Mapped Excel File' : 'Download Mapped Excel File'}
                      </>
                    )}
                  </button>
                </div>
              </div>
            )}
            
            <div className="mt-6 text-center text-sm text-gray-500 dark:text-gray-400">
              Excel Template Mapper | Use this tool to map data between different Excel formats
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<ExcelMapper />, document.getElementById('excel-mapper-root'));
  </script>
</body>
</html>
