<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Excel Mapper</title>

  <script
  async
  crossorigin="anonymous"
  data-clerk-publishable-key="YOUR_CLERK_PUBLISHABLE_KEY"
  src="https://clerk.dev/static/js/clerk.js">
</script>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.4/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            // Excel green color palette
            excel: {
              50: '#eef9f1',
              100: '#d5f0db',
              200: '#ace1b7',
              300: '#7bca8e',
              400: '#4fb06a',
              500: '#217346', // Main Excel green
              600: '#1e6a40',
              700: '#1a5a38',
              800: '#154a2e',
              900: '#113c25',
            }
          }
        }
      }
    }
  </script>
  <style>
    /* Add base styles for dark mode */
    .dark {
      color-scheme: dark;
    }

    /* Fix for file input */
    input[type="file"]::-webkit-file-upload-button {
      cursor: pointer;
      height: 100%;
    }

    /* Custom scrollbar for better UX */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    
    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 4px;
    }
    
    .dark ::-webkit-scrollbar-thumb {
      background: #475569;
    }

    /* Enhanced Tooltip styles - update to trigger only on info icon */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltip-text {
      /* Size and shape */
      width: 280px;
      max-width: 90vw;
      border-radius: 8px;
      
      /* Positioning */
      position: absolute;
      z-index: 50;
      top: 125%;
      left: 0;
      
      /* Colors and borders */
      background-color: #217346; /* Excel green */
      color: #ffffff;
      border: 1px solid #1a5a38;
      
      /* Text formatting */
      font-size: 0.875rem;
      line-height: 1.5;
      text-align: left;
      
      /* Spacing and shadow */
      padding: 10px 12px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      
      /* Visibility and transition */
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      transform: translateY(-10px);
      
      /* Content overflow */
      overflow-wrap: break-word;
      word-wrap: break-word;
    }

    /* Arrow pointer for tooltip */
    .tooltip .tooltip-text::before {
      content: "";
      position: absolute;
      top: -8px;
      left: 15px;
      border-width: 0 8px 8px 8px;
      border-style: solid;
      border-color: transparent transparent #217346 transparent;
    }

    /* Only show tooltip when hovering over the info icon */
    .tooltip .info-icon:hover + .tooltip-text {
      visibility: visible;
      opacity: 1;
      transform: translateY(0);
    }

    /* Dark mode tooltip style */
    .dark .tooltip .tooltip-text {
      background-color: #1a5a38;
      border: 1px solid #154a2e;
      color: #ffffff;
    }

    .dark .tooltip .tooltip-text::before {
      border-color: transparent transparent #1a5a38 transparent;
    }

    /* For tooltips with longer content */
    .tooltip .tooltip-text.large {
      max-height: 200px;
      overflow-y: auto;
      padding-right: 15px;
    }

    /* Custom scrollbar for tooltip content */
    .tooltip .tooltip-text::-webkit-scrollbar {
      width: 6px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Styled tooltip content */
    .tooltip .tooltip-text h4 {
      margin: 0 0 5px 0;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 5px;
    }

    .tooltip .tooltip-text p {
      margin: 0 0 8px 0;
    }

    .tooltip .tooltip-text .highlight {
      background-color: rgba(255, 255, 255, 0.2);
      padding: 1px 3px;
      border-radius: 2px;
    }

    /* Column header styling */
    .has-notes {
      padding-bottom: 1px;
    }

    .tooltip .info-icon {
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #217346;
      color: white;
      margin-left: 5px;
      vertical-align: text-top;
      cursor: help;
    }

    .dark .tooltip .info-icon {
      background-color: #4fb06a;
    }

    /* Custom dropdown styles */
    .custom-select-container {
      position: relative;
      width: 100%;
    }

    .custom-select-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      background-color: white;
      cursor: pointer;
      user-select: none;
    }

    .dark .custom-select-header {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }

    .custom-select-header.error {
      border-color: #ef4444;
    }

    .custom-select-header .arrow {
      transition: transform 0.2s;
    }

    .custom-select-header.open .arrow {
      transform: rotate(180deg);
    }

    .custom-select-dropdown {
      position: absolute;
      left: 0;
      right: 0;
      margin-top: 4px;
      max-height: 250px;
      overflow-y: auto;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      z-index: 30;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      display: none;
    }

    .custom-select-dropdown.open {
      display: block;
    }

    .dark .custom-select-dropdown {
      background-color: #1f2937;
      border-color: #374151;
    }

    .custom-select-option {
      padding: 8px 12px;
      cursor: pointer;
      transition: background-color 0.1s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .custom-select-option:hover {
      background-color: #f3f4f6;
    }

    .dark .custom-select-option:hover {
      background-color: #374151;
    }

    .custom-select-option.selected {
      background-color: #f9fafb;
      font-weight: 500;
    }

    .dark .custom-select-option.selected {
      background-color: #2a3441;
    }

    .custom-select-option.suggested {
      color: #4b5563;
      font-style: italic;
    }

    .dark .custom-select-option.suggested {
      color: #9ca3af;
    }

    /* Sample preview styles */
    .sample-preview {
      position: absolute;
      z-index: 40;
      width: 280px;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
    }

    .sample-preview.visible {
      opacity: 1;
      visibility: visible;
    }

    .dark .sample-preview {
      background-color: #1f2937;
      border-color: #374151;
      color: white;
    }

    .sample-preview-header {
      padding: 10px 12px;
      background-color: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .dark .sample-preview-header {
      background-color: #374151;
      border-color: #4b5563;
    }

    .sample-preview-body {
      max-height: 180px;
      overflow-y: auto;
    }

    .sample-preview-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f3f4f6;
    }

    .sample-preview-item:last-child {
      border-bottom: none;
    }

    .dark .sample-preview-item {
      border-color: #374151;
    }

    .sample-preview-footer {
      padding: 8px 12px;
      background-color: #f9fafb;
      border-top: 1px solid #e5e7eb;
      font-size: 0.75rem;
      color: #6b7280;
      font-style: italic;
    }

    .dark .sample-preview-footer {
      background-color: #374151;
      border-color: #4b5563;
      color: #9ca3af;
    }

    /* Custom tooltip for dropdown options */
    .dropdown-tooltip {
      position: relative;
    }

    .dropdown-tooltip .tooltip-text {
      /* Fixed positioning for dropdown tooltips to escape overflow constraints */
      position: fixed;
      z-index: 100; /* Higher z-index to appear above all dropdowns */
      
      /* Sizing and spacing */
      width: 280px;
      max-width: 90vw;
      padding: 10px 12px;
      
      /* Remove standard positioning */
      left: auto;
      right: auto;
      top: auto;
      bottom: auto;
      
      /* Will be positioned via JavaScript */
      transform: none;
      
      /* Better shadow for dropdown tooltips */
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }

    /* Hide the standard arrow for dropdown tooltips */
    .dropdown-tooltip .tooltip-text::before {
      display: none;
    }
    
    /* Auto-mapping suggestion panel */
    .mapping-suggestion-panel {
      margin-bottom: 1.5rem;
      background-color: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 0.375rem;
      padding: 1rem;
    }
    
    .dark .mapping-suggestion-panel {
      background-color: rgba(14, 165, 233, 0.1);
      border-color: rgba(14, 165, 233, 0.2);
    }
    
    .mapping-suggestion {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      border-radius: 0.25rem;
      background-color: #fff;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }
    
    .dark .mapping-suggestion {
      background-color: #1f2937;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1);
    }
    
    .mapping-suggestion:last-child {
      margin-bottom: 0;
    }
    
    .mapping-confidence {
      display: inline-block;
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    .confidence-high {
      background-color: #dcfce7;
      color: #166534;
    }
    
    .dark .confidence-high {
      background-color: rgba(22, 101, 52, 0.3);
      color: #4ade80;
    }
    
    .confidence-medium {
      background-color: #fef9c3;
      color: #854d0e;
    }
    
    .dark .confidence-medium {
      background-color: rgba(133, 77, 14, 0.3);
      color: #facc15;
    }
    
    .confidence-low {
      background-color: #fee2e2;
      color: #b91c1c;
    }
    
    .dark .confidence-low {
      background-color: rgba(185, 28, 28, 0.3);
      color: #f87171;
    }

    /* Badge styles */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .worksheet-badge {
      background-color: #e0f2fe;
      color: #0369a1;
      border: 1px solid #bae6fd;
    }

    .dark .worksheet-badge {
      background-color: rgba(14, 165, 233, 0.2);
      border-color: rgba(14, 165, 233, 0.3);
      color: #38bdf8;
    }

    /* Category mapping styles */
    .category-mapping-item {
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      margin-bottom: 0.75rem;
      background-color: white;
    }

    .dark .category-mapping-item {
      background-color: #1f2937;
      border-color: #374151;
    }

    .category-mapping-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      background-color: #f9fafb;
      border-top-left-radius: 0.375rem;
      border-top-right-radius: 0.375rem;
    }

    .dark .category-mapping-header {
      background-color: #374151;
      border-color: #4b5563;
    }

    .category-mapping-body {
      padding: 1rem;
    }

    /* Tab selector styles */
    .tab-selector {
      display: flex;
      overflow-x: auto;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 1rem;
    }

    .dark .tab-selector {
      border-color: #4b5563;
    }

    .tab-item {
      padding: 0.5rem 1rem;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      white-space: nowrap;
      font-weight: 500;
    }

    .tab-item:hover {
      color: #4b5563;
    }

    .dark .tab-item:hover {
      color: #9ca3af;
    }

    .tab-item.active {
      border-bottom-color: #217346;
      color: #217346;
    }

    .dark .tab-item.active {
      border-bottom-color: #4fb06a;
      color: #4fb06a;
    }

    /* Worksheet tab selector */
    .worksheet-tab-selector {
      display: flex;
      overflow-x: auto;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background-color: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
    }

    .dark .worksheet-tab-selector {
      background-color: #1f2937;
      border-color: #374151;
    }

    .worksheet-tab-item {
      padding: 0.375rem 0.75rem;
      margin-right: 0.5rem;
      border-radius: 0.375rem;
      cursor: pointer;
      white-space: nowrap;
      font-size: 0.875rem;
      border: 1px solid transparent;
      transition: all 0.2s;
    }

    .worksheet-tab-item:hover {
      background-color: #f3f4f6;
    }

    .dark .worksheet-tab-item:hover {
      background-color: #374151;
    }

    .worksheet-tab-item.active {
      background-color: #eef9f1;
      border-color: #ace1b7;
      color: #217346;
      font-weight: 500;
    }

    .dark .worksheet-tab-item.active {
      background-color: rgba(79, 176, 106, 0.1);
      border-color: rgba(79, 176, 106, 0.3);
      color: #4fb06a;
    }

    .worksheet-tab-item.main {
      background-color: #f0f9ff;
      border-color: #bae6fd;
      color: #0369a1;
    }

    .dark .worksheet-tab-item.main {
      background-color: rgba(14, 165, 233, 0.1);
      border-color: rgba(14, 165, 233, 0.3);
      color: #38bdf8;
    }

    .worksheet-tab-item.main.active {
      background-color: #e0f7fa;
      border-color: #67e8f9;
      color: #0e7490;
    }

    .dark .worksheet-tab-item.main.active {
      background-color: rgba(8, 145, 178, 0.2);
      border-color: rgba(8, 145, 178, 0.4);
      color: #06b6d4;
    }

    /* Sheet selection styles */
    .sheet-checkbox {
      margin-right: 8px;
    }
    
    .sheet-selection-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    
    .sheet-selection-item {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
    }
    
    .dark .sheet-selection-item {
      background-color: #374151;
      border-color: #4b5563;
    }
    
    .sheet-selection-item.selected {
      border-color: #217346;
      background-color: #eef9f1;
    }
    
    .dark .sheet-selection-item.selected {
      border-color: #4fb06a;
      background-color: rgba(79, 176, 106, 0.1);
    }
    
    /* Format preservation notice */
    .format-preservation-notice {
      display: flex;
      align-items: flex-start;
      margin-top: 16px;
      padding: 12px;
      background-color: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 6px;
    }
    
    .dark .format-preservation-notice {
      background-color: rgba(14, 165, 233, 0.1);
      border-color: rgba(14, 165, 233, 0.2);
    }
    
    .format-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    
    .format-icon {
      margin-right: 6px;
      color: #217346;
    }
    
    .dark .format-icon {
      color: #4fb06a;
    }
    
    /* Worksheet header preview */
    .worksheet-preview {
      margin-top: 16px;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
    }
    
    .dark .worksheet-preview {
      border-color: #4b5563;
    }
    
    .worksheet-preview-header {
      padding: 10px 12px;
      background-color: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .dark .worksheet-preview-header {
      background-color: #374151;
      border-color: #4b5563;
    }
    
    .worksheet-preview-content {
      padding: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .worksheet-header-item {
      display: flex;
      align-items: center;
      padding: 8px;
      margin-bottom: 4px;
      border-radius: 4px;
      background-color: #f3f4f6;
    }
    
    .dark .worksheet-header-item {
      background-color: #1f2937;
    }

    /* Per-worksheet configuration table */
    .worksheet-config-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 0.875rem;
    }

    .worksheet-config-table th {
      text-align: left;
      padding: 8px;
      background-color: #f3f4f6;
      border: 1px solid #e5e7eb;
    }

    .dark .worksheet-config-table th {
      background-color: #374151;
      border-color: #4b5563;
    }

    .worksheet-config-table td {
      padding: 8px;
      border: 1px solid #e5e7eb;
    }

    .dark .worksheet-config-table td {
      border-color: #4b5563;
    }

    .worksheet-config-table input {
      width: 100%;
      padding: 4px 8px;
      border: 1px solid #e5e7eb;
      border-radius: 0.25rem;
    }

    .dark .worksheet-config-table input {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }

    .worksheet-config-table tr:nth-child(even) {
      background-color: #f9fafb;
    }

    .dark .worksheet-config-table tr:nth-child(even) {
      background-color: #1f2937;
    }

    /* Multi-sheet tag styles */
    .sheet-tag {
      display: inline-flex;
      align-items: center;
      background-color: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      padding: 0.25rem 0.5rem;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
      font-size: 0.875rem;
    }

    .dark .sheet-tag {
      background-color: #374151;
      border-color: #4b5563;
      color: #e5e7eb;
    }

    .sheet-tag-main {
      background-color: #eef9f1;
      border-color: #ace1b7;
      color: #217346;
    }

    .dark .sheet-tag-main {
      background-color: rgba(79, 176, 106, 0.2);
      border-color: rgba(79, 176, 106, 0.4);
      color: #4fb06a;
    }

    .sheet-tag .remove-btn {
      margin-left: 0.5rem;
      font-size: 0.75rem;
      padding: 0.125rem 0.25rem;
      color: #6b7280;
      cursor: pointer;
      border-radius: 0.25rem;
    }

    .sheet-tag .remove-btn:hover {
      background-color: rgba(0, 0, 0, 0.1);
      color: #ef4444;
    }

    .dark .sheet-tag .remove-btn:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: #f87171;
    }

    /* Sheet suggestions */
    .sheet-suggestions {
      margin-top: 0.5rem;
    }

    .sheet-suggestion-item {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
      background-color: #f9fafb;
      border: 1px dashed #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .sheet-suggestion-item:hover {
      background-color: #eef9f1;
      border-color: #ace1b7;
      color: #217346;
    }

    .dark .sheet-suggestion-item {
      background-color: #1f2937;
      border-color: #4b5563;
    }

    .dark .sheet-suggestion-item:hover {
      background-color: rgba(79, 176, 106, 0.1);
      border-color: rgba(79, 176, 106, 0.3);
      color: #4fb06a;
    }

    .sheet-suggestion-score {
      margin-left: 0.5rem;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .dark .sheet-suggestion-score {
      color: #9ca3af;
    }

    /* For highlighting the main tab in preview */
    .main-tab-highlight {
      background-color: #e0f2fe;
      border-left: 3px solid #0ea5e9;
    }

    .dark .main-tab-highlight {
      background-color: rgba(14, 165, 233, 0.1);
      border-left: 3px solid #0ea5e9;
    }

    /* Badge for main tab in preview */
    .main-tab-badge {
      display: inline-block;
      padding: 2px 6px;
      background-color: #0ea5e9;
      color: white;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      margin-left: 6px;
      text-transform: uppercase;
    }

    .dark .main-tab-badge {
      background-color: #0284c7;
    }

    /* Export options panel */
    .export-options-panel {
      margin-top: 20px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      background-color: #f9fafb;
    }

    .dark .export-options-panel {
      background-color: #1f2937;
      border-color: #374151;
    }

    .export-options-title {
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
    }

    .export-options-title svg {
      margin-right: 8px;
    }

    .export-option-group {
      margin-bottom: 16px;
    }

    .export-option-label {
      display: flex;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .export-option-label input {
      margin-top: 2px;
      margin-right: 8px;
    }

    .export-option-description {
      font-size: 0.875rem;
      color: #4b5563;
    }

    .dark .export-option-description {
      color: #9ca3af;
    }
    
    /* Warning notice styles */
    .warning-notice {
      display: flex;
      align-items: flex-start;
      margin-top: 16px;
      padding: 12px;
      background-color: #fff7ed;
      border: 1px solid #ffedd5;
      border-radius: 6px;
    }
    
    .dark .warning-notice {
      background-color: rgba(234, 88, 12, 0.1);
      border-color: rgba(234, 88, 12, 0.2);
    }
    
    .warning-icon {
      color: #ea580c;
      margin-right: 12px;
      flex-shrink: 0;
    }
    
    .dark .warning-icon {
      color: #fb923c;
    }

    /* Loading animation */
    .loader-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .loader-spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #217346;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }

    .dark .loader-spinner {
      border: 3px solid #374151;
      border-top: 3px solid #4fb06a;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Worksheet summary section */
    .worksheet-summary {
      background-color: #f9fafb;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      margin: 16px 0;
      padding: 16px;
    }

    .dark .worksheet-summary {
      background-color: #1f2937;
      border-color: #374151;
    }

    /* Status indicators */
    .status-indicator {
      display: inline-flex;
      align-items: center;
      padding: 2px 6px;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .status-success {
      background-color: #dcfce7;
      color: #166534;
    }

    .dark .status-success {
      background-color: rgba(22, 101, 52, 0.3);
      color: #4ade80;
    }

    .status-warning {
      background-color: #fef9c3;
      color: #854d0e;
    }

    .dark .status-warning {
      background-color: rgba(133, 77, 14, 0.3);
      color: #facc15;
    }

    .status-error {
      background-color: #fee2e2;
      color: #b91c1c;
    }

    .dark .status-error {
      background-color: rgba(185, 28, 28, 0.3);
      color: #f87171;
    }

    /* Collapsible section */
    .collapsible-section {
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    .dark .collapsible-section {
      border-color: #4b5563;
    }

    .collapsible-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background-color: #f9fafb;
      cursor: pointer;
      user-select: none;
    }

    .dark .collapsible-header {
      background-color: #374151;
    }

    .collapsible-header:hover {
      background-color: #f3f4f6;
    }

    .dark .collapsible-header:hover {
      background-color: #4b5563;
    }

    .collapsible-arrow {
      transition: transform 0.3s ease;
    }

    .collapsible-arrow.open {
      transform: rotate(180deg);
    }

    .collapsible-content {
      height: 0;
      overflow: hidden;
      transition: height 0.3s ease;
    }

    .collapsible-content.open {
      height: auto;
      padding: 1rem;
    }

    /* Product info detection styles */
    .product-info-container {
      padding: 12px;
      background-color: #f0fdf4;
      border: 1px solid #bbf7d0;
      border-radius: 6px;
    }

    .dark .product-info-container {
      background-color: rgba(34, 197, 94, 0.1);
      border-color: rgba(34, 197, 94, 0.2);
    }

    .detected-field {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      padding: 4px 8px;
      background-color: #dcfce7;
      border-radius: 4px;
    }

    .dark .detected-field {
      background-color: rgba(22, 101, 52, 0.2);
    }

    .detected-field-icon {
      color: #15803d;
      margin-right: 8px;
    }

    .dark .detected-field-icon {
      color: #4ade80;
    }
    
    /* Header preview styles */
    .header-preview {
      margin-top: 8px;
      padding: 8px;
      border-radius: 4px;
      background-color: #f3f4f6;
      font-family: monospace;
      font-size: 0.875rem;
      white-space: nowrap;
      overflow-x: auto;
      max-width: 100%;
      scrollbar-width: thin;
    }
    
    .dark .header-preview {
      background-color: #1f2937;
    }
    
    .header-preview-item {
      display: inline-block;
      padding: 2px 6px;
      margin-right: 2px;
      border-radius: 3px;
      background-color: #e0f2fe;
      color: #0369a1;
    }
    
    .dark .header-preview-item {
      background-color: rgba(14, 165, 233, 0.2);
      color: #38bdf8;
    }
    
    .no-headers {
      color: #ef4444;
      font-style: italic;
    }
    
    .dark .no-headers {
      color: #f87171;
    }
    
    /* Refresh button style */
    .refresh-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem 0.75rem;
      font-weight: 500;
      border-radius: 0.375rem;
      transition-property: background-color, border-color, color;
      transition-duration: 150ms;
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .refresh-btn svg {
      margin-right: 0.375rem;
      width: 1rem;
      height: 1rem;
    }
    
    .refresh-btn-primary {
      background-color: #217346;
      color: white;
    }
    
    .refresh-btn-primary:hover {
      background-color: #1e6a40;
    }
    
    .refresh-btn-primary:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(33, 115, 70, 0.5);
    }
    
    .dark .refresh-btn-primary {
      background-color: #4fb06a;
    }
    
    .dark .refresh-btn-primary:hover {
      background-color: #3c9d57;
    }
    
    .dark .refresh-btn-primary:focus {
      box-shadow: 0 0 0 2px rgba(79, 176, 106, 0.5);
    }
    
    /* Expanded header preview styles */
    .expanded-preview {
      max-height: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      margin-top: 0.5rem;
    }
    
    .dark .expanded-preview {
      border-color: #4b5563;
    }
    
    .preview-row {
      display: flex;
      border-bottom: 1px solid #e5e7eb;
      overflow-x: auto;
    }
    
    .dark .preview-row {
      border-color: #4b5563;
    }
    
    .preview-row:last-child {
      border-bottom: none;
    }
    
    .preview-cell {
      flex: 1 0 120px;
      min-width: 120px;
      padding: 0.5rem;
      border-right: 1px solid #e5e7eb;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .dark .preview-cell {
      border-color: #4b5563;
    }
    
    .preview-cell:last-child {
      border-right: none;
    }
    
    .preview-header {
      font-weight: 600;
      background-color: #f9fafb;
    }
    
    .dark .preview-header {
      background-color: #374151;
    }
    
    /* Preset modal styles */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 40;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .modal-content {
      background-color: white;
      border-radius: 0.5rem;
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      position: relative;
    }
    
    .dark .modal-content {
      background-color: #1f2937;
    }
    
    .modal-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .dark .modal-header {
      border-color: #374151;
    }
    
    .modal-body {
      padding: 1.5rem;
      max-height: 60vh;
      overflow-y: auto;
    }
    
    .modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid #e5e7eb;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }
    
    .dark .modal-footer {
      border-color: #374151;
    }
    
    .preset-item {
      padding: 0.75rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      margin-bottom: 0.75rem;
      transition: all 0.2s;
    }
    
    .dark .preset-item {
      border-color: #374151;
    }
    
    .preset-item:hover {
      background-color: #f9fafb;
    }
    
    .dark .preset-item:hover {
      background-color: #374151;
    }
    
    .preset-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.5rem;
    }
    
    .preset-title {
      font-weight: 600;
      font-size: 1rem;
    }
    
    .preset-description {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 0.25rem;
    }
    
    .dark .preset-description {
      color: #9ca3af;
    }
    
    .preset-details {
      font-size: 0.875rem;
      color: #4b5563;
      margin-top: 0.5rem;
    }
    
    .dark .preset-details {
      color: #9ca3af;
    }
    
    .preset-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .preset-btn {
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 500;
      transition: all 0.15s;
    }
    
    .preset-btn-load {
      background-color: #4fb06a;
      color: white;
    }
    
    .preset-btn-load:hover {
      background-color: #3c9d57;
    }
    
    .preset-btn-delete {
      background-color: #ef4444;
      color: white;
    }
    
    .preset-btn-delete:hover {
      background-color: #dc2626;
    }
    
    /* Preset save form */
    .preset-form-group {
      margin-bottom: 1rem;
    }
    
    .preset-form-label {
      display: block;
      font-weight: 500;
      margin-bottom: 0.375rem;
    }
    
    .preset-form-input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }
    
    .dark .preset-form-input {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }
    
    .preset-form-textarea {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      min-height: 80px;
      resize: vertical;
    }
    
    .dark .preset-form-textarea {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }
    
    /* Preset dropdown menu */
    .preset-menu-container {
      position: relative;
      display: inline-block;
    }
    
    .preset-menu-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      width: 200px;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.25rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      z-index: 30;
      margin-top: 0.25rem;
      display: none;
    }
    
    .dark .preset-menu-dropdown {
      background-color: #1f2937;
      border-color: #374151;
    }
    
    .preset-menu-dropdown.open {
      display: block;
    }
    
    .preset-menu-item {
      padding: 0.5rem 0.75rem;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    
    .preset-menu-item:hover {
      background-color: #f3f4f6;
    }
    
    .dark .preset-menu-item:hover {
      background-color: #374151;
    }
    
    .preset-menu-item svg {
      margin-right: 0.5rem;
      width: 1rem;
      height: 1rem;
    }
    
    .preset-menu-divider {
      height: 1px;
      background-color: #e5e7eb;
      margin: 0.25rem 0;
    }
    
    .dark .preset-menu-divider {
      background-color: #4b5563;
    }
    
    /* Preset select dropdown */
    .preset-select-container {
      position: relative;
      display: inline-block;
      margin-right: 1rem;
    }
    
    .preset-select {
      display: flex;
      align-items: center;
      padding: 0.5rem 0.75rem;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      background-color: white;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .dark .preset-select {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }
    
    .preset-select:hover {
      background-color: #f9fafb;
      border-color: #d1d5db;
    }
    
    .dark .preset-select:hover {
      background-color: #4b5563;
      border-color: #6b7280;
    }
    
    .preset-select svg {
      margin-right: 0.5rem;
      width: 1rem;
      height: 1rem;
    }
    
    .preset-select-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      width: 240px;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.25rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      z-index: 30;
      margin-top: 0.25rem;
      max-height: 300px;
      overflow-y: auto;
      display: none;
    }
    
    .dark .preset-select-dropdown {
      background-color: #1f2937;
      border-color: #374151;
    }
    
    .preset-select-dropdown.open {
      display: block;
    }
    
    .preset-option {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
    }
    
    .dark .preset-option {
      border-color: #374151;
    }
    
    .preset-option:last-child {
      border-bottom: none;
    }
    
    .preset-option:hover {
      background-color: #f3f4f6;
    }
    
    .dark .preset-option:hover {
      background-color: #374151;
    }
    
    .preset-option-title {
      font-weight: 500;
      margin-bottom: 0.25rem;
    }
    
    .preset-option-desc {
      font-size: 0.75rem;
      color: #6b7280;
    }
    
    .dark .preset-option-desc {
      color: #9ca3af;
    }
    
    .preset-empty {
      padding: 1rem;
      text-align: center;
      color: #6b7280;
      font-style: italic;
    }
    
    .dark .preset-empty {
      color: #9ca3af;
    }
  </style>
</head>
<body>
  <div id="excel-mapper-root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Check for dark mode preference
    const initDarkMode = () => {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.classList.add('dark');
        return true;
      }
      return false;
    };

    // Modal component for presets
    const Modal = ({ isOpen, onClose, title, children, footer }) => {
      if (!isOpen) return null;
      
      return (
        <div className="modal-backdrop" onClick={onClose}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h2 className="text-lg font-semibold">{title}</h2>
              <button 
                onClick={onClose}
                className="text-gray-400 hover:text-gray-500 dark:text-gray-500 dark:hover:text-gray-400"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <div className="modal-body">
              {children}
            </div>
            {footer && (
              <div className="modal-footer">
                {footer}
              </div>
            )}
          </div>
        </div>
      );
    };

    // Custom Select Component with hover preview support and descriptions
    const CustomSelect = ({ 
      options, 
      value, 
      onChange, 
      placeholder = "-- Select an option --", 
      isError = false,
      suggestedValue = null,
      columnSamples = {},
      columnDescriptions = {}
    }) => {
      const [isOpen, setIsOpen] = useState(false);
      const [previewVisible, setPreviewVisible] = useState(false);
      const [previewHeader, setPreviewHeader] = useState(null);
      const [previewPos, setPreviewPos] = useState({ top: 0, left: 0 });
      const previewTimerRef = useRef(null);
      const dropdownRef = useRef(null);
      const containerRef = useRef(null);
      
      // Handle click outside to close dropdown
      useEffect(() => {
        const handleClickOutside = (event) => {
          if (containerRef.current && !containerRef.current.contains(event.target)) {
            setIsOpen(false);
          }
        };
        
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
          document.removeEventListener('mousedown', handleClickOutside);
        };
      }, []);
      
      // Clean up preview timer
      useEffect(() => {
        return () => {
          if (previewTimerRef.current) {
            clearTimeout(previewTimerRef.current);
          }
        };
      }, []);

      const handleToggle = () => {
        setIsOpen(!isOpen);
      };
      
      const handleSelect = (optionValue) => {
        onChange(optionValue);
        setIsOpen(false);
      };
      
      const handleOptionMouseEnter = (e, optionValue) => {
        // Clear any existing timer
        if (previewTimerRef.current) {
          clearTimeout(previewTimerRef.current);
        }
        
        // Set a timer to show preview after 1.5 seconds
        if (columnSamples[optionValue] && columnSamples[optionValue].length > 0) {
          previewTimerRef.current = setTimeout(() => {
            // Calculate position
            const rect = e.currentTarget.getBoundingClientRect();
            
            setPreviewHeader(optionValue);
            setPreviewPos({
              top: rect.top,
              left: rect.right + 10 // 10px right of the option
            });
            setPreviewVisible(true);
          }, 1500);
        }
      };
      
      const handleOptionMouseLeave = () => {
        if (previewTimerRef.current) {
          clearTimeout(previewTimerRef.current);
          previewTimerRef.current = null;
        }
        setPreviewVisible(false);
      };
      
      // Find the selected option's label
      const selectedOption = options.find(opt => opt.value === value);
      const displayValue = selectedOption ? selectedOption.label : placeholder;
      
      // Helper to check if a column has a description
      const hasDescription = (optionValue) => {
        return columnDescriptions[optionValue] && columnDescriptions[optionValue].trim() !== '';
      };
      
      return (
        <div ref={containerRef} className="custom-select-container">
          <div 
            className={`custom-select-header ${isOpen ? 'open' : ''} ${isError ? 'error' : ''}`} 
            onClick={handleToggle}
          >
            <span className={!selectedOption ? 'text-gray-400 dark:text-gray-500' : 'flex items-center'}>
              {displayValue}
              {value && hasDescription(value) && (
                <div className="tooltip ml-1">
                  <span className="info-icon text-xs">i</span>
                  <span 
                    className={`tooltip-text ${columnDescriptions[value] && columnDescriptions[value].length > 150 ? 'large' : ''}`}
                    dangerouslySetInnerHTML={{ __html: columnDescriptions[value] }}
                  />
                </div>
              )}
            </span>
            <span className="arrow">▼</span>
          </div>
          
          <div 
            ref={dropdownRef} 
            className={`custom-select-dropdown ${isOpen ? 'open' : ''}`}
          >
            {options.map((option) => (
              <div
                key={option.value || 'empty'}
                className={`custom-select-option ${option.value === value ? 'selected' : ''} ${option.value === suggestedValue ? 'suggested' : ''}`}
                onClick={() => handleSelect(option.value)}
                onMouseEnter={(e) => handleOptionMouseEnter(e, option.value)}
                onMouseLeave={handleOptionMouseLeave}
              >
                <div className="flex justify-between w-full items-center">
                  <div className="flex items-center">
                    <span className="mr-1">{option.label}</span>
                    {hasDescription(option.value) && (
                      <div className="dropdown-tooltip tooltip">
                        <span className="info-icon text-xs" 
                          onMouseEnter={(e) => {
                            // Get tooltip element (next sibling)
                            const tooltip = e.target.nextSibling;
                            if (tooltip) {
                              // Calculate position - above the icon
                              const rect = e.target.getBoundingClientRect();
                              tooltip.style.top = `${rect.top - 10 - tooltip.offsetHeight}px`;
                              tooltip.style.left = `${rect.left - tooltip.offsetWidth + 20}px`;
                              tooltip.style.visibility = 'visible';
                              tooltip.style.opacity = '1';
                            }
                          }}
                          onMouseLeave={(e) => {
                            // Hide tooltip on mouse leave
                            const tooltip = e.target.nextSibling;
                            if (tooltip) {
                              tooltip.style.visibility = 'hidden';
                              tooltip.style.opacity = '0';
                            }
                          }}
                        >i</span>
                        <span 
                          className={`tooltip-text ${columnDescriptions[option.value] && columnDescriptions[option.value].length > 150 ? 'large' : ''}`}
                          dangerouslySetInnerHTML={{ __html: columnDescriptions[option.value] }}
                        />
                      </div>
                    )}
                  </div>
                  
                  {option.value === suggestedValue && (
                    <span className="text-sm text-gray-500 dark:text-gray-400">(Suggested)</span>
                  )}
                </div>
              </div>
            ))}
          </div>
          
          {/* Sample preview popup */}
          {previewVisible && columnSamples[previewHeader] && (
            <div 
              className={`sample-preview ${previewVisible ? 'visible' : ''}`}
              style={{ top: `${previewPos.top}px`, left: `${previewPos.left}px` }}
            >
              <div className="sample-preview-header">
                Sample data: <span className="text-excel-600 dark:text-excel-400">{previewHeader}</span>
              </div>
              <div className="sample-preview-body">
                {columnSamples[previewHeader].map((sample, index) => (
                  <div key={index} className="sample-preview-item">
                    {typeof sample === 'undefined' || sample === null ? 
                      <span className="text-gray-400 dark:text-gray-500">Empty</span> : 
                      String(sample)
                    }
                  </div>
                ))}
              </div>
              <div className="sample-preview-footer">
                Showing {columnSamples[previewHeader].length} sample values from this column
              </div>
            </div>
          )}
        </div>
      );
    };

    // Collapsible Section Component
    const CollapsibleSection = ({ title, children, statusIndicator = null, defaultOpen = false }) => {
      const [isOpen, setIsOpen] = useState(defaultOpen);
      const contentRef = useRef(null);
      
      const toggleOpen = () => {
        setIsOpen(!isOpen);
      };
      
      return (
        <div className="collapsible-section">
          <div className="collapsible-header" onClick={toggleOpen}>
            <div className="flex items-center">
              <h3 className="font-medium">{title}</h3>
              {statusIndicator && (
                <div className="ml-2">{statusIndicator}</div>
              )}
            </div>
            <svg 
              className={`w-5 h-5 collapsible-arrow ${isOpen ? 'open' : ''}`} 
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 20 20" 
              fill="currentColor"
            >
              <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
            </svg>
          </div>
          <div 
            ref={contentRef}
            className={`collapsible-content ${isOpen ? 'open' : ''}`}
            style={{ height: isOpen ? contentRef.current?.scrollHeight + 'px' : '0' }}
          >
            {children}
          </div>
        </div>
      );
    };

    // Header Preview Component
    const HeaderPreview = ({ headers, label = "Headers Preview" }) => {
      const [expanded, setExpanded] = useState(false);
      
      // Limit to first 10 headers for the compact preview
      const previewHeaders = headers.slice(0, 10);
      const hasMore = headers.length > 10;
      
      return (
        <div>
          <div className="flex items-center justify-between">
            <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">{label}</p>
            {headers.length > 0 && (
              <button 
                onClick={() => setExpanded(!expanded)} 
                className="text-xs text-blue-600 dark:text-blue-400 hover:underline"
              >
                {expanded ? "Collapse" : "Expand"}
              </button>
            )}
          </div>
          
          {!expanded ? (
            <div className="header-preview">
              {headers.length > 0 ? (
                <>
                  {previewHeaders.map((header, index) => (
                    <span key={index} className="header-preview-item">{header}</span>
                  ))}
                  {hasMore && <span className="text-gray-400 dark:text-gray-500 ml-1">... and {headers.length - 10} more</span>}
                </>
              ) : (
                <span className="no-headers">No headers detected</span>
              )}
            </div>
          ) : (
            <div className="expanded-preview">
              <div className="preview-row">
                {headers.map((header, index) => (
                  <div key={index} className="preview-cell preview-header">{header || '(empty)'}</div>
                ))}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Preset Manager component
    const PresetManager = ({ 
      presets,
      savePreset,
      loadPreset,
      deletePreset,
      currentConfig
    }) => {
      const [isDropdownOpen, setIsDropdownOpen] = useState(false);
      const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
      const [isLoadModalOpen, setIsLoadModalOpen] = useState(false);
      const [presetName, setPresetName] = useState('');
      const [presetDescription, setPresetDescription] = useState('');
      const dropdownRef = useRef(null);
      
      // Close dropdown when clicking outside
      useEffect(() => {
        const handleClickOutside = (event) => {
          if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
            setIsDropdownOpen(false);
          }
        };
        
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
          document.removeEventListener('mousedown', handleClickOutside);
        };
      }, []);
      
      // Format date for display
      const formatDate = (timestamp) => {
        return new Date(timestamp).toLocaleString();
      };
      
      // Handle save preset
      const handleSavePreset = () => {
        if (!presetName.trim()) {
          alert('Please enter a preset name');
          return;
        }
        
        savePreset({
          name: presetName,
          description: presetDescription,
          ...currentConfig
        });
        
        setPresetName('');
        setPresetDescription('');
        setIsSaveModalOpen(false);
      };
      
      // Handle load preset
      const handleLoadPreset = (preset) => {
        loadPreset(preset);
        setIsLoadModalOpen(false);
      };
      
      return (
        <>
          <div className="preset-menu-container" ref={dropdownRef}>
            <button 
              className="preset-select flex items-center"
              onClick={() => setIsDropdownOpen(!isDropdownOpen)}
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path d="M5 4a1 1 0 00-2 0v7.268a2 2 0 000 3.464V16a1 1 0 102 0v-1.268a2 2 0 000-3.464V4zM11 4a1 1 0 10-2 0v1.268a2 2 0 000 3.464V16a1 1 0 102 0V8.732a2 2 0 000-3.464V4zM16 3a1 1 0 011 1v7.268a2 2 0 010 3.464V16a1 1 0 11-2 0v-1.268a2 2 0 010-3.464V4a1 1 0 011-1z" />
              </svg>
              Presets
            </button>
            
            <div className={`preset-menu-dropdown ${isDropdownOpen ? 'open' : ''}`}>
              <div 
                className="preset-menu-item"
                onClick={() => {
                  setIsDropdownOpen(false);
                  setIsSaveModalOpen(true);
                }}
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                </svg>
                Save Current Setup
              </div>
              
              <div 
                className="preset-menu-item"
                onClick={() => {
                  setIsDropdownOpen(false);
                  setIsLoadModalOpen(true);
                }}
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
                Load Preset
              </div>
            </div>
          </div>
          
          {/* Save Preset Modal */}
          <Modal
            isOpen={isSaveModalOpen}
            onClose={() => setIsSaveModalOpen(false)}
            title="Save Current Setup as Preset"
            footer={
              <>
                <button 
                  className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded"
                  onClick={() => setIsSaveModalOpen(false)}
                >
                  Cancel
                </button>
                <button 
                  className="px-4 py-2 bg-excel-500 hover:bg-excel-600 text-white rounded"
                  onClick={handleSavePreset}
                >
                  Save Preset
                </button>
              </>
            }
          >
            <div className="preset-form-group">
              <label className="preset-form-label">Preset Name</label>
              <input
                type="text"
                className="preset-form-input"
                value={presetName}
                onChange={(e) => setPresetName(e.target.value)}
                placeholder="Enter a name for this preset"
              />
            </div>
            
            <div className="preset-form-group">
              <label className="preset-form-label">Description (optional)</label>
              <textarea
                className="preset-form-textarea"
                value={presetDescription}
                onChange={(e) => setPresetDescription(e.target.value)}
                placeholder="Enter a description for this preset"
              />
            </div>
            
            <div className="text-sm text-gray-500 dark:text-gray-400 mt-2">
              <p>This preset will save:</p>
              <ul className="list-disc ml-6 mt-1">
                <li>All selected worksheets and their header row settings</li>
                <li>All column mappings between template and data</li>
                <li>Multi-tab mapping configuration (if enabled)</li>
              </ul>
            </div>
          </Modal>
          
          {/* Load Preset Modal */}
          <Modal
            isOpen={isLoadModalOpen}
            onClose={() => setIsLoadModalOpen(false)}
            title="Load Saved Preset"
            footer={
              <button 
                className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded"
                onClick={() => setIsLoadModalOpen(false)}
              >
                Close
              </button>
            }
          >
            {presets.length > 0 ? (
              <div className="space-y-3">
                {presets.map((preset, index) => (
                  <div key={index} className="preset-item">
                    <div className="preset-header">
                      <div>
                        <div className="preset-title">{preset.name}</div>
                        {preset.description && (
                          <div className="preset-description">{preset.description}</div>
                        )}
                      </div>
                      
                      <div className="preset-actions">
                        <button 
                          className="preset-btn preset-btn-load"
                          onClick={() => handleLoadPreset(preset)}
                        >
                          Load
                        </button>
                        <button 
                          className="preset-btn preset-btn-delete"
                          onClick={() => {
                            if (confirm(`Are you sure you want to delete the preset "${preset.name}"?`)) {
                              deletePreset(preset.id);
                            }
                          }}
                        >
                          Delete
                        </button>
                      </div>
                    </div>
                    
                    <div className="preset-details">
                      <div className="flex justify-between">
                        <span>Created: {formatDate(preset.createdAt)}</span>
                        <span>{Object.keys(preset.selectedTemplateSheets || {}).filter(sheet => preset.selectedTemplateSheets[sheet]).length} worksheets</span>
                      </div>
                      
                      {preset.enableMultiTabMapping ? (
                        <div className="mt-1">Multi-tab mapping enabled with {Object.keys(preset.categoryWorksheetMappings || {}).length} categories</div>
                      ) : (
                        <div className="mt-1">Single tab mapping with {Object.keys(preset.mappings || {}).length} column mappings</div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="preset-empty">
                <p>No saved presets yet. Create one by saving your current configuration.</p>
              </div>
            )}
          </Modal>
        </>
      );
    };

    const ExcelMapper = () => {
      const [template, setTemplate] = useState(null);
      const [data, setData] = useState(null);
      const [templateFile, setTemplateFile] = useState(null);
      const [dataFile, setDataFile] = useState(null);
      const [templateHeaders, setTemplateHeaders] = useState([]);
      const [dataHeaders, setDataHeaders] = useState([]);
      const [mappings, setMappings] = useState({});
      const [suggestedMappings, setSuggestedMappings] = useState({});
      const [mappingScores, setMappingScores] = useState({});
      const [mappedData, setMappedData] = useState(null);
      const [step, setStep] = useState(1);
      const [isDarkMode, setIsDarkMode] = useState(initDarkMode());
      const [isLoading, setIsLoading] = useState({
        template: false,
        data: false,
        mapping: false,
        headerLoad: false,
        export: false,
        refreshing: false
      });
      
      // Sheet selection states
      const [templateSheets, setTemplateSheets] = useState([]);
      const [dataSheets, setDataSheets] = useState([]);
      const [selectedDataSheet, setSelectedDataSheet] = useState('');
      const [templateHeaderRow, setTemplateHeaderRow] = useState(1);
      const [dataHeaderRow, setDataHeaderRow] = useState(1);
      
      // State to track selected template worksheets
      const [selectedTemplateSheets, setSelectedTemplateSheets] = useState({});
      
      // Required/Optional field states
      const [requirementRowAvailable, setRequirementRowAvailable] = useState(false);
      const [templateRequirementRow, setTemplateRequirementRow] = useState(2);
      const [fieldRequirements, setFieldRequirements] = useState({});
      
      // Template header notes state from data validation or comments
      const [templateHeaderNotes, setTemplateHeaderNotes] = useState({});
      const [dataHeaderDescriptions, setDataHeaderDescriptions] = useState({});
      const [debugInfo, setDebugInfo] = useState("");
      
      // Column data samples for preview
      const [columnSamples, setColumnSamples] = useState({});
      
      // State to track if suggestions have been reviewed
      const [suggestionsReviewed, setSuggestionsReviewed] = useState(false);
      
      // States for multi-tab mapping
      const [enableMultiTabMapping, setEnableMultiTabMapping] = useState(false);
      const [categoryColumn, setCategoryColumn] = useState('');
      const [categoryValues, setCategoryValues] = useState([]);
      const [categoryWorksheetMappings, setCategoryWorksheetMappings] = useState({});
      const [activeTab, setActiveTab] = useState(null);
      const [activeWorksheet, setActiveWorksheet] = useState(null);
      
      // Enhanced tabSpecificMappings to store per-worksheet mappings within each category
      const [worksheetMappings, setWorksheetMappings] = useState({});
      
      // Worksheet suggestions based on fuzzy matching
      const [worksheetSuggestions, setWorksheetSuggestions] = useState({});
      // Option to always include main tab
      const [includeMainTab, setIncludeMainTab] = useState(true);
      const [mainTabSelection, setMainTabSelection] = useState("");

      // States for sheet-specific header mappings
      const [worksheetHeadersMap, setWorksheetHeadersMap] = useState({});
      const [worksheetRequirementsMap, setWorksheetRequirementsMap] = useState({});
      const [worksheetNotesMap, setWorksheetNotesMap] = useState({});
      const [preserveFormatting, setPreserveFormatting] = useState(true);
      
      // States for per-worksheet configuration
      const [worksheetHeaderRows, setWorksheetHeaderRows] = useState({});
      const [worksheetRequirementRows, setWorksheetRequirementRows] = useState({});
      
      // States for storing worksheet data for preview
      const [worksheetDataMap, setWorksheetDataMap] = useState({});
      
      // Export options
      const [exportOptions, setExportOptions] = useState({
        preserveFormulas: true,
        preserveFormatting: true,
        preserveStyles: true,
        applyColumnFormats: true,
        preserveValidation: true,
        includeMacros: false, // Default to false
        preserveExistingData: true, // New option to keep all template data intact
        preserveHeaderRows: true, // New option to preserve rows above the header
        dataRowOffset: 1 // New option to specify how many rows below the header to start inserting data
      });

      // Product information detection
      const [detectProductInfo, setDetectProductInfo] = useState(true);
      const [productInfoDetected, setProductInfoDetected] = useState({});
      const [productFields, setProductFields] = useState({});
      const [worksheetStatus, setWorksheetStatus] = useState({});
      
      // Preset states
      const [presets, setPresets] = useState([]);

      // Load presets from localStorage on mount
      useEffect(() => {
        try {
          const savedPresets = localStorage.getItem('excelMapperPresets');
          if (savedPresets) {
            setPresets(JSON.parse(savedPresets));
          }
        } catch (error) {
          console.error('Error loading presets:', error);
          // Initialize with empty array if error
          setPresets([]);
        }
      }, []);
      
      // Update localStorage when presets change
      useEffect(() => {
        localStorage.setItem('excelMapperPresets', JSON.stringify(presets));
      }, [presets]);
      
      // Listen for dark mode changes
      useEffect(() => {
        const darkModeListener = (e) => {
          const isDark = e.matches;
          setIsDarkMode(isDark);
          if (isDark) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        };
        
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        mediaQuery.addEventListener('change', darkModeListener);
        
        return () => mediaQuery.removeEventListener('change', darkModeListener);
      }, []);

      // Function to save current configuration as a preset
      const savePreset = (presetData) => {
        const newPreset = {
          id: Date.now().toString(),
          createdAt: Date.now(),
          name: presetData.name,
          description: presetData.description || '',
          
          // Template settings
          selectedTemplateSheets,
          worksheetHeaderRows,
          worksheetRequirementRows,
          requirementRowAvailable,
          
          // Mapping settings
          mappings,
          suggestedMappings,
          
          // Multi-tab mapping settings
          enableMultiTabMapping,
          categoryColumn,
          includeMainTab,
          mainTabSelection,
          categoryWorksheetMappings,
          worksheetMappings,
          activeTab,
          activeWorksheet
        };
        
        // Save specific states based on current step
        if (step === 2) {
          // Save additional mapping details specific to step 2
          newPreset.step2State = {
            categoryValues,
            mappingScores
          };
        }
        
        setPresets(prev => [...prev, newPreset]);
      };
      
      // Function to load a preset
      const loadPreset = (preset) => {
        // Loading template settings
        setSelectedTemplateSheets(preset.selectedTemplateSheets || {});
        setWorksheetHeaderRows(preset.worksheetHeaderRows || {});
        setWorksheetRequirementRows(preset.worksheetRequirementRows || {});
        setRequirementRowAvailable(preset.requirementRowAvailable || false);
        
        // Loading mapping settings
        setMappings(preset.mappings || {});
        if (preset.suggestedMappings) {
          setSuggestedMappings(preset.suggestedMappings);
        }
        
        // Loading multi-tab mapping settings
        setEnableMultiTabMapping(preset.enableMultiTabMapping || false);
        setCategoryColumn(preset.categoryColumn || '');
        setIncludeMainTab(preset.includeMainTab || true);
        setMainTabSelection(preset.mainTabSelection || '');
        setCategoryWorksheetMappings(preset.categoryWorksheetMappings || {});
        setWorksheetMappings(preset.worksheetMappings || {});
        
        // Restore step 2 specific state if available
        if (preset.step2State) {
          if (preset.step2State.categoryValues) {
            setCategoryValues(preset.step2State.categoryValues);
          }
          if (preset.step2State.mappingScores) {
            setMappingScores(preset.step2State.mappingScores);
          }
        }
        
        // Set active tab and worksheet if they exist
        if (preset.activeTab) {
          setActiveTab(preset.activeTab);
        } else if (preset.categoryWorksheetMappings && Object.keys(preset.categoryWorksheetMappings).length > 0) {
          // Set to first category if none specified
          setActiveTab(Object.keys(preset.categoryWorksheetMappings)[0]);
        }
        
        if (preset.activeWorksheet) {
          setActiveWorksheet(preset.activeWorksheet);
        } else if (preset.activeTab && 
                  preset.categoryWorksheetMappings && 
                  preset.categoryWorksheetMappings[preset.activeTab] && 
                  preset.categoryWorksheetMappings[preset.activeTab].length > 0) {
          // Set to first worksheet for active category
          setActiveWorksheet(preset.categoryWorksheetMappings[preset.activeTab][0]);
        }
        
        // If data is already loaded, we need to reset certain states
        if (data) {
          // If multi-tab mapping is enabled, refresh category values
          if (preset.enableMultiTabMapping && preset.categoryColumn) {
            if (data.data && data.data.length > 1) {
              const dataRows = data.data.slice(1);
              // If we've restored category values from preset, use them directly
              if (!preset.step2State || !preset.step2State.categoryValues) {
                updateCategoryValues(data.headers, dataRows, preset.categoryColumn);
              }
            }
          }
          
          // Set suggestions reviewed to true to hide suggestion panel if mappings were already set
          if (Object.keys(preset.mappings || {}).length > 0 || 
              Object.keys(preset.worksheetMappings || {}).length > 0) {
            setSuggestionsReviewed(true);
          }
        }
        
        // Refresh worksheet headers after loading preset
        if (template) {
          refreshWorksheetHeaders();
        }
      };
      
      // Function to delete a preset
      const deletePreset = (presetId) => {
        setPresets(prev => prev.filter(preset => preset.id !== presetId));
      };

      // Function to check if a header is likely a product information field
      const identifyProductFields = (headers, sheetName) => {
        // Common patterns for product-related headers
        const productFieldPatterns = {
          productId: /\b(product|item|sku)[-_\s]*(id|number|no|code|identifier)\b/i,
          productName: /\b(product|item)[-_\s]*(name|title|label)\b/i,
          description: /\b(product|item)?[-_\s]*(desc|description|details|narrative|features)\b/i,
          price: /\b(price|cost|msrp|retail[-_\s]*price|sale[-_\s]*price|unit[-_\s]*price)\b/i,
          quantity: /\b(qty|quantity|inventory|stock|level|count)\b/i,
          category: /\b(category|dept|department|classification|type|group)\b/i,
          brand: /\b(brand|manufacturer|vendor|supplier|make)\b/i,
          upc: /\b(upc|ean|gtin|isbn|barcode)\b/i,
          color: /\b(color|colour|shade|hue)\b/i,
          size: /\b(size|dimension|measurement|width|height|length|weight)\b/i,
          material: /\b(material|fabric|composition|made[-_\s]*of)\b/i,
          images: /\b(image|img|photo|picture|thumbnail|url)\b/i
        };

        const productFields = {};
        const matchedFields = new Set();
        
        // Check each header against the patterns
        headers.forEach(header => {
          if (!header) return;
          
          // Test against each pattern
          for (const [fieldType, pattern] of Object.entries(productFieldPatterns)) {
            if (pattern.test(header.toLowerCase()) && !matchedFields.has(fieldType)) {
              if (!productFields[fieldType]) {
                productFields[fieldType] = [];
              }
              productFields[fieldType].push({
                header,
                sheet: sheetName
              });
              matchedFields.add(fieldType);
              break; // Match only one field type per header
            }
          }
        });
        
        return productFields;
      };

      // Function to handle file uploads
      const handleFileUpload = (e, fileType) => {
        const file = e.target.files[0];
        if (!file) return;
        
        setIsLoading(prev => ({ ...prev, [fileType]: true }));
        
        const reader = new FileReader();
        
        reader.onload = (evt) => {
          try {
            const binaryString = evt.target.result;
            const workbook = XLSX.read(binaryString, { 
              type: 'binary', 
              cellFormula: true, 
              cellDates: true,
              cellNF: true, 
              cellStyles: true,
              bookVBA: true, // Preserve VBA and macros
              bookFiles: true // Preserve embedded files/objects
            });
            
            if (fileType === 'template') {
              setTemplateFile(file);
              setTemplateSheets(workbook.SheetNames);
              
              // Set the main tab to the first sheet by default
              if (workbook.SheetNames.length > 0) {
                setMainTabSelection(workbook.SheetNames[0]);
              }
              
              // Initialize header and requirement rows for each worksheet
              const initialHeaderRows = {};
              const initialRequirementRows = {};
              
              workbook.SheetNames.forEach(sheet => {
                initialHeaderRows[sheet] = 1; // Default to row 1 for headers
                initialRequirementRows[sheet] = 2; // Default to row 2 for requirements
              });
              
              setWorksheetHeaderRows(initialHeaderRows);
              setWorksheetRequirementRows(initialRequirementRows);
              
              // Initialize selected worksheets - select all by default
              const initialSelectedSheets = {};
              workbook.SheetNames.forEach(sheet => {
                initialSelectedSheets[sheet] = true;
              });
              setSelectedTemplateSheets(initialSelectedSheets);

              // Save workbook to enable refreshing later
              setTemplate({ 
                workbook,
                headers: [], 
                data: [],
                worksheetHeaders: {},
                worksheetRequirements: {},
                worksheetNotes: {}
              });
              
              // Process worksheet data for preview
              processWorksheetData(workbook);
            } else {
              setDataFile(file);
              setDataSheets(workbook.SheetNames);
              setSelectedDataSheet(workbook.SheetNames[0]);
            }
          } catch (error) {
            console.error(`Error reading ${fileType} file:`, error);
          } finally {
            setIsLoading(prev => ({ ...prev, [fileType]: false }));
          }
        };
        
        reader.onerror = () => {
          console.error(`Error reading ${fileType} file`);
          setIsLoading(prev => ({ ...prev, [fileType]: false }));
        };
        
        reader.readAsBinaryString(file);
      };
      
      // Process worksheet data for preview
      const processWorksheetData = (workbook) => {
        if (!workbook || !workbook.SheetNames || workbook.SheetNames.length === 0) return;
        
        const dataMap = {};
        
        // Process each worksheet to store sample data
        workbook.SheetNames.forEach(sheetName => {
          try {
            const worksheet = workbook.Sheets[sheetName];
            
            // Convert worksheet to JSON data with header option
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            // Store first few rows for preview
            dataMap[sheetName] = jsonData.slice(0, 5); // Store just first 5 rows for preview
          } catch (error) {
            console.error(`Error processing worksheet ${sheetName}:`, error);
            dataMap[sheetName] = [];
          }
        });
        
        setWorksheetDataMap(dataMap);
      };
      
      // Refresh headers for a specific worksheet based on current row settings
      const refreshWorksheetHeaders = () => {
        if (!template || !template.workbook) return;
        
        setIsLoading(prev => ({ ...prev, refreshing: true }));
        
        try {
          // Process each worksheet in the template
          const headerMap = {};
          const requirementsMap = {};
          const notesMap = {};
          const statusMap = {};
          let detectedProductInfo = {};
          
          // Process each worksheet one at a time
          for (let i = 0; i < template.workbook.SheetNames.length; i++) {
            try {
              const sheetName = template.workbook.SheetNames[i];
              console.log(`Processing worksheet: ${sheetName}`);
              
              const worksheet = template.workbook.Sheets[sheetName];
              // Use a try-catch for sheet_to_json in case a sheet has issues
              let jsonData = [];
              try {
                jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
              } catch (sheetError) {
                console.error(`Error converting sheet ${sheetName} to JSON:`, sheetError);
                jsonData = []; // Use empty array if conversion fails
              }
              
              // Safely determine the header row index with fallbacks
              const headerRowIndex = Math.max(0, ((worksheetHeaderRows || {})[sheetName] || 1) - 1);
              
              // Safely get headers with fallback
              const headers = (jsonData && jsonData.length > headerRowIndex) ? 
                jsonData[headerRowIndex] || [] : [];
              
              // Initialize worksheet status
              statusMap[sheetName] = {
                headerCount: headers.filter(Boolean).length,
                status: headers.length > 0 ? 'success' : 'error',
                message: headers.length > 0 
                  ? `${headers.filter(Boolean).length} headers detected` 
                  : 'No headers found'
              };
              
              // Process requirement row if enabled
              let requirements = {};
              if (requirementRowAvailable) {
                const reqRowIndex = Math.max(0, ((worksheetRequirementRows || {})[sheetName] || 2) - 1);
                const reqRow = (jsonData && jsonData.length > reqRowIndex) ? jsonData[reqRowIndex] || [] : [];
                
                headers.forEach((header, index) => {
                  if (!header) return;
                  
                  // Check if the requirement cell contains any indicator of being required
                  const reqValue = index < reqRow.length ? reqRow[index] : null;
                  const reqString = reqValue ? String(reqValue) : '';
                  const isRequired = reqString && 
                    reqString.toLowerCase().match(/required|mandatory|req|r|yes|y|\*/i) !== null;
                  
                  requirements[header] = isRequired ? 'Required' : 'Optional';
                });
              } else {
                // Default all fields to optional if no requirement row specified
                headers.forEach(header => {
                  if (header) {
                    requirements[header] = 'Optional';
                  }
                });
              }
              
              // Extract notes and validation messages for this worksheet - with simplified approach
              const notes = {};
              let validationCount = 0;
              let commentCount = 0;
              
              // Only process notes for the first few columns to avoid excessive processing
              const maxHeadersToProcess = Math.min(headers.length, 50); // Limit to first 50 headers
              
              for (let headerIndex = 0; headerIndex < maxHeadersToProcess; headerIndex++) {
                const header = headers[headerIndex];
                if (!header) continue;
                
                try {
                  // Calculate the cell reference
                  const colLetter = XLSX.utils.encode_col(headerIndex);
                  const cellRef = `${colLetter}${headerRowIndex + 1}`;
                  
                  let foundNote = "";
                  
                  // Try simplified validation access (safer)
                  if (worksheet['!dataValidations'] && Array.isArray(worksheet['!dataValidations'])) {
                    const validations = worksheet['!dataValidations'];
                    for (let i = 0; i < Math.min(validations.length, 50); i++) { // Limit validation checks
                      const validation = validations[i];
                      if (validation && validation.sqref && 
                         (validation.sqref === cellRef || 
                          (typeof validation.sqref === 'string' && validation.sqref.includes(cellRef)))) {
                        if (validation.prompt) {
                          foundNote = validation.prompt;
                          validationCount++;
                          break;
                        }
                      }
                    }
                  }
                  
                  // Store the note
                  notes[header] = foundNote;
                  
                } catch (noteError) {
                  console.error(`Error processing notes for ${header}:`, noteError);
                  notes[header] = ""; // Use empty note on error
                }
              }
              
              // Don't process product info for this sheet if it has too many headers or causes issues
              if (detectProductInfo && headers.length > 0 && headers.length < 500) {
                try {
                  const detectedFields = identifyProductFields(headers, sheetName);
                  
                  // If product fields were found in this sheet, update status
                  const fieldCount = Object.values(detectedFields).reduce((total, arr) => total + arr.length, 0);
                  if (fieldCount > 0) {
                    statusMap[sheetName].productFields = fieldCount;
                    statusMap[sheetName].isProductSheet = fieldCount >= 3; // Consider it a product sheet if 3+ product fields
                    
                    // Merge with existing detected fields (safer approach)
                    Object.entries(detectedFields).forEach(([fieldType, fields]) => {
                      if (!detectedProductInfo[fieldType]) {
                        detectedProductInfo[fieldType] = [];
                      }
                      detectedProductInfo[fieldType] = [
                        ...detectedProductInfo[fieldType], 
                        ...fields
                      ].slice(0, 20); // Limit to prevent too many fields
                    });
                  }
                } catch (productError) {
                  console.error(`Error detecting product fields in ${sheetName}:`, productError);
                }
              }
              
              // Store headers, requirements, and notes for this worksheet
              headerMap[sheetName] = headers;
              requirementsMap[sheetName] = requirements;
              notesMap[sheetName] = notes;
            } catch (worksheetError) {
              console.error(`Error processing worksheet ${template.workbook.SheetNames[i]}:`, worksheetError);
              // Create empty data for this worksheet to prevent the app from crashing
              const sheetName = template.workbook.SheetNames[i];
              headerMap[sheetName] = [];
              requirementsMap[sheetName] = {};
              notesMap[sheetName] = {};
              statusMap[sheetName] = {
                headerCount: 0,
                status: 'error',
                message: `Error: ${worksheetError.message}`
              };
            }
          }
          
          // Store all worksheet-specific header information
          setWorksheetHeadersMap(headerMap);
          setWorksheetRequirementsMap(requirementsMap);
          setWorksheetNotesMap(notesMap);
          setWorksheetStatus(statusMap);
          
          // Store detected product information (limiting the size to prevent UI issues)
          if (detectProductInfo) {
            // Limit the number of fields stored to prevent performance issues
            Object.keys(detectedProductInfo).forEach(key => {
              if (detectedProductInfo[key].length > 10) {
                detectedProductInfo[key] = detectedProductInfo[key].slice(0, 10);
              }
            });
            
            setProductInfoDetected(detectedProductInfo);
            setProductFields(detectedProductInfo);
          }
          
          // Use the headers from the first worksheet for default view
          if (template.workbook.SheetNames.length > 0) {
            const firstSheet = template.workbook.SheetNames[0];
            setTemplateHeaders(headerMap[firstSheet] || []);
            setFieldRequirements(requirementsMap[firstSheet] || {});
            setTemplateHeaderNotes(notesMap[firstSheet] || {});
            
            // Update template with new info
            setTemplate(prev => ({ 
              ...prev,
              headers: headerMap[firstSheet] || [], 
              data: [headerMap[firstSheet] || []],
              worksheetHeaders: headerMap,
              worksheetRequirements: requirementsMap,
              worksheetNotes: notesMap
            }));
          }
          
          // Create debug info summarizing what we found
          let totalHeaderCount = 0;
          Object.values(headerMap).forEach(headers => {
            if (headers && Array.isArray(headers)) {
              totalHeaderCount += headers.filter(Boolean).length;
            }
          });
          
          const productFieldCount = Object.values(detectedProductInfo)
            .reduce((total, arr) => total + (Array.isArray(arr) ? arr.length : 0), 0);
          
          setDebugInfo(
            `Loaded ${totalHeaderCount} columns from ${template.workbook.SheetNames.length} worksheets. ` +
            (productFieldCount > 0 ? `Detected ${productFieldCount} product-related fields.` : '')
          );
          
          // Reset suggestions reviewed state when refreshing
          setSuggestionsReviewed(false);
        } catch (error) {
          console.error('Error refreshing template headers:', error);
          setDebugInfo(`Error: ${error.message}`);
        } finally {
          setIsLoading(prev => ({ ...prev, refreshing: false }));
        }
      };

      // Process the selected data worksheet
      const processDataSheet = () => {
        if (!dataFile) return;
        
        setIsLoading(prev => ({ ...prev, data: true }));
        
        const reader = new FileReader();
        
        reader.onload = (evt) => {
          try {
            const binaryString = evt.target.result;
            const workbook = XLSX.read(binaryString, { 
              type: 'binary', 
              cellFormula: true,
              cellStyles: true,
              cellDates: true,
              cellNF: true,
              bookVBA: true,
              bookFiles: true
            });
            
            // Process the selected data worksheet
            const selectedSheet = selectedDataSheet;
            const worksheet = workbook.Sheets[selectedSheet];
            
            // Get all data as array of arrays
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            const headerRowIndex = dataHeaderRow - 1;
            const headers = jsonData[headerRowIndex] || [];
            
            // Generate demo descriptions for data headers
            const descriptions = {};
            headers.forEach((header, index) => {
              if (!header) return;
              
              // Create descriptive text based on header name
              const words = header.split(/[\s_.-]+/);
              const formattedHeader = words.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');
              
              if (index % 5 === 0) {
                descriptions[header] = `<h4>${formattedHeader}</h4><p>Contains unique identifier values for each record. Use this for reference or linking to other systems.</p>`;
              } else if (index % 5 === 1) {
                descriptions[header] = `<h4>${formattedHeader}</h4><p>This column stores ${formattedHeader.toLowerCase()} values from the source system. <span class="highlight">Important for data integrity</span>.</p>`;
              } else if (index % 5 === 2) {
                descriptions[header] = `<h4>About ${formattedHeader}</h4><p>Contains formatted text data with ${formattedHeader.toLowerCase()} information. This data is used for reporting and analytics.</p>`;
              } else if (index % 5 === 3) {
                descriptions[header] = `<h4>${formattedHeader} Details</h4><p>This column provides metadata about each record, including things like:</p><ul><li>Source system information</li><li>Last update timestamp</li><li>Validation status</li></ul>`;
              } else {
                descriptions[header] = `<h4>${formattedHeader} Column</h4><p>This field contains supplementary information that may be useful for specific reporting needs. The content is <span class="highlight">variable in format</span>.</p>`;
              }
            });
            
            setDataHeaderDescriptions(descriptions);
            
            // Get data rows (all rows after the header row)
            const dataRows = jsonData.slice(headerRowIndex + 1);
            
            // Combine headers with dataRows for complete dataset
            const fullData = [headers, ...dataRows];
            
            setData({ workbook, sheet: selectedSheet, headers, data: fullData });
            setDataHeaders(headers);
            
            // Extract sample data for each column (up to 5 unique non-empty values)
            const samples = {};
            headers.forEach((header, colIndex) => {
              if (!header) return;
              
              const columnData = new Set();
              // Loop through the first 20 rows to find samples
              for (let rowIndex = 0; rowIndex < Math.min(dataRows.length, 20); rowIndex++) {
                const row = dataRows[rowIndex];
                if (row && colIndex < row.length && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== '') {
                  columnData.add(row[colIndex]);
                  if (columnData.size >= 5) break; // Collect up to 5 samples
                }
              }
              
              // Convert Set to Array
              samples[header] = Array.from(columnData);
              
              // If we don't have enough samples, try to get more including empty values
              if (samples[header].length < 3 && dataRows.length > 0) {
                samples[header] = [];
                for (let rowIndex = 0; rowIndex < Math.min(dataRows.length, 5); rowIndex++) {
                  const row = dataRows[rowIndex];
                  if (row && colIndex < row.length) {
                    samples[header].push(row[colIndex]);
                  }
                }
              }
            });
            
            setColumnSamples(samples);
            
            // If template headers already exist, generate suggested mappings
            if (templateHeaders.length > 0) {
              const { suggestions, scores } = generateFuzzyMappings(templateHeaders, headers);
              setSuggestedMappings(suggestions);
              setMappingScores(scores);
              setMappings(suggestions);
              
              // Reset suggestions reviewed state when loading new data
              setSuggestionsReviewed(false);
            }
            
            // Get unique values for category column if one is selected
            if (enableMultiTabMapping && categoryColumn) {
              updateCategoryValues(headers, dataRows, categoryColumn);
            }
          } catch (error) {
            console.error('Error processing data sheet:', error);
            setDebugInfo(`Error: ${error.message}`);
          } finally {
            setIsLoading(prev => ({ ...prev, data: false }));
          }
        };
        
        reader.onerror = () => {
          console.error('Error reading data file for processing');
          setIsLoading(prev => ({ ...prev, data: false }));
        };
        
        reader.readAsBinaryString(dataFile);
      };

      // Enhanced fuzzy matching function
      const fuzzyMatch = (str1, str2) => {
        if (!str1 || !str2) return 0;
        
        // Normalize strings: lowercase, remove special chars, trim whitespace
        const cleanStr1 = String(str1).toLowerCase().replace(/[^a-z0-9]/gi, '');
        const cleanStr2 = String(str2).toLowerCase().replace(/[^a-z0-9]/gi, '');
        
        // Exact match after normalization is a perfect score
        if (cleanStr1 === cleanStr2) return 1.0;
        
        // Calculate Levenshtein distance-based similarity
        const len1 = cleanStr1.length;
        const len2 = cleanStr2.length;
        
        // If either string is empty, similarity is 0
        if (len1 === 0 || len2 === 0) return 0;
        
        // Check for containment (one string is part of the other)
        if (cleanStr1.includes(cleanStr2) || cleanStr2.includes(cleanStr1)) {
          // Length ratio determines strength of the match
          const containmentScore = Math.min(len1, len2) / Math.max(len1, len2);
          // Boost score for containment
          return Math.min(1.0, containmentScore + 0.3);
        }
        
        // Character by character matching, giving more weight to matching prefixes
        let matchScore = 0;
        const maxLen = Math.max(len1, len2);
        const minLen = Math.min(len1, len2);
        
        for (let i = 0; i < minLen; i++) {
          // Characters match
          if (cleanStr1[i] === cleanStr2[i]) {
            // Earlier matches are more important (prefix bonus)
            matchScore += 1 - (i / (2 * maxLen));
          }
        }
        
        // Normalize score
        return matchScore / maxLen;
      };

      // Generate suggested mappings based on enhanced fuzzy matching
      const generateFuzzyMappings = (templateHeaders, dataHeaders) => {
        const suggestions = {};
        const scores = {};
        
        templateHeaders.forEach(templateHeader => {
          if (!templateHeader) return;
          
          // Track all matches for this template header
          let matches = [];
          
          dataHeaders.forEach(dataHeader => {
            if (!dataHeader) return;
            
            const score = fuzzyMatch(templateHeader, dataHeader);
            if (score > 0.3) { // Consider any match above 30% similarity
              matches.push({ header: dataHeader, score });
            }
          });
          
          // Sort matches by score (highest first)
          matches.sort((a, b) => b.score - a.score);
          
          // Store scores for all potential matches
          scores[templateHeader] = matches;
          
          // Only use the best match if it's good enough (above 60% similarity)
          if (matches.length > 0 && matches[0].score > 0.6) {
            suggestions[templateHeader] = matches[0].header;
          }
        });
        
        return { suggestions, scores };
      };

      // Handle mapping change with enhanced for per-worksheet mapping
      const handleMappingChange = (templateHeader, dataHeader, category = null, worksheet = null) => {
        if (enableMultiTabMapping && category && worksheet) {
          // Update worksheet-specific mappings
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // Initialize nested objects if they don't exist
            if (!newMappings[category]) {
              newMappings[category] = {};
            }
            if (!newMappings[category][worksheet]) {
              newMappings[category][worksheet] = {};
            }
            
            // Update the mapping for the current category/worksheet
            newMappings[category][worksheet][templateHeader] = dataHeader;
            
            // If this is the main tab, sync this mapping to all categories that use the main tab
            if (worksheet === mainTabSelection) {
              // Find all categories that use the main tab
              Object.keys(categoryWorksheetMappings).forEach(otherCategory => {
                if (otherCategory !== category && 
                    categoryWorksheetMappings[otherCategory] && 
                    categoryWorksheetMappings[otherCategory].includes(mainTabSelection)) {
                  
                  // Initialize if needed
                  if (!newMappings[otherCategory]) {
                    newMappings[otherCategory] = {};
                  }
                  if (!newMappings[otherCategory][mainTabSelection]) {
                    newMappings[otherCategory][mainTabSelection] = {};
                  }
                  
                  // Copy the mapping to the main tab in this category
                  newMappings[otherCategory][mainTabSelection][templateHeader] = dataHeader;
                }
              });
            } else {
              // For non-main tabs, try to sync with same-named worksheets in other categories
              // Find other categories that use the same worksheet name
              Object.keys(categoryWorksheetMappings).forEach(otherCategory => {
                if (otherCategory !== category && 
                    categoryWorksheetMappings[otherCategory] && 
                    categoryWorksheetMappings[otherCategory].includes(worksheet)) {
                  
                  // Initialize if needed
                  if (!newMappings[otherCategory]) {
                    newMappings[otherCategory] = {};
                  }
                  if (!newMappings[otherCategory][worksheet]) {
                    newMappings[otherCategory][worksheet] = {};
                  }
                  
                  // Copy the mapping to the same worksheet in this category
                  newMappings[otherCategory][worksheet][templateHeader] = dataHeader;
                }
              });
            }
            
            return newMappings;
          });
        } else {
          // Update shared mappings
          setMappings(prev => ({
            ...prev,
            [templateHeader]: dataHeader
          }));
        }
      };

      // Update category values when category column changes
      const updateCategoryValues = (headers, dataRows, categoryCol) => {
        // Find the index of the category column
        const colIndex = headers.indexOf(categoryCol);
        
        if (colIndex === -1) {
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setWorksheetSuggestions({});
          return;
        }
        
        // Get unique values from the category column
        const uniqueValues = new Set();
        dataRows.forEach(row => {
          if (row && colIndex < row.length && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== '') {
            uniqueValues.add(String(row[colIndex]));
          }
        });
        
        const valueArray = Array.from(uniqueValues).sort();
        
        // Update state with the unique values
        setCategoryValues(valueArray);
        
        // Find worksheet suggestions for each category value
        const allSuggestions = {};
        
        // Initialize worksheet mappings for each category value (now as arrays)
        const initialMappings = {};
        
        valueArray.forEach(value => {
          // Get suggestions for this category value
          const suggestions = findWorksheetSuggestions(value);
          allSuggestions[value] = suggestions;
          
          // Initialize with the best match or first worksheet
          const bestMatch = suggestions.length > 0 ? suggestions[0].sheet : null;
          const initialSheets = [];
          
          // Add the best match if found
          if (bestMatch) {
            initialSheets.push(bestMatch);
          }
          
          // Add the main tab if selected and it's different from the best match
          if (includeMainTab && mainTabSelection && mainTabSelection !== bestMatch) {
            initialSheets.push(mainTabSelection);
          }
          
          // If no sheets selected yet, use the first available worksheet
          if (initialSheets.length === 0 && templateSheets.length > 0) {
            initialSheets.push(templateSheets[0]);
          }
          
          initialMappings[value] = initialSheets;
        });
        
        setCategoryWorksheetMappings(initialMappings);
        setWorksheetSuggestions(allSuggestions);
        
        // Set the first category value as the active tab
        if (valueArray.length > 0) {
          setActiveTab(valueArray[0]);
          // Set the first worksheet as active for this category
          if (initialMappings[valueArray[0]] && initialMappings[valueArray[0]].length > 0) {
            setActiveWorksheet(initialMappings[valueArray[0]][0]);
          }
        }
        
        // Initialize worksheet mappings for each category and worksheet
        const initialWorksheetMappings = {};
        
        // For each category and its worksheets, initialize mappings with suggested mappings
        Object.entries(initialMappings).forEach(([category, worksheets]) => {
          initialWorksheetMappings[category] = {};
          
          worksheets.forEach(worksheet => {
            // For the main tab, use the suggested mappings
            if (worksheet === mainTabSelection) {
              initialWorksheetMappings[category][worksheet] = { ...suggestedMappings };
            } else {
              // For other worksheets, initialize with empty mappings
              initialWorksheetMappings[category][worksheet] = {};
            }
          });
        });
        
        setWorksheetMappings(initialWorksheetMappings);
      };

      // Find worksheet suggestions for category values
      const findWorksheetSuggestions = (categoryValue) => {
        if (!categoryValue || !templateSheets.length) return [];
        
        // Get fuzzy matches between the category value and worksheet names
        const suggestions = [];
        
        templateSheets.forEach(sheet => {
          const score = fuzzyMatch(categoryValue, sheet);
          if (score > 0.3) { // Consider any match above 30% similarity
            suggestions.push({ sheet, score });
          }
        });
        
        // Sort by score (highest first)
        suggestions.sort((a, b) => b.score - a.score);
        
        return suggestions;
      };

      // Handle category column change
      const handleCategoryColumnChange = (column) => {
        setCategoryColumn(column);
        
        if (!column) {
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setWorksheetSuggestions({});
          setActiveTab(null);
          setActiveWorksheet(null);
          return;
        }
        
        // Retrieve the data rows
        if (!data || !data.data || data.data.length <= 1) return;
        
        const dataRows = data.data.slice(1); // Skip header row
        
        updateCategoryValues(data.headers, dataRows, column);
      };

      // Add a worksheet to a category's mapping
      const addWorksheetToCategory = (categoryValue, worksheet, isMain = false) => {
        setCategoryWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          // Initialize array if needed
          if (!newMappings[categoryValue]) {
            newMappings[categoryValue] = [];
          }
          
          // Add worksheet if not already included
          if (!newMappings[categoryValue].includes(worksheet)) {
            if (isMain) {
              // Add as first item if it's the main tab
              newMappings[categoryValue] = [worksheet, ...newMappings[categoryValue]];
            } else {
              // Add to the end otherwise
              newMappings[categoryValue] = [...newMappings[categoryValue], worksheet];
            }
          }
          
          return newMappings;
        });
        
        // Initialize worksheet mappings for this category and worksheet
        setWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          // Initialize nested objects if they don't exist
          if (!newMappings[categoryValue]) {
            newMappings[categoryValue] = {};
          }
          
          // Only initialize if it doesn't exist yet
          if (!newMappings[categoryValue][worksheet]) {
            // For main tab, use suggested mappings; otherwise empty
            if (worksheet === mainTabSelection) {
              newMappings[categoryValue][worksheet] = { ...suggestedMappings };
            } else {
              newMappings[categoryValue][worksheet] = {};
            }
          }
          
          return newMappings;
        });
      };

      // Remove a worksheet from a category's mapping
      const removeWorksheetFromCategory = (categoryValue, worksheet) => {
        setCategoryWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          if (newMappings[categoryValue]) {
            newMappings[categoryValue] = newMappings[categoryValue].filter(sheet => sheet !== worksheet);
          }
          
          return newMappings;
        });
        
        // Clean up mappings for this worksheet
        setWorksheetMappings(prev => {
          const newMappings = { ...prev };
          
          if (newMappings[categoryValue] && newMappings[categoryValue][worksheet]) {
            delete newMappings[categoryValue][worksheet];
          }
          
          return newMappings;
        });
        
        // If the active worksheet is being removed, select another one
        if (activeTab === categoryValue && activeWorksheet === worksheet) {
          // Find another worksheet for this category
          const remainingWorksheets = categoryWorksheetMappings[categoryValue]?.filter(
            sheet => sheet !== worksheet
          ) || [];
          
          if (remainingWorksheets.length > 0) {
            setActiveWorksheet(remainingWorksheets[0]);
          } else {
            setActiveWorksheet(null);
          }
        }
      };

      // Handle main tab selection change
      const handleMainTabChange = (tabName) => {
        setMainTabSelection(tabName);
        
        // If including main tab is enabled, update all category mappings
        if (includeMainTab && categoryValues.length > 0) {
          setCategoryWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // For each category
            Object.keys(newMappings).forEach(category => {
              // Remove previous main tab if it exists
              if (mainTabSelection && newMappings[category].includes(mainTabSelection)) {
                newMappings[category] = newMappings[category].filter(sheet => sheet !== mainTabSelection);
              }
              
              // Add new main tab if not already included (at the beginning of the array)
              if (tabName && !newMappings[category].includes(tabName)) {
                newMappings[category] = [tabName, ...newMappings[category]];
              }
            });
            
            return newMappings;
          });
          
          // Update worksheet mappings too
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // For each category
            Object.keys(prev).forEach(category => {
              // If the old main tab had mappings, and the new main tab doesn't,
              // copy those mappings to the new main tab
              if (prev[category] && prev[category][mainTabSelection] && tabName) {
                if (!newMappings[category]) {
                  newMappings[category] = {};
                }
                
                // Initialize new main tab with suggested mappings or old mappings
                newMappings[category][tabName] = { ...prev[category][mainTabSelection] };
                
                // Clean up old main tab if not in the category's worksheet list
                if (!categoryWorksheetMappings[category]?.includes(mainTabSelection)) {
                  delete newMappings[category][mainTabSelection];
                }
              }
            });
            
            return newMappings;
          });
        }
      };

      // Handle changing the active worksheet for the current category
      const handleWorksheetTabChange = (worksheet) => {
        setActiveWorksheet(worksheet);
      };

      // Toggle including main tab
      const toggleIncludeMainTab = (e) => {
        const include = e.target.checked;
        setIncludeMainTab(include);
        
        // Update all category mappings
        if (categoryValues.length > 0) {
          setCategoryWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // For each category
            Object.keys(newMappings).forEach(category => {
              if (include) {
                // Add main tab if not already included
                if (mainTabSelection && !newMappings[category].includes(mainTabSelection)) {
                  newMappings[category] = [mainTabSelection, ...newMappings[category]];
                }
              } else {
                // Remove main tab if it exists
                if (mainTabSelection && newMappings[category].includes(mainTabSelection)) {
                  newMappings[category] = newMappings[category].filter(sheet => sheet !== mainTabSelection);
                }
              }
            });
            
            return newMappings;
          });
          
          // Clear active worksheet if it was the main tab
          if (!include && activeWorksheet === mainTabSelection) {
            // Find another worksheet for this category
            const remainingWorksheets = categoryWorksheetMappings[activeTab]?.filter(
              sheet => sheet !== mainTabSelection
            ) || [];
            
            if (remainingWorksheets.length > 0) {
              setActiveWorksheet(remainingWorksheets[0]);
            } else {
              setActiveWorksheet(null);
            }
          }
        }
      };

      // Toggle product information detection
      const toggleProductInfoDetection = (e) => {
        setDetectProductInfo(e.target.checked);
      };

      // Accept all suggestions for the current worksheet mapping
      const acceptAllSuggestions = () => {
        if (enableMultiTabMapping && activeTab && activeWorksheet) {
          // Update worksheet-specific mappings with suggestions
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            // Initialize nested objects if they don't exist
            if (!newMappings[activeTab]) {
              newMappings[activeTab] = {};
            }
            if (!newMappings[activeTab][activeWorksheet]) {
              newMappings[activeTab][activeWorksheet] = {};
            }
            
            // Apply all suggested mappings
            Object.entries(suggestedMappings).forEach(([templateHeader, dataHeader]) => {
              newMappings[activeTab][activeWorksheet][templateHeader] = dataHeader;
            });
            
            return newMappings;
          });
        } else {
          // Update shared mappings
          setMappings(suggestedMappings);
        }
        
        setSuggestionsReviewed(true);
      };
      
      // Accept a specific mapping suggestion
      const acceptSuggestion = (templateHeader) => {
        if (!suggestedMappings[templateHeader]) return;
        
        if (enableMultiTabMapping && activeTab && activeWorksheet) {
          // Update worksheet-specific mapping
          handleMappingChange(templateHeader, suggestedMappings[templateHeader], activeTab, activeWorksheet);
        } else {
          // Update shared mappings
          setMappings(prev => ({
            ...prev,
            [templateHeader]: suggestedMappings[templateHeader]
          }));
        }
      };
      
      // Clear a specific mapping
      const clearMapping = (templateHeader, category = null, worksheet = null) => {
        if (enableMultiTabMapping && category && worksheet) {
          // Update worksheet-specific mappings
          setWorksheetMappings(prev => {
            const newMappings = { ...prev };
            
            if (newMappings[category] && 
                newMappings[category][worksheet] && 
                newMappings[category][worksheet][templateHeader]) {
              delete newMappings[category][worksheet][templateHeader];
            }
            
            return newMappings;
          });
        } else {
          // Update shared mappings
          setMappings(prev => {
            const newMappings = { ...prev };
            delete newMappings[templateHeader];
            return newMappings;
          });
        }
      };

      // Validate mappings before proceeding
      const validateMappings = (category = null, worksheet = null) => {
        // Determine which mappings to check
        let mappingsToCheck;
        
        if (enableMultiTabMapping && category && worksheet && 
            worksheetMappings[category] && worksheetMappings[category][worksheet]) {
          mappingsToCheck = worksheetMappings[category][worksheet];
        } else {
          mappingsToCheck = mappings;
        }
        
        const missingRequiredFields = [];
        
        // Get the relevant headers and requirements for this worksheet
        let headers, requirements;
        
        if (worksheet && worksheetHeadersMap[worksheet]) {
          headers = worksheetHeadersMap[worksheet] || [];
          requirements = worksheetRequirementsMap[worksheet] || {};
        } else {
          headers = templateHeaders;
          requirements = fieldRequirements;
        }
        
        headers.forEach(header => {
          if (!header) return;
          
          const isRequired = requirements[header] === 'Required';
          const isMapped = mappingsToCheck[header] && mappingsToCheck[header] !== '';
          
          if (isRequired && !isMapped) {
            missingRequiredFields.push(header);
          }
        });
        
        return {
          valid: missingRequiredFields.length === 0,
          missingFields: missingRequiredFields
        };
      };

      // Map data based on current mappings
      const mapData = () => {
        if (!template || !data) return;
        
        setIsLoading(prev => ({ ...prev, mapping: true }));
        
        try {
          if (enableMultiTabMapping) {
            // Handle multi-tab mapping with worksheet-specific mappings
            const mappedDataByKey = {};
            
            // Find the index of the category column
            const categoryColIndex = data.headers.indexOf(categoryColumn);
            
            if (categoryColIndex === -1) {
              throw new Error("Category column not found in data headers");
            }
            
            // Process all data rows (including handling the main tab specially)
            const allDataRows = data.data.slice(1); // Skip header row
            
            // Check if we should map all data to the main tab
            if (includeMainTab && mainTabSelection) {
              // IMPORTANT: Always get the specific template headers for the main tab
              // This ensures we use the actual headers from this worksheet
              const mainTabHeaders = worksheetHeadersMap[mainTabSelection] || templateHeaders;
              
              const mainTabMappedRows = [mainTabHeaders]; // Start with main tab headers
              
              // Create a mapping key for the main tab (use "ALL" as category to distinguish)
              const mainTabKey = `ALL:${mainTabSelection}`;
              
              // Get the main tab mappings for applying to data
              let mainTabMappings = {}; 
              
              // Find any category that uses the main tab for mappings
              const categoryWithMainTab = Object.keys(categoryWorksheetMappings).find(
                catKey => categoryWorksheetMappings[catKey]?.includes(mainTabSelection)
              );
              
              if (categoryWithMainTab && 
                  worksheetMappings[categoryWithMainTab] && 
                  worksheetMappings[categoryWithMainTab][mainTabSelection]) {
                mainTabMappings = worksheetMappings[categoryWithMainTab][mainTabSelection];
              } else {
                // Fall back to shared mappings
                mainTabMappings = mappings;
              }
              
              // Map ALL data rows to the main tab
              allDataRows.forEach(dataRow => {
                const mappedRow = new Array(mainTabHeaders.length).fill('');
                
                // For each template header in this specific worksheet
                mainTabHeaders.forEach((templateHeader, templateColIndex) => {
                  if (!templateHeader) return;
                  
                  // Look up the data column mapped to this template header
                  const dataHeader = mainTabMappings[templateHeader];
                  
                  if (dataHeader) {
                    // Find the index of this header in the data
                    const dataColIndex = data.headers.indexOf(dataHeader);
                    
                    if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                      mappedRow[templateColIndex] = dataRow[dataColIndex];
                    }
                  }
                });
                
                mainTabMappedRows.push(mappedRow);
              });
              
              // Store mapped data for the main tab (all data)
              mappedDataByKey[mainTabKey] = {
                category: "All Data",
                worksheet: mainTabSelection,
                data: mainTabMappedRows,
                isMainTab: true,
                headers: mainTabHeaders,
                requirements: worksheetRequirementsMap[mainTabSelection] || fieldRequirements,
                headerRow: worksheetHeaderRows[mainTabSelection] || templateHeaderRow
              };
            }
            
            // Group data rows by category for category-specific worksheets
            const groupedData = {};
            
            // Process each data row
            allDataRows.forEach(dataRow => {
              // Ensure the row has data in the category column
              if (dataRow && categoryColIndex < dataRow.length) {
                const categoryValue = String(dataRow[categoryColIndex] || "");
                
                // Create array for this category if it doesn't exist
                if (!groupedData[categoryValue]) {
                  groupedData[categoryValue] = [];
                }
                
                // Add row to the appropriate category
                groupedData[categoryValue].push(dataRow);
              }
            });
            
            // Process each category group and its target worksheets
            Object.keys(groupedData).forEach(categoryValue => {
              const targetWorksheets = categoryWorksheetMappings[categoryValue] || [];
              
              if (targetWorksheets.length === 0) {
                console.warn(`No target worksheets defined for category: ${categoryValue}`);
                return;
              }
              
              const rows = groupedData[categoryValue];
              
              // For each target worksheet, create a separate mapping
              targetWorksheets.forEach(targetWorksheet => {
                // Skip main tab here if we already processed it - avoiding duplicate mapping
                if (includeMainTab && targetWorksheet === mainTabSelection) {
                  return;
                }
                
                // IMPORTANT: Always get the specific headers for this particular worksheet
                // This ensures we never share headers across worksheets, only mappings
                const templateHeadersArr = worksheetHeadersMap[targetWorksheet] || templateHeaders;
                
                const mappedRows = [templateHeadersArr]; // Start with this worksheet's unique headers
                
                // Get the mappings for this category/worksheet
                let currentMappings;
                
                // Use worksheet-specific mappings if available
                if (worksheetMappings[categoryValue] && worksheetMappings[categoryValue][targetWorksheet]) {
                  currentMappings = worksheetMappings[categoryValue][targetWorksheet];
                } else {
                  // Fall back to shared mappings
                  currentMappings = mappings;
                }
                
                // Map each data row
                rows.forEach(dataRow => {
                  const mappedRow = new Array(templateHeadersArr.length).fill('');
                  
                  // For each template header in this specific worksheet
                  templateHeadersArr.forEach((templateHeader, templateColIndex) => {
                    if (!templateHeader) return;
                    
                    // Look up the data column mapped to this template header
                    const dataHeader = currentMappings[templateHeader];
                    
                    if (dataHeader) {
                      // Find the index of this header in the data
                      const dataColIndex = data.headers.indexOf(dataHeader);
                      
                      if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                        mappedRow[templateColIndex] = dataRow[dataColIndex];
                      }
                    }
                  });
                  
                  mappedRows.push(mappedRow);
                });
                
                // Unique key for category + worksheet combination
                const mappingKey = `${categoryValue}:${targetWorksheet}`;
                
                // Store mapped data for this category-worksheet combination
                mappedDataByKey[mappingKey] = {
                  category: categoryValue,
                  worksheet: targetWorksheet,
                  data: mappedRows,
                  // Store info about headers and requirements for validation
                  headers: templateHeadersArr, // These are specific to this worksheet
                  requirements: worksheetRequirementsMap[targetWorksheet] || fieldRequirements,
                  // Store the header row information for the target worksheet
                  headerRow: worksheetHeaderRows[targetWorksheet] || templateHeaderRow
                };
              });
            });
            
            // Set the mapped data with all category mappings
            setMappedData(mappedDataByKey);
          } else {
            // Standard single-worksheet mapping
            const mappedRows = [];
            
            // Get headers from selected worksheets only
            const selectedSheets = Object.keys(selectedTemplateSheets).filter(sheet => selectedTemplateSheets[sheet]);
            
            // If no worksheets are selected, use the default template headers
            let templateHeadersToUse = [];
            if (selectedSheets.length > 0) {
              // Use the first selected sheet as the default
              const firstSelectedSheet = selectedSheets[0];
              templateHeadersToUse = worksheetHeadersMap[firstSelectedSheet] || [];
            } else {
              templateHeadersToUse = templateHeaders;
            }
            
            // Start with a row containing template headers
            mappedRows.push(templateHeadersToUse);
            
            // For each data row (skip header)
            for (let i = 1; i < data.data.length; i++) {
              const dataRow = data.data[i];
              const mappedRow = new Array(templateHeadersToUse.length).fill('');
              
              // For each template header
              templateHeadersToUse.forEach((templateHeader, templateColIndex) => {
                if (!templateHeader) return;
                
                const dataHeader = mappings[templateHeader];
                
                if (dataHeader) {
                  // Find the index of this header in the data
                  const dataColIndex = data.headers.indexOf(dataHeader);
                  
                  if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                    mappedRow[templateColIndex] = dataRow[dataColIndex];
                  }
                }
              });
              
              mappedRows.push(mappedRow);
            }
            
            setMappedData(mappedRows);
          }
          
          setStep(3);
        } catch (error) {
          console.error('Error mapping data:', error);
          setDebugInfo(`Error mapping data: ${error.message}`);
        } finally {
          setIsLoading(prev => ({ ...prev, mapping: false }));
        }
      };

      // Update export options
      const handleExportOptionChange = (option, value) => {
        setExportOptions(prev => ({
          ...prev,
          [option]: value
        }));
      };

      // Handle data row offset change
      const handleDataRowOffsetChange = (e) => {
        const value = parseInt(e.target.value) || 0;
        // Ensure offset is at least 0
        const newOffset = Math.max(0, value);
        setExportOptions(prev => ({
          ...prev,
          dataRowOffset: newOffset
        }));
      };

      // Export data directly into a copy of the original template
      const exportExcel = () => {
        if (!mappedData || !template || !templateFile) return;
        
        setIsLoading(prev => ({ ...prev, export: true }));
        
        try {
          // Read the template file again to get a fresh copy
          const reader = new FileReader();
          
          reader.onload = (evt) => {
            try {
              const binaryString = evt.target.result;
              
              // Create a new workbook from the template file with select options for better compatibility
              const readOpts = { 
                type: 'binary', 
                cellFormula: true, 
                cellDates: true,
                cellNF: true
              };
              
              // Only add certain options if they are enabled
              if (exportOptions.preserveStyles) {
                readOpts.cellStyles = true;
              }
              
              if (exportOptions.includeMacros) {
                readOpts.bookVBA = true;
                readOpts.bookFiles = true;
              }
              
              const workbook = XLSX.read(binaryString, readOpts);
              
              // IMPORTANT: Store the source styles, formats, and template info to be referenced later
              const templateInfo = {};
              
              // Process all worksheets to build a comprehensive style library
              workbook.SheetNames.forEach(sheetName => {
                const worksheet = workbook.Sheets[sheetName];
                
                templateInfo[sheetName] = {
                  merges: worksheet['!merges'] ? [...worksheet['!merges']] : [],
                  styles: {},
                  formats: {},
                  formulas: {},
                  validations: worksheet['!dataValidations'] ? [...worksheet['!dataValidations']] : []
                };
                
                // Extract cell styles, formats, and formulas
                Object.keys(worksheet).forEach(cellRef => {
                  if (cellRef[0] === '!') return; // Skip metadata
                  
                  const cell = worksheet[cellRef];
                  
                  // Store cell info for reference
                  if (cell) {
                    // Deep clone style objects to avoid reference issues
                    if (exportOptions.preserveStyles && cell.s) {
                      templateInfo[sheetName].styles[cellRef] = JSON.parse(JSON.stringify(cell.s));
                    }
                    
                    // Store number format
                    if (exportOptions.applyColumnFormats && cell.z) {
                      templateInfo[sheetName].formats[cellRef] = cell.z;
                    }
                    
                    // Store formulas if enabled
                    if (exportOptions.preserveFormulas && cell.f) {
                      templateInfo[sheetName].formulas[cellRef] = cell.f;
                    }
                  }
                });
              });
              
              // Function to apply styles and formatting to cells
              const applyTemplateStyles = (worksheetName, worksheet, cellRef, value, rowOffset = 0) => {
                // Create the cell if it doesn't exist
                if (!worksheet[cellRef]) {
                  worksheet[cellRef] = { v: value };
                } else {
                  worksheet[cellRef].v = value;
                }
                
                // Determine appropriate data type
                if (typeof value === 'number') {
                  worksheet[cellRef].t = 'n';
                } else if (typeof value === 'boolean') {
                  worksheet[cellRef].t = 'b';
                } else if (value instanceof Date) {
                  worksheet[cellRef].t = 'd';
                } else {
                  worksheet[cellRef].t = 's';
                }
                
                if (!templateInfo[worksheetName]) return;
                
                const decodedCell = XLSX.utils.decode_cell(cellRef);
                const colIndex = decodedCell.c;
                
                // Find column style reference - look for the same column in the template
                // First try header row, then template data rows
                const colLetter = XLSX.utils.encode_col(colIndex);
                
                // Try to find style from the template using the same column
                if (exportOptions.preserveStyles) {
                  // First look for exact cell style
                  if (templateInfo[worksheetName].styles[cellRef]) {
                    worksheet[cellRef].s = JSON.parse(JSON.stringify(templateInfo[worksheetName].styles[cellRef]));
                  } else {
                    // Look for any cell style in the same column (for new rows)
                    // Check sample cells from the template in the same column
                    let foundStyle = false;
                    
                    // Try header row first
                    const headerCellRef = colLetter + '1';
                    if (templateInfo[worksheetName].styles[headerCellRef]) {
                      worksheet[cellRef].s = JSON.parse(JSON.stringify(templateInfo[worksheetName].styles[headerCellRef]));
                      foundStyle = true;
                    }
                    
                    // If no style found yet, look for any data row with a style in this column
                    if (!foundStyle) {
                      for (let r = 2; r < 10; r++) { // Check first few rows
                        const dataRowCellRef = colLetter + r;
                        if (templateInfo[worksheetName].styles[dataRowCellRef]) {
                          worksheet[cellRef].s = JSON.parse(JSON.stringify(templateInfo[worksheetName].styles[dataRowCellRef]));
                          break;
                        }
                      }
                    }
                  }
                }
                
                // Apply number format if enabled
                if (exportOptions.applyColumnFormats) {
                  // First look for exact cell format
                  if (templateInfo[worksheetName].formats[cellRef]) {
                    worksheet[cellRef].z = templateInfo[worksheetName].formats[cellRef];
                  } else {
                    // Look for any cell format in the same column
                    for (const templateCellRef in templateInfo[worksheetName].formats) {
                      const templateCell = XLSX.utils.decode_cell(templateCellRef);
                      if (templateCell.c === colIndex) {
                        worksheet[cellRef].z = templateInfo[worksheetName].formats[templateCellRef];
                        break;
                      }
                    }
                  }
                }
                
                // Apply formulas if enabled - adjust row references where needed
                if (exportOptions.preserveFormulas) {
                  const baseRow = decodedCell.r - rowOffset; // Calculate base row to check template formulas
                  
                  // Try to find a matching formula from the template
                  if (baseRow >= 0) {
                    const templateCellRef = XLSX.utils.encode_cell({c: colIndex, r: baseRow});
                    
                    if (templateInfo[worksheetName].formulas[templateCellRef]) {
                      let formula = templateInfo[worksheetName].formulas[templateCellRef];
                      
                      // For formulas that reference other cells, adjust row references
                      // This is a simplified approach - complex formulas might need more sophisticated adjustment
                      if (rowOffset > 0) {
                        // Replace cell references like A1, B2, etc. with adjusted row numbers
                        formula = formula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                          const newRow = parseInt(row) + rowOffset;
                          return `${col}${newRow}`;
                        });
                      }
                      
                      worksheet[cellRef].f = formula;
                    }
                  }
                }
              };

              // Function to update worksheet with mapped data while preserving all existing content
              const updateWorksheet = (worksheetName, mappedRows, headerRowIndex = 0) => {
                // Get or create the worksheet
                let worksheet = workbook.Sheets[worksheetName];
                
                if (!worksheet) {
                  console.warn(`Worksheet ${worksheetName} not found in template, creating new worksheet`);
                  worksheet = {};
                  workbook.Sheets[worksheetName] = worksheet;
                  workbook.SheetNames.push(worksheetName);
                }
                
                // Calculate start row where data should be inserted
                // With the new dataRowOffset option, we can add more rows after the header
                const dataStartRow = headerRowIndex + 1 + exportOptions.dataRowOffset; // Row after header + offset
                
                // Store original range info before modifications
                let originalRange = {s: {r: 0, c: 0}, e: {r: 0, c: 0}};
                if (worksheet['!ref']) {
                  originalRange = XLSX.utils.decode_range(worksheet['!ref']);
                }
                
                // *** KEY CHANGE: Don't clear existing data - keep it all and just overwrite specific cells ***
                
                // Now add the mapped data
                // Determine if we should preserve header rows from the template
                if (exportOptions.preserveHeaderRows) {
                  // Skip the header row from mappedRows and only copy data rows
                  // Start with row after header (accounting for the offset)
                  for (let rowIndex = 1; rowIndex < mappedRows.length; rowIndex++) {
                    const dataRow = mappedRows[rowIndex];
                    const targetRowIndex = dataStartRow + (rowIndex - 1); // -1 because we skip header
                    
                    for (let colIndex = 0; colIndex < dataRow.length; colIndex++) {
                      const value = dataRow[colIndex];
                      
                      // Skip empty values to preserve template content
                      if (value === undefined || value === null || value === '') continue;
                      
                      // Calculate cell reference
                      const cellRef = XLSX.utils.encode_cell({r: targetRowIndex, c: colIndex});
                      
                      // Add cell with styles from template
                      applyTemplateStyles(worksheetName, worksheet, cellRef, value, targetRowIndex - dataStartRow);
                    }
                  }
                } else {
                  // If not preserving headers, copy both header and data rows
                  for (let rowIndex = 0; rowIndex < mappedRows.length; rowIndex++) {
                    const dataRow = mappedRows[rowIndex];
                    // For header row (rowIndex=0), put at headerRowIndex
                    // For data rows, put at dataStartRow + (rowIndex-1)
                    const targetRowIndex = rowIndex === 0 ? headerRowIndex : dataStartRow + (rowIndex - 1);
                    
                    for (let colIndex = 0; colIndex < dataRow.length; colIndex++) {
                      const value = dataRow[colIndex];
                      
                      // Skip empty values to preserve template content
                      if (value === undefined || value === null || value === '') continue;
                      
                      // Calculate cell reference
                      const cellRef = XLSX.utils.encode_cell({r: targetRowIndex, c: colIndex});
                      
                      // Add cell with styles from template
                      applyTemplateStyles(worksheetName, worksheet, cellRef, value, 
                                         rowIndex === 0 ? 0 : targetRowIndex - dataStartRow);
                    }
                  }
                }
                
                // Update the range to include all the data if needed
                const lastDataRow = dataStartRow + mappedRows.length - 2; // -2 to account for header skip
                const lastDataCol = mappedRows[0].length - 1;
                
                // Calculate the new range, preserving the original range if it's larger
                const newRange = {
                  s: {
                    r: Math.min(originalRange.s.r, 0),
                    c: Math.min(originalRange.s.c, 0)
                  },
                  e: {
                    r: Math.max(originalRange.e.r, lastDataRow),
                    c: Math.max(originalRange.e.c, lastDataCol)
                  }
                };
                
                worksheet['!ref'] = XLSX.utils.encode_range(newRange);
                
                // Preserve the original merged cells
                if (exportOptions.preserveStyles && templateInfo[worksheetName] && templateInfo[worksheetName].merges) {
                  worksheet['!merges'] = templateInfo[worksheetName].merges;
                }
                
                // Preserve data validations if enabled
                if (exportOptions.preserveValidation && templateInfo[worksheetName] && templateInfo[worksheetName].validations) {
                  worksheet['!dataValidations'] = templateInfo[worksheetName].validations;
                }
              };
              
              // Process all mapped data
              if (enableMultiTabMapping) {
                // Multi-tab export
                Object.keys(mappedData).forEach(mappingKey => {
                  const { worksheet: worksheetName, data: mappedRows, headerRow = templateHeaderRow } = mappedData[mappingKey];
                  
                  // Update the worksheet with this data
                  updateWorksheet(worksheetName, mappedRows, headerRow - 1); // Convert to 0-based
                });
              } else {
                // Only update worksheets that are selected
                const selectedSheets = Object.keys(selectedTemplateSheets).filter(sheet => selectedTemplateSheets[sheet]);
                
                if (selectedSheets.length > 0) {
                  // Use the first selected sheet as the target
                  const targetWorksheet = selectedSheets[0];
                  const headerRow = worksheetHeaderRows[targetWorksheet] || templateHeaderRow;
                  updateWorksheet(targetWorksheet, mappedData, headerRow - 1); // Convert to 0-based
                } else {
                  // Fall back to the main tab if it's set, or the first available worksheet
                  const targetWorksheet = mainTabSelection || templateSheets[0];
                  updateWorksheet(targetWorksheet, mappedData, templateHeaderRow - 1); // Convert to 0-based
                }
              }
              
              // Clean up options to minimize compatibility issues
              const writeOpts = {
                bookType: 'xlsx',
                type: 'binary'
              };
              
              // Generate a filename based on the template
              const filename = templateFile.name.replace(/\.[^/.]+$/, '') + '_filled.xlsx';
              
              // Write the workbook to a file
              const wbout = XLSX.write(workbook, writeOpts);
              
              // Convert binary string to ArrayBuffer for more reliable download
              const buf = new ArrayBuffer(wbout.length);
              const view = new Uint8Array(buf);
              for (let i = 0; i < wbout.length; i++) {
                view[i] = wbout.charCodeAt(i) & 0xFF;
              }
              
              // Create Blob and download
              const blob = new Blob([buf], {type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = filename;
              a.click();
              
              // Clean up
              setTimeout(() => {
                URL.revokeObjectURL(url);
              }, 100);
              
              alert("Export complete! The file will download with all template content preserved.");
            } catch (error) {
              console.error('Error processing template for export:', error);
              setDebugInfo(`Error exporting: ${error.message}`);
              alert(`Error during export: ${error.message}`);
            } finally {
              setIsLoading(prev => ({ ...prev, export: false }));
            }
          };
          
          reader.onerror = () => {
            console.error('Error reading template file for export');
            setIsLoading(prev => ({ ...prev, export: false }));
          };
          
          reader.readAsBinaryString(templateFile);
        } catch (error) {
          console.error('Error exporting Excel file:', error);
          setIsLoading(prev => ({ ...prev, export: false }));
        }
      };

      // Continue to mapping step
      const proceedToMapping = () => {
        if (template && data) {
          // If no worksheets are selected, select the first one by default
          const selectedSheets = Object.keys(selectedTemplateSheets).filter(sheet => selectedTemplateSheets[sheet]);
          if (selectedSheets.length === 0 && templateSheets.length > 0) {
            setSelectedTemplateSheets({
              [templateSheets[0]]: true
            });
          }
          
          // Update template headers based on selected worksheet
          if (selectedSheets.length > 0) {
            setTemplateHeaders(worksheetHeadersMap[selectedSheets[0]] || []);
            setFieldRequirements(worksheetRequirementsMap[selectedSheets[0]] || {});
            setTemplateHeaderNotes(worksheetNotesMap[selectedSheets[0]] || {});
          }
          
          setStep(2);
        }
      };

      // Toggle requirement row availability
      const toggleRequirementRow = (e) => {
        setRequirementRowAvailable(e.target.checked);
      };
      
      // Toggle multi-tab mapping
      const toggleMultiTabMapping = (e) => {
        const enabled = e.target.checked;
        setEnableMultiTabMapping(enabled);
        
        if (!enabled) {
          setCategoryColumn('');
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setWorksheetSuggestions({});
          setActiveTab(null);
          setActiveWorksheet(null);
          setWorksheetMappings({});
        }
      };
      
      // Toggle format preservation
      const toggleFormatPreservation = (e) => {
        setPreserveFormatting(e.target.checked);
      };

      // Helper function to check if a header has notes
      const headerHasNotes = (header, sheetName = null) => {
        if (sheetName && worksheetNotesMap[sheetName]) {
          return worksheetNotesMap[sheetName][header] && worksheetNotesMap[sheetName][header].trim() !== '';
        }
        
        return templateHeaderNotes[header] && templateHeaderNotes[header].trim() !== '';
      };

      // Helper to get the header note text for a specific header
      const getHeaderNote = (header, sheetName = null) => {
        if (sheetName && worksheetNotesMap[sheetName]) {
          return worksheetNotesMap[sheetName][header] || '';
        }
        
        return templateHeaderNotes[header] || '';
      };

      // Helper to get the requirement for a specific header
      const getHeaderRequirement = (header, sheetName = null) => {
        if (sheetName && worksheetRequirementsMap[sheetName]) {
          return worksheetRequirementsMap[sheetName][header] || 'Optional';
        }
        
        return fieldRequirements[header] || 'Optional';
      };

      // Dynamically check if any notes are available
      const hasAnyNotes = Object.values(templateHeaderNotes).some(note => note && note.trim() !== '');
      
      // Check if any data descriptions are available
      const hasAnyDataDescriptions = Object.values(dataHeaderDescriptions).some(
        desc => desc && desc.trim() !== ''
      );

      // Function to determine if a note needs the "large" class
      const isLargeNote = (note) => {
        return note && note.length > 150;
      };
      
      // Get confidence level label based on score
      const getConfidenceLevel = (score) => {
        if (score >= 0.8) return 'High';
        if (score >= 0.6) return 'Medium';
        return 'Low';
      };
      
      // Get confidence level class based on score
      const getConfidenceClass = (score) => {
        if (score >= 0.8) return 'confidence-high';
        if (score >= 0.6) return 'confidence-medium';
        return 'confidence-low';
      };
      
      // Get the number of unmapped required fields for a specific worksheet
      const getUnmappedRequiredFieldsCount = (category = null, worksheet = null) => {
        // Get the mappings to check
        let currentMappings;
        
        if (enableMultiTabMapping && category && worksheet && 
            worksheetMappings[category] && worksheetMappings[category][worksheet]) {
          currentMappings = worksheetMappings[category][worksheet];
        } else {
          currentMappings = mappings;
        }
        
        // Get the headers and requirements for this worksheet
        let headers, requirements;
        
        if (worksheet && worksheetHeadersMap[worksheet]) {
          headers = worksheetHeadersMap[worksheet];
          requirements = worksheetRequirementsMap[worksheet] || {};
        } else {
          headers = templateHeaders;
          requirements = fieldRequirements;
        }
        
        return headers.filter(header => {
          return (
            header && 
            requirements[header] === 'Required' && 
            (!currentMappings[header] || currentMappings[header] === '')
          );
        }).length;
      };

      // Get current mappings based on active category and worksheet
      const getCurrentMappings = () => {
        if (enableMultiTabMapping && activeTab && activeWorksheet && 
            worksheetMappings[activeTab] && worksheetMappings[activeTab][activeWorksheet]) {
          return worksheetMappings[activeTab][activeWorksheet];
        }
        return mappings;
      };

      // Calculate total columns across all worksheets
      const getTotalTemplateColumns = () => {
        let total = 0;
        Object.values(worksheetHeadersMap).forEach(headers => {
          total += headers.filter(Boolean).length;
        });
        return total;
      };

      // Get total product fields detected
      const getTotalProductFields = () => {
        return Object.values(productInfoDetected).flat().length;
      };

      // Get product-related worksheets count
      const getProductWorksheetCount = () => {
        return Object.values(worksheetStatus).filter(status => status.isProductSheet).length;
      };
      
      // Get all selected template worksheet names
      const getSelectedTemplateWorksheets = () => {
        return Object.keys(selectedTemplateSheets).filter(sheet => selectedTemplateSheets[sheet]);
      };
      
      // Get current configuration for presets
      const getCurrentConfig = () => {
        return {
          // Template settings
          selectedTemplateSheets,
          worksheetHeaderRows,
          worksheetRequirementRows,
          requirementRowAvailable,
          
          // Mapping settings
          mappings,
          
          // Multi-tab mapping settings
          enableMultiTabMapping,
          categoryColumn,
          includeMainTab,
          mainTabSelection,
          categoryWorksheetMappings,
          worksheetMappings
        };
      };

      return (
        <div className={`min-h-screen transition-colors duration-200 ${isDarkMode ? 'dark bg-gray-900' : 'bg-gray-50'}`}>
          <div className="p-4 md:p-6 max-w-5xl mx-auto">
            <div className="flex justify-between items-center mb-6">
              <h1 className="text-2xl md:text-3xl font-bold text-center dark:text-white flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-8 h-8 mr-2 text-excel-500">
                  <path d="M18.375 2.25c-1.035 0-1.875.84-1.875 1.875v15.75c0 1.035.84 1.875 1.875 1.875h.75c1.035 0 1.875-.84 1.875-1.875V4.125c0-1.036-.84-1.875-1.875-1.875h-.75zM9.75 8.625c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v11.25c0 1.035-.84 1.875-1.875 1.875h-.75a1.875 1.875 0 01-1.875-1.875V8.625zM3 13.125c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v6.75c0 1.035-.84 1.875-1.875 1.875h-.75A1.875 1.875 0 013 19.875v-6.75z" />
                </svg>
                Excel Mapper
              </h1>
              
              {/* Preset Manager */}
              <PresetManager 
                presets={presets}
                savePreset={savePreset}
                loadPreset={loadPreset}
                deletePreset={deletePreset}
                currentConfig={getCurrentConfig()}
              />
            </div>
            
            <div className="mb-8 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm dark:text-gray-200">
              <h2 className="text-lg md:text-xl font-semibold mb-2 text-excel-600 dark:text-excel-400">How it works:</h2>
              <ol className="list-decimal pl-6">
                <li className="mb-1">Upload your Excel template file and configure worksheet settings</li>
                <li className="mb-1">Upload your data Excel file and select the worksheet and header row</li>
                <li className="mb-1">Review and adjust the column mappings to desired template destinations</li>
                <li className="mb-1">Generate your mapped Excel file with all formatting preserved</li>
              </ol>
            </div>
            
            <div className="flex mb-6 overflow-x-auto pb-1">
              <div className={`px-4 py-2 rounded-t-lg mr-2 transition-colors duration-150 ${step === 1 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 1: Upload Files
              </div>
              <div className={`px-4 py-2 rounded-t-lg mr-2 transition-colors duration-150 ${step === 2 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 2: Map Columns
              </div>
              <div className={`px-4 py-2 rounded-t-lg transition-colors duration-150 ${step === 3 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 3: Export
              </div>
            </div>
            
            {step === 1 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <div className="mb-8 border-b pb-6 dark:border-gray-700">
                  <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">1. Vendor Template</h2>
                  
                  <div className="mb-4">
                    <label className="block mb-2 text-gray-700 dark:text-gray-300">Upload Template File</label>
                    <div className="relative">
                      <input
                        type="file"
                        accept=".xlsx, .xls"
                        onChange={(e) => handleFileUpload(e, 'template')}
                        className="block w-full text-base text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded p-2 
                          file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold
                          file:bg-excel-50 file:text-excel-700 dark:file:bg-gray-700 dark:file:text-gray-300
                          hover:file:bg-excel-100 dark:hover:file:bg-gray-600"
                      />
                      {isLoading.template && (
                        <div className="absolute inset-0 bg-white/70 dark:bg-gray-800/70 flex items-center justify-center">
                          <svg className="animate-spin h-5 w-5 text-excel-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {templateSheets.length > 0 && (
                    <>
                      <div className="mb-4 p-4 border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/20 rounded-md">
                        <h3 className="font-medium text-blue-800 dark:text-blue-300 mb-2">Template Configuration</h3>
                        
                        <div className="flex items-center mb-3 space-x-4">
                          <div className="flex items-center">
                            <input
                              type="checkbox"
                              id="preserveFormatting"
                              checked={preserveFormatting}
                              onChange={toggleFormatPreservation}
                              className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                            />
                            <label htmlFor="preserveFormatting" className="text-gray-700 dark:text-gray-300 font-medium">
                              Preserve template formatting
                            </label>
                          </div>
                          
                          <div className="flex items-center">
                            <input
                              type="checkbox"
                              id="detectProductInfo"
                              checked={detectProductInfo}
                              onChange={toggleProductInfoDetection}
                              className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                            />
                            <label htmlFor="detectProductInfo" className="text-gray-700 dark:text-gray-300 font-medium">
                              Auto-detect product fields
                            </label>
                          </div>
                          
                          <div className="flex items-center">
                            <input
                              type="checkbox"
                              id="requirementRow"
                              checked={requirementRowAvailable}
                              onChange={toggleRequirementRow}
                              className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                            />
                            <label htmlFor="requirementRow" className="text-gray-700 dark:text-gray-300 font-medium">
                              Has required fields row
                            </label>
                          </div>
                        </div>
                        
                        <div className="mt-4">
                          <div className="flex justify-between items-center mb-2">
                            <h4 className="font-medium text-blue-800 dark:text-blue-300">Select Worksheets & Configure Headers</h4>
                            <button 
                              className="refresh-btn refresh-btn-primary text-sm"
                              onClick={refreshWorksheetHeaders}
                              disabled={isLoading.refreshing}
                            >
                              {isLoading.refreshing ? (
                                <span className="flex items-center">
                                  <svg className="animate-spin mr-1 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                  </svg>
                                  Refreshing...
                                </span>
                              ) : (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                  </svg>
                                  Refresh Headers
                                </>
                              )}
                            </button>
                          </div>
                          
                          <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                            Select worksheets to include and configure their header rows. Click Refresh to update headers.
                          </p>
                          
                          <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md p-3">
                            <div className="mb-2 flex justify-between">
                              <button 
                                className="text-sm text-blue-600 dark:text-blue-400 hover:underline"
                                onClick={() => {
                                  const allSelected = {};
                                  templateSheets.forEach(sheet => {
                                    allSelected[sheet] = true;
                                  });
                                  setSelectedTemplateSheets(allSelected);
                                }}
                              >
                                Select All
                              </button>
                              <button 
                                className="text-sm text-blue-600 dark:text-blue-400 hover:underline"
                                onClick={() => setSelectedTemplateSheets({})}
                              >
                                Clear All
                              </button>
                            </div>
                            
                            <div className="max-h-80 overflow-y-auto border-t border-gray-200 dark:border-gray-700 pt-2">
                              <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                <thead className="bg-gray-50 dark:bg-gray-700">
                                  <tr>
                                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                      Select
                                    </th>
                                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                      Worksheet
                                    </th>
                                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                      Header Row
                                    </th>
                                    {requirementRowAvailable && (
                                      <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                        Required Fields Row
                                      </th>
                                    )}
                                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                                      Status
                                    </th>
                                  </tr>
                                </thead>
                                <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                                  {templateSheets.map((sheet, index) => {
                                    const status = worksheetStatus[sheet] || {};
                                    const headerCount = (worksheetHeadersMap[sheet] || []).filter(Boolean).length;
                                    const sheetData = worksheetDataMap[sheet] || [];
                                    
                                    // Get headers based on current row settings (for preview)
                                    const headerRowIndex = Math.max(0, (worksheetHeaderRows[sheet] || 1) - 1);
                                    const previewHeaders = sheetData.length > headerRowIndex ? 
                                      sheetData[headerRowIndex] || [] : [];
                                    
                                    return (
                                      <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : ''}>
                                        <td className="px-3 py-2 whitespace-nowrap">
                                          <input
                                            type="checkbox"
                                            checked={!!selectedTemplateSheets[sheet]}
                                            onChange={(e) => {
                                              setSelectedTemplateSheets(prev => ({
                                                ...prev,
                                                [sheet]: e.target.checked
                                              }));
                                            }}
                                            className="h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                                          />
                                        </td>
                                        <td className="px-3 py-2 whitespace-nowrap font-medium text-gray-700 dark:text-gray-300">
                                          {sheet}
                                        </td>
                                        <td className="px-3 py-2 whitespace-nowrap">
                                          <input
                                            type="number"
                                            min="1"
                                            value={worksheetHeaderRows[sheet] || 1}
                                            onChange={(e) => {
                                              const value = Math.max(1, parseInt(e.target.value) || 1);
                                              setWorksheetHeaderRows(prev => ({
                                                ...prev,
                                                [sheet]: value
                                              }));
                                            }}
                                            className="w-16 p-1 text-sm border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                          />
                                        </td>
                                        {requirementRowAvailable && (
                                          <td className="px-3 py-2 whitespace-nowrap">
                                            <input
                                              type="number"
                                              min="1"
                                              value={worksheetRequirementRows[sheet] || 2}
                                              onChange={(e) => {
                                                const value = Math.max(1, parseInt(e.target.value) || 1);
                                                setWorksheetRequirementRows(prev => ({
                                                  ...prev,
                                                  [sheet]: value
                                                }));
                                              }}
                                              className="w-16 p-1 text-sm border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                            />
                                          </td>
                                        )}
                                        <td className="px-3 py-2">
                                          <div className="flex flex-col">
                                            <span className={`status-indicator ${headerCount > 0 ? 'status-success' : 'status-error'} text-xs mb-1`}>
                                              {headerCount > 0 ? `${headerCount} headers` : 'No headers'}
                                            </span>
                                            
                                            <HeaderPreview 
                                              headers={previewHeaders || []}
                                              label={`Row ${worksheetHeaderRows[sheet] || 1} Preview`}
                                            />
                                          </div>
                                        </td>
                                      </tr>
                                    );
                                  })}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        </div>
                      </div>

                      {isLoading.headerLoad && (
                        <div className="loader-container py-8">
                          <div className="loader-spinner"></div>
                          <p className="text-gray-600 dark:text-gray-300">
                            Analyzing worksheets and loading headers...
                          </p>
                        </div>
                      )}
                      
                      {preserveFormatting && (
                        <div className="format-preservation-notice mb-4">
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-3 flex-shrink-0 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                          </svg>
                          <div>
                            <h4 className="font-medium text-blue-800 dark:text-blue-300 mb-1">Template formatting will be preserved</h4>
                            <div className="text-blue-700 dark:text-blue-400 text-sm">
                              <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 mt-2">
                                <div>
                                  <div className="format-item">
                                    <span className="format-icon">✓</span> Colors, fonts, and borders
                                  </div>
                                  <div className="format-item">
                                    <span className="format-icon">✓</span> Formulas and calculations
                                  </div>
                                </div>
                                <div>
                                  <div className="format-item">
                                    <span className="format-icon">✓</span> Data validation rules
                                  </div>
                                  <div className="format-item">
                                    <span className="format-icon">✓</span> Conditional formatting
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      )}
                    </>
                  )}
                </div>
                
                <div className="mb-6">
                  <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">2. Manufacturer Data</h2>
                  
                  <div className="mb-4">
                    <label className="block mb-2 text-gray-700 dark:text-gray-300">Upload Data File</label>
                    <div className="relative">
                      <input
                        type="file"
                        accept=".xlsx, .xls"
                        onChange={(e) => handleFileUpload(e, 'data')}
                        className="block w-full text-base text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded p-2 
                          file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold
                          file:bg-excel-50 file:text-excel-700 dark:file:bg-gray-700 dark:file:text-gray-300
                          hover:file:bg-excel-100 dark:hover:file:bg-gray-600"
                      />
                      {isLoading.data && (
                        <div className="absolute inset-0 bg-white/70 dark:bg-gray-800/70 flex items-center justify-center">
                          <svg className="animate-spin h-5 w-5 text-excel-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {dataSheets.length > 0 && (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Select Worksheet</label>
                        <select
                          value={selectedDataSheet}
                          onChange={(e) => setSelectedDataSheet(e.target.value)}
                          className="block w-full p-2 text-base border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        >
                          {dataSheets.map((sheet, index) => (
                            <option key={index} value={sheet}>{sheet}</option>
                          ))}
                        </select>
                      </div>
                      
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Header Row Number</label>
                        <input
                          type="number"
                          min="1"
                          value={dataHeaderRow}
                          onChange={(e) => setDataHeaderRow(Math.max(1, parseInt(e.target.value) || 1))}
                          className="block w-full p-2 text-base border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        />
                      </div>
                    </div>
                  )}
                  
                  {dataSheets.length > 0 && (
                    <button
                      onClick={processDataSheet}
                      disabled={isLoading.data}
                      className={`px-4 py-2 rounded transition-colors ${
                        isLoading.data 
                          ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                          : 'bg-excel-500 hover:bg-excel-600 text-white'
                      }`}
                    >
                      {isLoading.data ? (
                        <span className="flex items-center">
                          <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                          Processing...
                        </span>
                      ) : 'Load Data Headers'}
                    </button>
                  )}
                  
                  {dataHeaders.length > 0 && (
                    <div className="mt-4">
                      <p className="text-excel-600 dark:text-excel-400">✓ Data loaded with {dataHeaders.filter(Boolean).length} columns</p>
                      <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 max-h-24 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded p-2">
                        Headers: {dataHeaders.filter(Boolean).join(', ')}
                      </div>
                    </div>
                  )}
                </div>
                
                <button
                  disabled={!template || !data || Object.keys(selectedTemplateSheets).length === 0}
                  onClick={proceedToMapping}
                  className={`w-full md:w-auto px-4 py-2 rounded transition-colors ${
                    !template || !data || Object.keys(selectedTemplateSheets).length === 0
                      ? 'bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed' 
                      : 'bg-excel-500 text-white hover:bg-excel-600'
                  }`}
                >
                  Continue to Column Mapping
                </button>
              </div>
            )}
            
            {step === 2 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">Map Template Columns to Data Columns</h2>
                
                {/* Show selected worksheets info */}
                <div className="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-md">
                  <h3 className="font-medium text-blue-800 dark:text-blue-300 mb-2">Selected Template Worksheets</h3>
                  <div className="flex flex-wrap gap-2">
                    {getSelectedTemplateWorksheets().map((sheet, i) => (
                      <div key={i} className="px-2 py-1 bg-blue-100 dark:bg-blue-800/30 text-blue-700 dark:text-blue-300 rounded">
                        {sheet}
                      </div>
                    ))}
                    {getSelectedTemplateWorksheets().length === 0 && (
                      <p className="text-sm text-blue-600 dark:text-blue-400">
                        No worksheets selected. Please go back and select at least one worksheet.
                      </p>
                    )}
                  </div>
                </div>
                
                <p className="mb-4 text-gray-600 dark:text-gray-300">
                  We've automatically matched columns based on name similarity. Please review and adjust as needed.
                  <span className="text-red-500 dark:text-red-400 ml-2 font-medium">Required fields must be mapped.</span>
                </p>
                
                {/* Multi-tab mapping option */}
                <div className="mb-6 border dark:border-gray-700 rounded-lg p-4 bg-gray-50 dark:bg-gray-900/50">
                  <div className="flex items-center mb-3">
                    <input
                      type="checkbox"
                      id="enableMultiTabMapping"
                      checked={enableMultiTabMapping}
                      onChange={toggleMultiTabMapping}
                      className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                    />
                    <label htmlFor="enableMultiTabMapping" className="text-gray-700 dark:text-gray-300 font-medium">
                      Enable Category-Based Multi-Tab Mapping
                    </label>
                  </div>
                  
                  {enableMultiTabMapping && (
                    <div className="pl-6">
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                        Map your data to different worksheets in the template based on worksheet categories.
                        Each template category can have its own column mappings.
                      </p>
                      
                      <div className="mb-4">
                        <div className="flex items-center mb-2">
                          <input
                            type="checkbox"
                            id="includeMainTab"
                            checked={includeMainTab}
                            onChange={toggleIncludeMainTab}
                            className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                          />
                          <label htmlFor="includeMainTab" className="text-gray-700 dark:text-gray-300 font-medium">
                            Include Main Tab for all categories
                          </label>
                        </div>
                        
                        {includeMainTab && (
                          <div className="ml-6 mt-2">
                            <label className="block mb-1 text-gray-700 dark:text-gray-300">Select Main Tab</label>
                            <select
                              value={mainTabSelection}
                              onChange={(e) => handleMainTabChange(e.target.value)}
                              className="block w-full p-2 text-base border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                            >
                              {getSelectedTemplateWorksheets().map((sheet, index) => (
                                <option key={index} value={sheet}>{sheet}</option>
                              ))}
                            </select>
                            <p className="text-xs mt-1 text-gray-500 dark:text-gray-400">
                              Data from all categories will be copied to this tab in addition to category-specific tabs
                            </p>
                          </div>
                        )}
                      </div>
                      
                      <div className="mb-3">
                        <div className="flex items-center justify-between mb-2">
                          <label className="text-gray-700 dark:text-gray-300">Template Categories</label>
                          <span className="text-sm text-gray-500 dark:text-gray-400">
                            {getSelectedTemplateWorksheets().length} worksheets available
                          </span>
                        </div>
                        
                        <div className="border dark:border-gray-700 rounded overflow-hidden">
                          <div className="overflow-y-auto max-h-96">
                            <div className="p-4 divide-y dark:divide-gray-700 space-y-4">
                              {getSelectedTemplateWorksheets().map((sheet, index) => (
                                <div key={index} className="pt-4 first:pt-0">
                                  <div className="flex justify-between items-center mb-2">
                                    <span className="font-medium text-gray-800 dark:text-gray-200">{sheet}</span>
                                    <span className={`badge ${sheet === mainTabSelection ? 'worksheet-badge' : ''} ml-2 text-xs`}>
                                      {sheet === mainTabSelection ? "Main Tab" : "Template Worksheet"}
                                    </span>
                                  </div>
                                  
                                  <div className="mb-2">
                                    <label className="block mb-1 text-gray-700 dark:text-gray-300 text-sm">
                                      Map data categories using column:
                                    </label>
                                    <CustomSelect
                                      options={[
                                        { value: '', label: '-- Select a data column --' },
                                        ...dataHeaders.filter(Boolean).map(header => ({
                                          value: header,
                                          label: header
                                        }))
                                      ]}
                                      value={categoryColumn || ''}
                                      onChange={(value) => handleCategoryColumnChange(value)}
                                      columnSamples={columnSamples}
                                      columnDescriptions={dataHeaderDescriptions}
                                    />
                                  </div>
                                  
                                  {categoryColumn && categoryValues && categoryValues.length > 0 && (
                                    <div className="mt-3">
                                      <label className="block mb-1 text-sm text-gray-700 dark:text-gray-300">
                                        Data categories that will map to this worksheet:
                                      </label>
                                      <div className="flex flex-wrap gap-2 mt-1">
                                        {categoryValues.map((value, valueIndex) => {
                                          // Check if this category is mapped to this worksheet
                                          const isMapped = categoryWorksheetMappings[value]?.includes(sheet);
                                          return (
                                            <div 
                                              key={valueIndex}
                                              className={`px-2 py-1 text-sm rounded-full cursor-pointer border
                                                ${isMapped 
                                                  ? 'bg-excel-100 border-excel-400 text-excel-700 dark:bg-excel-900/20 dark:border-excel-600 dark:text-excel-400' 
                                                  : 'bg-gray-100 border-gray-300 text-gray-600 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-300'
                                                }`}
                                              onClick={() => {
                                                if (isMapped) {
                                                  removeWorksheetFromCategory(value, sheet);
                                                } else {
                                                  addWorksheetToCategory(value, sheet);
                                                }
                                              }}
                                            >
                                              {value}
                                              {isMapped && <span className="ml-1">✓</span>}
                                            </div>
                                          );
                                        })}
                                      </div>
                                    </div>
                                  )}
                                </div>
                              ))}
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      {/* Template worksheet tabs */}
                      <div className="mb-3">
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">
                          Configure Mappings For Worksheet:
                        </label>
                        <div className="tab-selector mb-3">
                          {getSelectedTemplateWorksheets().map((sheet, index) => (
                            <div
                              key={index}
                              className={`tab-item ${activeWorksheet === sheet ? 'active' : ''}`}
                              onClick={() => {
                                setActiveWorksheet(sheet);
                                // Find a category that uses this worksheet
                                const firstCategory = Object.keys(categoryWorksheetMappings).find(
                                  cat => categoryWorksheetMappings[cat]?.includes(sheet)
                                );
                                if (firstCategory) {
                                  setActiveTab(firstCategory);
                                }
                              }}
                            >
                              <div className="flex items-center">
                                <span>{sheet}</span>
                                {sheet === mainTabSelection && (
                                  <span className="badge worksheet-badge ml-2 text-xs">Main</span>
                                )}
                              </div>
                            </div>
                          ))}
                        </div>
                        
                        {/* Category tabs for the active worksheet */}
                        {activeWorksheet && categoryColumn && categoryValues && categoryValues.length > 0 && (
                          <div className="worksheet-tab-selector">
                            <div className="text-sm text-gray-500 dark:text-gray-400 mr-3 self-center">
                              Category:
                            </div>
                            {categoryValues.filter(value => 
                              categoryWorksheetMappings[value]?.includes(activeWorksheet)
                            ).map((category, catIndex) => (
                              <div
                                key={catIndex}
                                className={`worksheet-tab-item ${activeTab === category ? 'active' : ''}`}
                                onClick={() => setActiveTab(category)}
                              >
                                {category}
                              </div>
                            ))}
                            {!categoryValues.some(value => categoryWorksheetMappings[value]?.includes(activeWorksheet)) && (
                              <div className="text-sm text-gray-500 dark:text-gray-400 italic">
                                No categories mapped to this worksheet yet
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
                
                {!suggestionsReviewed && Object.keys(suggestedMappings).length > 0 && (
                  <div className="mapping-suggestion-panel mb-6 dark:bg-blue-950/20">
                    <div className="flex items-center justify-between mb-3">
                      <h3 className="font-medium text-blue-800 dark:text-blue-300">Suggested Column Mappings</h3>
                      <button 
                        onClick={acceptAllSuggestions}
                        className="px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white text-sm rounded transition-colors"
                      >
                        Accept All
                      </button>
                    </div>
                    
                    <div className="overflow-x-auto">
                      <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 text-sm rounded-md">
                        <thead className="bg-gray-50 dark:bg-gray-700">
                          <tr>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Template Column</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Suggested Data Column</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Confidence</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Action</th>
                          </tr>
                        </thead>
                        <tbody>
                          {Object.entries(suggestedMappings).map(([templateHeader, dataHeader], index) => {
                            // Get the match score for this suggestion
                            const matchScores = mappingScores[templateHeader] || [];
                            const matchInfo = matchScores.find(m => m.header === dataHeader);
                            const score = matchInfo ? matchInfo.score : 0;
                            const confidenceLevel = getConfidenceLevel(score);
                            const confidenceClass = getConfidenceClass(score);
                            
                            return (
                              <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="tooltip flex items-center">
                                    <span className="has-notes">{templateHeader}</span>
                                    {headerHasNotes(templateHeader) && (
                                      <>
                                        <span className="info-icon ml-1">i</span>
                                        <span 
                                          className={`tooltip-text ${isLargeNote(templateHeaderNotes[templateHeader]) ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: templateHeaderNotes[templateHeader] }}
                                        />
                                      </>
                                    )}
                                  </div>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="flex items-center">
                                    <span>{dataHeader}</span>
                                    {dataHeaderDescriptions[dataHeader] && (
                                      <div className="tooltip ml-1">
                                        <span className="info-icon text-xs">i</span>
                                        <span 
                                          className={`tooltip-text ${dataHeaderDescriptions[dataHeader] && dataHeaderDescriptions[dataHeader].length > 150 ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: dataHeaderDescriptions[dataHeader] }}
                                        />
                                      </div>
                                    )}
                                  </div>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <span className={`mapping-confidence ${confidenceClass}`}>
                                    {confidenceLevel}
                                  </span>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="flex space-x-2">
                                    <button
                                      onClick={() => acceptSuggestion(templateHeader)}
                                      className="px-2 py-0.5 bg-green-500 hover:bg-green-600 text-white text-sm rounded"
                                      title="Accept this mapping"
                                    >
                                      ✓
                                    </button>
                                    <button
                                      onClick={() => clearMapping(templateHeader, activeTab, activeWorksheet)}
                                      className="px-2 py-0.5 bg-red-500 hover:bg-red-600 text-white text-sm rounded"
                                      title="Reject this mapping"
                                    >
                                      ✗
                                    </button>
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </tbody>
                      </table>
                    </div>
                    
                    <div className="mt-3">
                      <button 
                        onClick={() => setSuggestionsReviewed(true)}
                        className="text-blue-600 dark:text-blue-400 text-sm hover:underline"
                      >
                        Dismiss suggestions
                      </button>
                    </div>
                  </div>
                )}
                
                <div className="mb-4 flex flex-col sm:flex-row gap-2 text-sm">
                  {hasAnyNotes && (
                    <div className="text-excel-600 dark:text-excel-400 border border-excel-200 dark:border-excel-800 bg-excel-50 dark:bg-excel-900/30 p-3 rounded flex items-start flex-1">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                      </svg>
                      <span><span className="font-medium">Tip:</span> Hover over the "i" icons next to template column names to see input guidance from the Excel template.</span>
                    </div>
                  )}
                  
                  <div className="text-blue-600 dark:text-blue-400 border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/30 p-3 rounded flex items-start flex-1">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                    </svg>
                    <span><span className="font-medium">Tip:</span> Hover over the "i" icons next to data column names to see descriptions, or hover on any cell for 1.5 seconds to see sample data.</span>
                  </div>
                </div>
                
                {enableMultiTabMapping && activeTab && activeWorksheet && (
                  <div className="py-2 px-4 bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300 mb-4 rounded-md">
                    Currently configuring mappings for:
                    <span className="font-medium ml-2">{activeTab}</span>
                    <span className="mx-2">→</span>
                    <span className="font-medium">{activeWorksheet}</span>
                    {activeWorksheet === mainTabSelection && (
                      <span className="ml-1 text-sm">(main tab)</span>
                    )}
                    <span className="ml-2 text-sm">
                      {getUnmappedRequiredFieldsCount(activeTab, activeWorksheet) > 0 && (
                        <span className="bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 px-2 py-0.5 rounded-full">
                          {getUnmappedRequiredFieldsCount(activeTab, activeWorksheet)} unmapped required
                        </span>
                      )}
                    </span>
                  </div>
                )}
                
                <div className="overflow-x-auto mb-6">
                  <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                    <thead className="bg-gray-50 dark:bg-gray-700">
                      <tr>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Template Column</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Requirement</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Data Column</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left w-16">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {(() => {
                        // Get the appropriate headers based on the context
                        let headers, requirements;
                        
                        if (enableMultiTabMapping && activeWorksheet && worksheetHeadersMap[activeWorksheet]) {
                          headers = worksheetHeadersMap[activeWorksheet];
                          requirements = worksheetRequirementsMap[activeWorksheet] || {};
                        } else if (getSelectedTemplateWorksheets().length > 0) {
                          // Use the first selected worksheet for single-tab mapping
                          const firstSelectedSheet = getSelectedTemplateWorksheets()[0];
                          headers = worksheetHeadersMap[firstSelectedSheet] || [];
                          requirements = worksheetRequirementsMap[firstSelectedSheet] || {};
                        } else {
                          headers = templateHeaders;
                          requirements = fieldRequirements;
                        }
                        
                        // Get the current mappings
                        const currentMappings = getCurrentMappings();
                        
                        return headers.filter(Boolean).map((header, index) => (
                          <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              <div className="tooltip flex items-center">
                                <span className="has-notes">{header}</span>
                                {headerHasNotes(header, activeWorksheet) && (
                                  <>
                                    <span className="info-icon ml-1">i</span>
                                    <span 
                                      className={`tooltip-text ${isLargeNote(getHeaderNote(header, activeWorksheet)) ? 'large' : ''}`}
                                      dangerouslySetInnerHTML={{ __html: getHeaderNote(header, activeWorksheet) }}
                                    />
                                  </>
                                )}
                              </div>
                            </td>
                            <td className={`py-2 px-4 border-b dark:border-gray-600 ${
                              getHeaderRequirement(header, activeWorksheet) === 'Required' 
                                ? 'text-red-500 dark:text-red-400 font-medium' 
                                : 'text-excel-500 dark:text-excel-400'
                            }`}>
                              {getHeaderRequirement(header, activeWorksheet) || 'Optional'}
                            </td>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              <CustomSelect
                                options={[
                                  { value: '', label: '-- Not Mapped --' },
                                  ...dataHeaders.filter(Boolean).map(dataHeader => ({
                                    value: dataHeader,
                                    label: dataHeader
                                  }))
                                ]}
                                value={currentMappings[header] || ''}
                                onChange={(value) => handleMappingChange(header, value, activeTab, activeWorksheet)}
                                isError={getHeaderRequirement(header, activeWorksheet) === 'Required' && (!currentMappings[header] || currentMappings[header] === '')}
                                suggestedValue={suggestedMappings[header] || null}
                                columnSamples={columnSamples}
                                columnDescriptions={dataHeaderDescriptions}
                              />
                            </td>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              {currentMappings[header] && (
                                <button
                                  onClick={() => clearMapping(header, activeTab, activeWorksheet)}
                                  className="p-1 bg-red-100 hover:bg-red-200 dark:bg-red-900/30 dark:hover:bg-red-900/50 text-red-700 dark:text-red-400 rounded"
                                  title="Clear this mapping"
                                >
                                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                    <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                                  </svg>
                                </button>
                              )}
                            </td>
                          </tr>
                        ));
                      })()}
                    </tbody>
                  </table>
                </div>
                
                <div className="mt-6 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                  <button
                    onClick={() => setStep(1)}
                    className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  >
                    Back
                  </button>
                  <button
                    onClick={mapData}
                    disabled={isLoading.mapping}
                    className={`px-4 py-2 rounded transition-colors ${
                      isLoading.mapping 
                        ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                        : 'bg-excel-500 hover:bg-excel-600 text-white'
                    }`}
                  >
                    {isLoading.mapping ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Mapping Data...
                      </span>
                    ) : (
                      <>
                        Map Data
                        {!enableMultiTabMapping && getUnmappedRequiredFieldsCount() > 0 && (
                          <span className="ml-2 bg-red-500 text-white text-xs px-1.5 py-0.5 rounded-full">
                            {getUnmappedRequiredFieldsCount()} unmapped required
                          </span>
                        )}
                        {enableMultiTabMapping && activeTab && activeWorksheet && 
                         getUnmappedRequiredFieldsCount(activeTab, activeWorksheet) > 0 && (
                          <span className="ml-2 bg-red-500 text-white text-xs px-1.5 py-0.5 rounded-full">
                            {getUnmappedRequiredFieldsCount(activeTab, activeWorksheet)} unmapped required
                          </span>
                        )}
                      </>
                    )}
                  </button>
                </div>
              </div>
            )}
            
            {step === 3 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">Data Successfully Mapped</h2>
                
                <div className="mb-6">
                  <p className="text-excel-600 dark:text-excel-400 mb-2 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    {enableMultiTabMapping ? (
                      <>
                        Mapping complete for {Object.keys(mappedData).length} mapped combinations across multiple worksheets
                      </>
                    ) : (
                      <>
                        Mapping complete for {mappedData.length - 1} rows of data
                      </>
                    )}
                  </p>
                  
                  <div className="warning-notice mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" className="warning-icon h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                    </svg>
                    <div>
                      <h4 className="font-medium text-orange-800 dark:text-orange-300 mb-1">Header Row Protection</h4>
                      <p className="text-orange-700 dark:text-orange-400 text-sm">
                        Your export may include special rows above the header that contain retailer platform information. Use the Data Row Offset option below to skip those rows when inserting your data.
                      </p>
                    </div>
                  </div>
                  
                  {preserveFormatting && (
                    <div className="format-preservation-notice mb-4">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-3 flex-shrink-0 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                      </svg>
                      <div>
                        <h4 className="font-medium text-blue-800 dark:text-blue-300 mb-1">Template formatting will be preserved</h4>
                        <div className="text-blue-700 dark:text-blue-400 text-sm">
                          <p>Your exported file will maintain all formatting, including:</p>
                          <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 mt-2">
                            <div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Colors, fonts, and borders
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Formulas and calculations
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Conditional formatting
                              </div>
                            </div>
                            <div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Data validation rules
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> Hyperlinks and styles
                              </div>
                              <div className="format-item">
                                <span className="format-icon">✓</span> All existing template content
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                  
                  <div className="export-options-panel">
                    <div className="export-options-title">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                      </svg>
                      Export Options
                    </div>
                    
                    <div className="export-option-group">
                      {/* Row offset option */}
                      <div className="mb-4 border-b pb-4 border-gray-200 dark:border-gray-700">
                        <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-2">Data Insertion Options</h3>
                        
                        <div className="flex items-center mb-3">
                          <input 
                            type="checkbox" 
                            id="preserveHeaderRows" 
                            checked={exportOptions.preserveHeaderRows}
                            onChange={(e) => handleExportOptionChange('preserveHeaderRows', e.target.checked)}
                            className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                          />
                          <label htmlFor="preserveHeaderRows" className="text-gray-700 dark:text-gray-300">
                            Preserve header rows
                          </label>
                        </div>
                        
                        <div className="mb-2">
                          <label htmlFor="dataRowOffset" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Data row offset (rows to skip after header before inserting data)
                          </label>
                          <div className="flex items-center">
                            <input
                              type="number"
                              id="dataRowOffset"
                              min="0"
                              value={exportOptions.dataRowOffset}
                              onChange={handleDataRowOffsetChange}
                              className="mt-1 block w-24 px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-base focus:outline-none focus:ring-excel-500 focus:border-excel-500 dark:text-white"
                            />
                            <span className="ml-2 text-sm text-gray-500 dark:text-gray-400">
                              rows
                            </span>
                          </div>
                          <p className="mt-1 text-sm text-gray-500 dark:text-gray-400">
                            Increase this value to skip more rows after the header row before inserting data.
                            This helps when your template has metadata, validation, or retailer-specific rows.
                          </p>
                        </div>
                      </div>
                      
                      {/* Existing export options */}
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="preserveExistingData" 
                          checked={exportOptions.preserveExistingData}
                          onChange={(e) => handleExportOptionChange('preserveExistingData', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="preserveExistingData" className="font-medium">Preserve All Template Content</label>
                          <p className="export-option-description">
                            Only overwrite cells where mapped data exists, leave all other template cells intact
                          </p>
                        </div>
                      </div>
                    
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="preserveFormulas" 
                          checked={exportOptions.preserveFormulas}
                          onChange={(e) => handleExportOptionChange('preserveFormulas', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="preserveFormulas" className="font-medium">Preserve Formulas</label>
                          <p className="export-option-description">
                            Keep Excel formulas from the template (recommended for calculated fields)
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="preserveStyles" 
                          checked={exportOptions.preserveStyles}
                          onChange={(e) => handleExportOptionChange('preserveStyles', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="preserveStyles" className="font-medium">Preserve Cell Styles</label>
                          <p className="export-option-description">
                            Keep colors, fonts, borders and cell styles from the template
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="applyColumnFormats" 
                          checked={exportOptions.applyColumnFormats}
                          onChange={(e) => handleExportOptionChange('applyColumnFormats', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="applyColumnFormats" className="font-medium">Apply Column Formats</label>
                          <p className="export-option-description">
                            Apply number, date, and text formats from the template columns
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="preserveValidation" 
                          checked={exportOptions.preserveValidation}
                          onChange={(e) => handleExportOptionChange('preserveValidation', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="preserveValidation" className="font-medium">Preserve Data Validation</label>
                          <p className="export-option-description">
                            Keep dropdown lists and validation rules from the template
                          </p>
                        </div>
                      </div>
                      
                      <div className="export-option-label">
                        <input 
                          type="checkbox" 
                          id="includeMacros" 
                          checked={exportOptions.includeMacros}
                          onChange={(e) => handleExportOptionChange('includeMacros', e.target.checked)}
                        />
                        <div>
                          <label htmlFor="includeMacros" className="font-medium">Include Macros (VBA)</label>
                          <p className="export-option-description">
                            Try to include macros from template (if present). May cause compatibility issues in some cases.
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>

                  {enableMultiTabMapping ? (
                    <div className="mt-4 mb-6">
                      <div className="tab-selector mb-3">
                        {Object.keys(mappedData).map((mappingKey, index) => {
                          const { category, worksheet, isMainTab } = mappedData[mappingKey];
                          return (
                            <div
                              key={index}
                              className={`tab-item ${activeTab === mappingKey ? 'active' : ''}`}
                              onClick={() => setActiveTab(mappingKey)}
                            >
                              <div className="flex items-center">
                                <span>{isMainTab ? "All Data" : category}</span>
                                <span className="badge worksheet-badge ml-2 text-xs">
                                  {worksheet}
                                </span>
                                <span className="ml-1 text-xs text-gray-500 dark:text-gray-400">
                                  ({mappedData[mappingKey].data.length - 1} rows)
                                </span>
                                {isMainTab && (
                                  <span className="main-tab-badge ml-1">Main</span>
                                )}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                      
                      {activeTab && mappedData[activeTab] && (
                        <div className="overflow-x-auto">
                          <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                            <thead className="bg-gray-50 dark:bg-gray-700">
                              <tr>
                                {mappedData[activeTab].data[0].map((header, index) => {
                                  // Get the target worksheet for this category
                                  const targetWorksheet = mappedData[activeTab].worksheet;
                                  // Determine if this header has notes based on the target worksheet
                                  const hasNotes = headerHasNotes(header, targetWorksheet);
                                  // Get the note content if available
                                  const noteContent = getHeaderNote(header, targetWorksheet);
                                  // Get requirement status
                                  const isRequired = getHeaderRequirement(header, targetWorksheet) === 'Required';
                                  
                                  return (
                                    <th key={index} className="py-2 px-4 border-b dark:border-gray-600 text-left">
                                      <div className="tooltip flex items-center">
                                        <span className={hasNotes ? "has-notes" : ""}>
                                          {header || '(Empty Column)'}
                                          {header && isRequired && (
                                            <span className="ml-1 text-red-500 dark:text-red-400">*</span>
                                          )}
                                        </span>
                                        {header && hasNotes && (
                                          <>
                                            <span className="info-icon ml-1">i</span>
                                            <span 
                                              className={`tooltip-text ${isLargeNote(noteContent) ? 'large' : ''}`}
                                              dangerouslySetInnerHTML={{ __html: noteContent }}
                                            />
                                          </>
                                        )}
                                      </div>
                                    </th>
                                  );
                                })}
                              </tr>
                            </thead>
                            <tbody>
                              {mappedData[activeTab].data.slice(1, Math.min(6, mappedData[activeTab].data.length)).map((row, rowIndex) => (
                                <tr 
                                  key={rowIndex} 
                                  className={`${rowIndex % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'} ${mappedData[activeTab].isMainTab ? 'main-tab-highlight' : ''}`}
                                >
                                  {row.map((cell, cellIndex) => (
                                    <td key={cellIndex} className="py-2 px-4 border-b dark:border-gray-600">
                                      {cell === undefined || cell === null ? '' : String(cell)}
                                    </td>
                                  ))}
                                </tr>
                              ))}
                            </tbody>
                          </table>
                          {mappedData[activeTab].data.length > 6 && (
                            <p className="mt-2 text-gray-500 dark:text-gray-400 text-sm">
                              Showing first 5 rows of {mappedData[activeTab].data.length - 1} total rows
                              for {mappedData[activeTab].isMainTab ? "All Data" : mappedData[activeTab].category} → {mappedData[activeTab].worksheet}
                            </p>
                          )}
                          <p className="mt-2 text-sm text-blue-600 dark:text-blue-400">
                            Will be inserted in worksheet "{mappedData[activeTab].worksheet}" starting at row {mappedData[activeTab].headerRow + exportOptions.dataRowOffset}
                            {mappedData[activeTab].isMainTab && (
                              <span className="ml-2 font-medium">(Main tab with ALL data)</span>
                            )}
                          </p>
                        </div>
                      )}
                      
                      <div className="mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-900/30 rounded-md text-yellow-800 dark:text-yellow-200">
                        <div className="flex">
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                          </svg>
                          <div>
                            <p className="font-medium mb-1">Multi-tab mapping summary:</p>
                            <ul className="list-disc list-inside text-sm ml-2">
                              <li>
                                {Object.keys(mappedData).filter(key => !mappedData[key].isMainTab).length} category-worksheet combinations mapped
                              </li>
                              <li>
                                {includeMainTab && mainTabSelection ? "Main tab includes ALL data rows regardless of category" : "No main tab selected"}
                              </li>
                              <li>
                                Data spread across {new Set(Object.values(mappedData).map(item => item.worksheet)).size} different worksheets
                              </li>
                              <li>
                                Total rows to be exported: {Object.values(mappedData).reduce((total, item) => total + item.data.length - 1, 0)}
                              </li>
                              <li>
                                Each worksheet uses its specific column mappings and header row configuration
                              </li>
                              <li>
                                Click on each mapping tab above to preview the data that will be exported
                              </li>
                            </ul>
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div className="overflow-x-auto mt-4 mb-6">
                      <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                        <thead className="bg-gray-50 dark:bg-gray-700">
                          <tr>
                            {mappedData[0].map((header, index) => (
                              <th key={index} className="py-2 px-4 border-b dark:border-gray-600 text-left">
                                <div className="tooltip flex items-center">
                                  <span className={header && headerHasNotes(header) ? "has-notes" : ""}>
                                    {header || '(Empty Column)'}
                                    {header && fieldRequirements[header] === 'Required' && (
                                      <span className="ml-1 text-red-500 dark:text-red-400">*</span>
                                    )}
                                  </span>
                                  {header && headerHasNotes(header) && (
                                    <>
                                      <span className="info-icon ml-1">i</span>
                                      <span 
                                        className={`tooltip-text ${isLargeNote(templateHeaderNotes[header]) ? 'large' : ''}`}
                                        dangerouslySetInnerHTML={{ __html: templateHeaderNotes[header] }}
                                      />
                                    </>
                                  )}
                                </div>
                              </th>
                            ))}
                          </tr>
                        </thead>
                        <tbody>
                          {mappedData.slice(1, Math.min(6, mappedData.length)).map((row, rowIndex) => (
                            <tr key={rowIndex} className={rowIndex % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                              {row.map((cell, cellIndex) => (
                                <td key={cellIndex} className="py-2 px-4 border-b dark:border-gray-600">
                                  {cell === undefined || cell === null ? '' : String(cell)}
                                </td>
                              ))}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                      {mappedData.length > 6 && (
                        <p className="mt-2 text-gray-500 dark:text-gray-400 text-sm">Showing first 5 rows of {mappedData.length - 1} total rows</p>
                      )}
                      <p className="mt-2 text-sm text-blue-600 dark:text-blue-400">
                        Data will be inserted after row {templateHeaderRow + exportOptions.dataRowOffset} (Header row + offset)
                      </p>
                    </div>
                  )}
                </div>
                
                <div className="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                  <button
                    onClick={() => setStep(2)}
                    className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  >
                    Back to Mapping
                  </button>
                  <button
                    onClick={exportExcel}
                    disabled={isLoading.export}
                    className={`px-4 py-2 ${isLoading.export ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' : 'bg-excel-500 hover:bg-excel-600'} text-white rounded transition-colors flex items-center justify-center`}
                  >
                    {isLoading.export ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Exporting Excel File...
                      </span>
                    ) : (
                      <>
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        {enableMultiTabMapping ? 'Download Multi-Tab Mapped Excel File' : 'Download Mapped Excel File'}
                      </>
                    )}
                  </button>
                </div>
              </div>
            )}
            
            <div className="mt-6 text-center text-sm text-gray-500 dark:text-gray-400">
              Excel Mapper | Use this tool to map data between different Excel formats
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<ExcelMapper />, document.getElementById('excel-mapper-root'));
  </script>
</body>
</html>
