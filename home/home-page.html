<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Excel Template Mapper</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.4/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            // Excel green color palette
            excel: {
              50: '#eef9f1',
              100: '#d5f0db',
              200: '#ace1b7',
              300: '#7bca8e',
              400: '#4fb06a',
              500: '#217346', // Main Excel green
              600: '#1e6a40',
              700: '#1a5a38',
              800: '#154a2e',
              900: '#113c25',
            }
          }
        }
      }
    }
  </script>
  <style>
    /* Add base styles for dark mode */
    .dark {
      color-scheme: dark;
    }

    /* Fix for file input */
    input[type="file"]::-webkit-file-upload-button {
      cursor: pointer;
      height: 100%;
    }

    /* Custom scrollbar for better UX */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    
    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 4px;
    }
    
    .dark ::-webkit-scrollbar-thumb {
      background: #475569;
    }

    /* Enhanced Tooltip styles - update to trigger only on info icon */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltip-text {
      /* Size and shape */
      width: 280px;
      max-width: 90vw;
      border-radius: 8px;
      
      /* Positioning */
      position: absolute;
      z-index: 50;
      top: 125%;
      left: 0;
      
      /* Colors and borders */
      background-color: #217346; /* Excel green */
      color: #ffffff;
      border: 1px solid #1a5a38;
      
      /* Text formatting */
      font-size: 0.875rem;
      line-height: 1.5;
      text-align: left;
      
      /* Spacing and shadow */
      padding: 10px 12px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      
      /* Visibility and transition */
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      transform: translateY(-10px);
      
      /* Content overflow */
      overflow-wrap: break-word;
      word-wrap: break-word;
    }

    /* Arrow pointer for tooltip */
    .tooltip .tooltip-text::before {
      content: "";
      position: absolute;
      top: -8px;
      left: 15px;
      border-width: 0 8px 8px 8px;
      border-style: solid;
      border-color: transparent transparent #217346 transparent;
    }

    /* Only show tooltip when hovering over the info icon */
    .tooltip .info-icon:hover + .tooltip-text {
      visibility: visible;
      opacity: 1;
      transform: translateY(0);
    }

    /* Dark mode tooltip style */
    .dark .tooltip .tooltip-text {
      background-color: #1a5a38;
      border: 1px solid #154a2e;
      color: #ffffff;
    }

    .dark .tooltip .tooltip-text::before {
      border-color: transparent transparent #1a5a38 transparent;
    }

    /* For tooltips with longer content */
    .tooltip .tooltip-text.large {
      max-height: 200px;
      overflow-y: auto;
      padding-right: 15px;
    }

    /* Custom scrollbar for tooltip content */
    .tooltip .tooltip-text::-webkit-scrollbar {
      width: 6px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    .tooltip .tooltip-text::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Styled tooltip content */
    .tooltip .tooltip-text h4 {
      margin: 0 0 5px 0;
      font-size: 1rem;
      font-weight: 600;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 5px;
    }

    .tooltip .tooltip-text p {
      margin: 0 0 8px 0;
    }

    .tooltip .tooltip-text .highlight {
      background-color: rgba(255, 255, 255, 0.2);
      padding: 1px 3px;
      border-radius: 2px;
    }

    /* Column header styling */
    .has-notes {
      padding-bottom: 1px;
    }

    .tooltip .info-icon {
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #217346;
      color: white;
      margin-left: 5px;
      vertical-align: text-top;
      cursor: help;
    }

    .dark .tooltip .info-icon {
      background-color: #4fb06a;
    }

    /* Custom dropdown styles */
    .custom-select-container {
      position: relative;
      width: 100%;
    }

    .custom-select-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      background-color: white;
      cursor: pointer;
      user-select: none;
    }

    .dark .custom-select-header {
      background-color: #374151;
      border-color: #4b5563;
      color: white;
    }

    .custom-select-header.error {
      border-color: #ef4444;
    }

    .custom-select-header .arrow {
      transition: transform 0.2s;
    }

    .custom-select-header.open .arrow {
      transform: rotate(180deg);
    }

    .custom-select-dropdown {
      position: absolute;
      left: 0;
      right: 0;
      margin-top: 4px;
      max-height: 250px;
      overflow-y: auto;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      z-index: 30;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      display: none;
    }

    .custom-select-dropdown.open {
      display: block;
    }

    .dark .custom-select-dropdown {
      background-color: #1f2937;
      border-color: #374151;
    }

    .custom-select-option {
      padding: 8px 12px;
      cursor: pointer;
      transition: background-color 0.1s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .custom-select-option:hover {
      background-color: #f3f4f6;
    }

    .dark .custom-select-option:hover {
      background-color: #374151;
    }

    .custom-select-option.selected {
      background-color: #f9fafb;
      font-weight: 500;
    }

    .dark .custom-select-option.selected {
      background-color: #2a3441;
    }

    .custom-select-option.suggested {
      color: #4b5563;
      font-style: italic;
    }

    .dark .custom-select-option.suggested {
      color: #9ca3af;
    }

    /* Sample preview styles */
    .sample-preview {
      position: absolute;
      z-index: 40;
      width: 280px;
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
    }

    .sample-preview.visible {
      opacity: 1;
      visibility: visible;
    }

    .dark .sample-preview {
      background-color: #1f2937;
      border-color: #374151;
      color: white;
    }

    .sample-preview-header {
      padding: 10px 12px;
      background-color: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .dark .sample-preview-header {
      background-color: #374151;
      border-color: #4b5563;
    }

    .sample-preview-body {
      max-height: 180px;
      overflow-y: auto;
    }

    .sample-preview-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f3f4f6;
    }

    .sample-preview-item:last-child {
      border-bottom: none;
    }

    .dark .sample-preview-item {
      border-color: #374151;
    }

    .sample-preview-footer {
      padding: 8px 12px;
      background-color: #f9fafb;
      border-top: 1px solid #e5e7eb;
      font-size: 0.75rem;
      color: #6b7280;
      font-style: italic;
    }

    .dark .sample-preview-footer {
      background-color: #374151;
      border-color: #4b5563;
      color: #9ca3af;
    }

    /* Custom tooltip for dropdown options */
    .dropdown-tooltip {
      position: relative;
    }

    .dropdown-tooltip .tooltip-text {
      /* Fixed positioning for dropdown tooltips to escape overflow constraints */
      position: fixed;
      z-index: 100; /* Higher z-index to appear above all dropdowns */
      
      /* Sizing and spacing */
      width: 280px;
      max-width: 90vw;
      padding: 10px 12px;
      
      /* Remove standard positioning */
      left: auto;
      right: auto;
      top: auto;
      bottom: auto;
      
      /* Will be positioned via JavaScript */
      transform: none;
      
      /* Better shadow for dropdown tooltips */
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }

    /* Hide the standard arrow for dropdown tooltips */
    .dropdown-tooltip .tooltip-text::before {
      display: none;
    }
    
    /* Auto-mapping suggestion panel */
    .mapping-suggestion-panel {
      margin-bottom: 1.5rem;
      background-color: #f0f9ff;
      border: 1px solid #bae6fd;
      border-radius: 0.375rem;
      padding: 1rem;
    }
    
    .dark .mapping-suggestion-panel {
      background-color: rgba(14, 165, 233, 0.1);
      border-color: rgba(14, 165, 233, 0.2);
    }
    
    .mapping-suggestion {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      border-radius: 0.25rem;
      background-color: #fff;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }
    
    .dark .mapping-suggestion {
      background-color: #1f2937;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1);
    }
    
    .mapping-suggestion:last-child {
      margin-bottom: 0;
    }
    
    .mapping-confidence {
      display: inline-block;
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 500;
    }
    
    .confidence-high {
      background-color: #dcfce7;
      color: #166534;
    }
    
    .dark .confidence-high {
      background-color: rgba(22, 101, 52, 0.3);
      color: #4ade80;
    }
    
    .confidence-medium {
      background-color: #fef9c3;
      color: #854d0e;
    }
    
    .dark .confidence-medium {
      background-color: rgba(133, 77, 14, 0.3);
      color: #facc15;
    }
    
    .confidence-low {
      background-color: #fee2e2;
      color: #b91c1c;
    }
    
    .dark .confidence-low {
      background-color: rgba(185, 28, 28, 0.3);
      color: #f87171;
    }

    /* Badge styles */
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .worksheet-badge {
      background-color: #e0f2fe;
      color: #0369a1;
      border: 1px solid #bae6fd;
    }

    .dark .worksheet-badge {
      background-color: rgba(14, 165, 233, 0.2);
      border-color: rgba(14, 165, 233, 0.3);
      color: #38bdf8;
    }

    /* Category mapping styles */
    .category-mapping-item {
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      margin-bottom: 0.75rem;
      background-color: white;
    }

    .dark .category-mapping-item {
      background-color: #1f2937;
      border-color: #374151;
    }

    .category-mapping-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #e5e7eb;
      background-color: #f9fafb;
      border-top-left-radius: 0.375rem;
      border-top-right-radius: 0.375rem;
    }

    .dark .category-mapping-header {
      background-color: #374151;
      border-color: #4b5563;
    }

    .category-mapping-body {
      padding: 1rem;
    }

    /* Tab selector styles */
    .tab-selector {
      display: flex;
      overflow-x: auto;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 1rem;
    }

    .dark .tab-selector {
      border-color: #4b5563;
    }

    .tab-item {
      padding: 0.5rem 1rem;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      white-space: nowrap;
      font-weight: 500;
    }

    .tab-item:hover {
      color: #4b5563;
    }

    .dark .tab-item:hover {
      color: #9ca3af;
    }

    .tab-item.active {
      border-bottom-color: #217346;
      color: #217346;
    }

    .dark .tab-item.active {
      border-bottom-color: #4fb06a;
      color: #4fb06a;
    }
  </style>
</head>
<body>
  <div id="excel-mapper-root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Check for dark mode preference
    const initDarkMode = () => {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.classList.add('dark');
        return true;
      }
      return false;
    };

    // Custom Select Component with hover preview support and descriptions
    const CustomSelect = ({ 
      options, 
      value, 
      onChange, 
      placeholder = "-- Select an option --", 
      isError = false,
      suggestedValue = null,
      columnSamples = {},
      columnDescriptions = {}
    }) => {
      const [isOpen, setIsOpen] = useState(false);
      const [previewVisible, setPreviewVisible] = useState(false);
      const [previewHeader, setPreviewHeader] = useState(null);
      const [previewPos, setPreviewPos] = useState({ top: 0, left: 0 });
      const previewTimerRef = useRef(null);
      const dropdownRef = useRef(null);
      const containerRef = useRef(null);
      
      // Handle click outside to close dropdown
      useEffect(() => {
        const handleClickOutside = (event) => {
          if (containerRef.current && !containerRef.current.contains(event.target)) {
            setIsOpen(false);
          }
        };
        
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
          document.removeEventListener('mousedown', handleClickOutside);
        };
      }, []);
      
      // Clean up preview timer
      useEffect(() => {
        return () => {
          if (previewTimerRef.current) {
            clearTimeout(previewTimerRef.current);
          }
        };
      }, []);

      const handleToggle = () => {
        setIsOpen(!isOpen);
      };
      
      const handleSelect = (optionValue) => {
        onChange(optionValue);
        setIsOpen(false);
      };
      
      const handleOptionMouseEnter = (e, optionValue) => {
        // Clear any existing timer
        if (previewTimerRef.current) {
          clearTimeout(previewTimerRef.current);
        }
        
        // Set a timer to show preview after 1.5 seconds
        if (columnSamples[optionValue] && columnSamples[optionValue].length > 0) {
          previewTimerRef.current = setTimeout(() => {
            // Calculate position
            const rect = e.currentTarget.getBoundingClientRect();
            
            setPreviewHeader(optionValue);
            setPreviewPos({
              top: rect.top,
              left: rect.right + 10 // 10px right of the option
            });
            setPreviewVisible(true);
          }, 1500);
        }
      };
      
      const handleOptionMouseLeave = () => {
        if (previewTimerRef.current) {
          clearTimeout(previewTimerRef.current);
          previewTimerRef.current = null;
        }
        setPreviewVisible(false);
      };
      
      // Find the selected option's label
      const selectedOption = options.find(opt => opt.value === value);
      const displayValue = selectedOption ? selectedOption.label : placeholder;
      
      // Helper to check if a column has a description
      const hasDescription = (optionValue) => {
        return columnDescriptions[optionValue] && columnDescriptions[optionValue].trim() !== '';
      };
      
      return (
        <div ref={containerRef} className="custom-select-container">
          <div 
            className={`custom-select-header ${isOpen ? 'open' : ''} ${isError ? 'error' : ''}`} 
            onClick={handleToggle}
          >
            <span className={!selectedOption ? 'text-gray-400 dark:text-gray-500' : 'flex items-center'}>
              {displayValue}
              {value && hasDescription(value) && (
                <div className="tooltip ml-1">
                  <span className="info-icon text-xs">i</span>
                  <span 
                    className={`tooltip-text ${columnDescriptions[value] && columnDescriptions[value].length > 150 ? 'large' : ''}`}
                    dangerouslySetInnerHTML={{ __html: columnDescriptions[value] }}
                  />
                </div>
              )}
            </span>
            <span className="arrow">â–¼</span>
          </div>
          
          <div 
            ref={dropdownRef} 
            className={`custom-select-dropdown ${isOpen ? 'open' : ''}`}
          >
            {options.map((option) => (
              <div
                key={option.value || 'empty'}
                className={`custom-select-option ${option.value === value ? 'selected' : ''} ${option.value === suggestedValue ? 'suggested' : ''}`}
                onClick={() => handleSelect(option.value)}
                onMouseEnter={(e) => handleOptionMouseEnter(e, option.value)}
                onMouseLeave={handleOptionMouseLeave}
              >
                <div className="flex justify-between w-full items-center">
                  <div className="flex items-center">
                    <span className="mr-1">{option.label}</span>
                    {hasDescription(option.value) && (
                      <div className="dropdown-tooltip tooltip">
                        <span className="info-icon text-xs" 
                          onMouseEnter={(e) => {
                            // Get tooltip element (next sibling)
                            const tooltip = e.target.nextSibling;
                            if (tooltip) {
                              // Calculate position - above the icon
                              const rect = e.target.getBoundingClientRect();
                              tooltip.style.top = `${rect.top - 10 - tooltip.offsetHeight}px`;
                              tooltip.style.left = `${rect.left - tooltip.offsetWidth + 20}px`;
                              tooltip.style.visibility = 'visible';
                              tooltip.style.opacity = '1';
                            }
                          }}
                          onMouseLeave={(e) => {
                            // Hide tooltip on mouse leave
                            const tooltip = e.target.nextSibling;
                            if (tooltip) {
                              tooltip.style.visibility = 'hidden';
                              tooltip.style.opacity = '0';
                            }
                          }}
                        >i</span>
                        <span 
                          className={`tooltip-text ${columnDescriptions[option.value] && columnDescriptions[option.value].length > 150 ? 'large' : ''}`}
                          dangerouslySetInnerHTML={{ __html: columnDescriptions[option.value] }}
                        />
                      </div>
                    )}
                  </div>
                  
                  {option.value === suggestedValue && (
                    <span className="text-sm text-gray-500 dark:text-gray-400">(Suggested)</span>
                  )}
                </div>
              </div>
            ))}
          </div>
          
          {/* Sample preview popup */}
          {previewVisible && columnSamples[previewHeader] && (
            <div 
              className={`sample-preview ${previewVisible ? 'visible' : ''}`}
              style={{ top: `${previewPos.top}px`, left: `${previewPos.left}px` }}
            >
              <div className="sample-preview-header">
                Sample data: <span className="text-excel-600 dark:text-excel-400">{previewHeader}</span>
              </div>
              <div className="sample-preview-body">
                {columnSamples[previewHeader].map((sample, index) => (
                  <div key={index} className="sample-preview-item">
                    {typeof sample === 'undefined' || sample === null ? 
                      <span className="text-gray-400 dark:text-gray-500">Empty</span> : 
                      String(sample)
                    }
                  </div>
                ))}
              </div>
              <div className="sample-preview-footer">
                Showing {columnSamples[previewHeader].length} sample values from this column
              </div>
            </div>
          )}
        </div>
      );
    };

    const ExcelMapper = () => {
      const [template, setTemplate] = useState(null);
      const [data, setData] = useState(null);
      const [templateFile, setTemplateFile] = useState(null);
      const [dataFile, setDataFile] = useState(null);
      const [templateHeaders, setTemplateHeaders] = useState([]);
      const [dataHeaders, setDataHeaders] = useState([]);
      const [mappings, setMappings] = useState({});
      const [suggestedMappings, setSuggestedMappings] = useState({});
      const [mappingScores, setMappingScores] = useState({});
      const [mappedData, setMappedData] = useState(null);
      const [step, setStep] = useState(1);
      const [isDarkMode, setIsDarkMode] = useState(initDarkMode());
      const [isLoading, setIsLoading] = useState({
        template: false,
        data: false,
        mapping: false
      });
      
      // Sheet selection states
      const [templateSheets, setTemplateSheets] = useState([]);
      const [dataSheets, setDataSheets] = useState([]);
      const [selectedTemplateSheet, setSelectedTemplateSheet] = useState('');
      const [selectedDataSheet, setSelectedDataSheet] = useState('');
      const [templateHeaderRow, setTemplateHeaderRow] = useState(1);
      const [dataHeaderRow, setDataHeaderRow] = useState(1);
      
      // Required/Optional field states
      const [requirementRowAvailable, setRequirementRowAvailable] = useState(false);
      const [templateRequirementRow, setTemplateRequirementRow] = useState(2);
      const [fieldRequirements, setFieldRequirements] = useState({});
      
      // Template header notes state from data validation or comments
      const [templateHeaderNotes, setTemplateHeaderNotes] = useState({});
      const [dataHeaderDescriptions, setDataHeaderDescriptions] = useState({});
      const [debugInfo, setDebugInfo] = useState("");
      
      // Column data samples for preview
      const [columnSamples, setColumnSamples] = useState({});
      
      // State to track if suggestions have been reviewed
      const [suggestionsReviewed, setSuggestionsReviewed] = useState(false);
      
      // States for multi-tab mapping
      const [enableMultiTabMapping, setEnableMultiTabMapping] = useState(false);
      const [categoryColumn, setCategoryColumn] = useState('');
      const [categoryValues, setCategoryValues] = useState([]);
      const [categoryWorksheetMappings, setCategoryWorksheetMappings] = useState({});
      const [activeTab, setActiveTab] = useState(null);
      const [tabSpecificMappings, setTabSpecificMappings] = useState({});
      const [useSharedMappings, setUseSharedMappings] = useState(true);
      
      // Listen for dark mode changes
      useEffect(() => {
        const darkModeListener = (e) => {
          const isDark = e.matches;
          setIsDarkMode(isDark);
          if (isDark) {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        };
        
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        mediaQuery.addEventListener('change', darkModeListener);
        
        return () => mediaQuery.removeEventListener('change', darkModeListener);
      }, []);

      // Function to handle file uploads
      const handleFileUpload = (e, fileType) => {
        const file = e.target.files[0];
        if (!file) return;
        
        setIsLoading(prev => ({ ...prev, [fileType]: true }));
        
        const reader = new FileReader();
        
        reader.onload = (evt) => {
          try {
            const binaryString = evt.target.result;
            const workbook = XLSX.read(binaryString, { type: 'binary', cellFormula: true, cellNF: true, cellDates: true, cellStyles: true });
            
            if (fileType === 'template') {
              setTemplateFile(file);
              setTemplateSheets(workbook.SheetNames);
              setSelectedTemplateSheet(workbook.SheetNames[0]);
            } else {
              setDataFile(file);
              setDataSheets(workbook.SheetNames);
              setSelectedDataSheet(workbook.SheetNames[0]);
            }
          } catch (error) {
            console.error(`Error reading ${fileType} file:`, error);
          } finally {
            setIsLoading(prev => ({ ...prev, [fileType]: false }));
          }
        };
        
        reader.onerror = () => {
          console.error(`Error reading ${fileType} file`);
          setIsLoading(prev => ({ ...prev, [fileType]: false }));
        };
        
        reader.readAsBinaryString(file);
      };

      // Process the selected worksheet with headers and requirement info
      const processSheet = (fileType) => {
        const file = fileType === 'template' ? templateFile : dataFile;
        if (!file) return;
        
        setIsLoading(prev => ({ ...prev, [fileType]: true }));
        
        const reader = new FileReader();
        
        reader.onload = (evt) => {
          try {
            const binaryString = evt.target.result;
            // Include cellStyles to access cell formatting information
            const workbook = XLSX.read(binaryString, { 
              type: 'binary', 
              cellFormula: true,  // Get formulas
              cellStyles: true,   // Get cell styles
              cellDates: true,    // Get dates
              cellNF: true,       // Get number formats
              cellText: false     // Don't get text
            });
            
            const selectedSheet = fileType === 'template' ? selectedTemplateSheet : selectedDataSheet;
            const worksheet = workbook.Sheets[selectedSheet];
            
            // Get all data as array of arrays
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            if (fileType === 'template') {
              // Extract headers from specified row (convert to 0-based index)
              const headerRowIndex = templateHeaderRow - 1;
              const headers = jsonData[headerRowIndex] || [];
              
              // Process requirement row if enabled
              let requirements = {};
              if (requirementRowAvailable) {
                const reqRowIndex = templateRequirementRow - 1;
                const reqRow = jsonData[reqRowIndex] || [];
                
                headers.forEach((header, index) => {
                  if (header) {
                    // Check if the requirement cell contains any indicator of being required
                    const reqValue = reqRow[index];
                    const isRequired = 
                      reqValue && 
                      String(reqValue).toLowerCase().match(/required|mandatory|req|r|yes|y|\*/i) !== null;
                    
                    requirements[header] = isRequired ? 'Required' : 'Optional';
                  }
                });
              } else {
                // Default all fields to optional if no requirement row specified
                headers.forEach(header => {
                  if (header) {
                    requirements[header] = 'Optional';
                  }
                });
              }
              
              setFieldRequirements(requirements);
              
              // This will hold all the notes/tooltips found for headers
              const notes = {};
              let validationCount = 0;
              let commentCount = 0;
              
              // Try to extract validation input messages
              // In SheetJS, data validations might be found in the dataValidation property
              const hasValidations = worksheet['!dataValidations'] || 
                                    (worksheet.Workbook && worksheet.Workbook.Sheets && 
                                     worksheet.Workbook.Sheets[0] && 
                                     worksheet.Workbook.Sheets[0].DataValidations);
              
              // Iterate over header cells to find validation messages or comments
              headers.forEach((header, index) => {
                if (!header) return;
                
                // Calculate the cell reference for this header
                const colLetter = XLSX.utils.encode_col(index);
                const cellRef = `${colLetter}${headerRowIndex + 1}`;
                
                let foundNote = "";
                
                // Try to get data validation input message
                if (worksheet['!dataValidations']) {
                  const validations = worksheet['!dataValidations'];
                  for (let i = 0; i < validations.length; i++) {
                    const validation = validations[i];
                    // Check if validation applies to this cell
                    if (validation.sqref === cellRef || validation.sqref.includes(cellRef)) {
                      if (validation.prompt) {
                        foundNote = validation.prompt;
                        validationCount++;
                        break;
                      }
                    }
                  }
                }
                
                // If validation message not found, try fallback methods
                if (!foundNote) {
                  // Check for comments/notes as fallback
                  if (worksheet[cellRef] && worksheet[cellRef].c && worksheet[cellRef].c.length > 0) {
                    foundNote = worksheet[cellRef].c[0].t || "";
                    commentCount++;
                  }
                  else if (worksheet[cellRef] && worksheet[cellRef].cm) {
                    foundNote = typeof worksheet[cellRef].cm === 'string' ? 
                      worksheet[cellRef].cm : 
                      (worksheet[cellRef].cm.t || worksheet[cellRef].cm.text || "");
                    commentCount++;
                  }
                  else if (worksheet.comments && worksheet.comments[cellRef]) {
                    foundNote = worksheet.comments[cellRef].t || worksheet.comments[cellRef].text || "";
                    commentCount++;
                  }
                }
                
                // Store the note (empty string if none found)
                notes[header] = foundNote;
              });
              
              // Create debug info
              let debugText = `Found ${validationCount} validation input messages and ${commentCount} comments.`;
              setDebugInfo(debugText);
              
              // Add fallback demo notes for demonstration if no real messages found
              if (validationCount === 0 && commentCount === 0) {
                headers.forEach((header, index) => {
                  if (!header) return;
                  
                  // Add formatted demo notes with more detailed examples
                  if (index % 4 === 0) {
                    notes[header] = `<h4>Input Guidelines</h4><p>Enter data for <span class="highlight">${header}</span> in the correct format to ensure data integrity.</p>`;
                  } else if (index % 4 === 1) {
                    notes[header] = `<h4>${header}</h4><p>This field should contain ${header.toLowerCase()} information that follows these rules:</p><ul><li>Must be properly formatted</li><li>Should be accurate and verified</li></ul>`;
                  } else if (index % 4 === 2) {
                    notes[header] = `<h4>Format Required</h4><p>The <span class="highlight">${header}</span> field expects data in a specific format. Please ensure your data matches this expectation.</p>`;
                  } else if (index % 4 === 3 && requirements[header] === 'Required') {
                    notes[header] = `<h4>Required Field</h4><p>The <span class="highlight">${header}</span> field must be completed. Missing data will cause validation errors.</p>`;
                  }
                });
                setDebugInfo("Using demo validation messages for illustration (no real validation data found in Excel file).");
              }
              
              setTemplateHeaderNotes(notes);
              
              // Get data rows (all rows after the header row)
              const dataRows = jsonData.slice(headerRowIndex + 1);
              
              // Combine headers with dataRows for complete dataset
              const fullData = [headers, ...dataRows];
              
              setTemplate({ workbook, sheet: selectedSheet, headers, data: fullData });
              setTemplateHeaders(headers);
              
              // Reset suggestions reviewed state when loading a new template
              setSuggestionsReviewed(false);
              
              // Reset multi-tab mapping settings
              setEnableMultiTabMapping(false);
              setCategoryColumn('');
              setCategoryValues([]);
              setCategoryWorksheetMappings({});
              setActiveTab(null);
              setTabSpecificMappings({});
              setUseSharedMappings(true);
            } else {
              // Process data file normally (unchanged)
              const headerRowIndex = dataHeaderRow - 1;
              const headers = jsonData[headerRowIndex] || [];
              
              // Generate demo descriptions for data headers
              const descriptions = {};
              headers.forEach((header, index) => {
                if (!header) return;
                
                // Create descriptive text based on header name
                const words = header.split(/[\s_.-]+/);
                const formattedHeader = words.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');
                
                if (index % 5 === 0) {
                  descriptions[header] = `<h4>${formattedHeader}</h4><p>Contains unique identifier values for each record. Use this for reference or linking to other systems.</p>`;
                } else if (index % 5 === 1) {
                  descriptions[header] = `<h4>${formattedHeader}</h4><p>This column stores ${formattedHeader.toLowerCase()} values from the source system. <span class="highlight">Important for data integrity</span>.</p>`;
                } else if (index % 5 === 2) {
                  descriptions[header] = `<h4>About ${formattedHeader}</h4><p>Contains formatted text data with ${formattedHeader.toLowerCase()} information. This data is used for reporting and analytics.</p>`;
                } else if (index % 5 === 3) {
                  descriptions[header] = `<h4>${formattedHeader} Details</h4><p>This column provides metadata about each record, including things like:</p><ul><li>Source system information</li><li>Last update timestamp</li><li>Validation status</li></ul>`;
                } else {
                  descriptions[header] = `<h4>${formattedHeader} Column</h4><p>This field contains supplementary information that may be useful for specific reporting needs. The content is <span class="highlight">variable in format</span>.</p>`;
                }
              });
              
              setDataHeaderDescriptions(descriptions);
              
              // Get data rows (all rows after the header row)
              const dataRows = jsonData.slice(headerRowIndex + 1);
              
              // Combine headers with dataRows for complete dataset
              const fullData = [headers, ...dataRows];
              
              setData({ workbook, sheet: selectedSheet, headers, data: fullData });
              setDataHeaders(headers);
              
              // Extract sample data for each column (up to 5 unique non-empty values)
              const samples = {};
              headers.forEach((header, colIndex) => {
                if (!header) return;
                
                const columnData = new Set();
                // Loop through the first 20 rows to find samples
                for (let rowIndex = 0; rowIndex < Math.min(dataRows.length, 20); rowIndex++) {
                  const row = dataRows[rowIndex];
                  if (row && colIndex < row.length && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== '') {
                    columnData.add(row[colIndex]);
                    if (columnData.size >= 5) break; // Collect up to 5 samples
                  }
                }
                
                // Convert Set to Array
                samples[header] = Array.from(columnData);
                
                // If we don't have enough samples, try to get more including empty values
                if (samples[header].length < 3 && dataRows.length > 0) {
                  samples[header] = [];
                  for (let rowIndex = 0; rowIndex < Math.min(dataRows.length, 5); rowIndex++) {
                    const row = dataRows[rowIndex];
                    if (row && colIndex < row.length) {
                      samples[header].push(row[colIndex]);
                    }
                  }
                }
              });
              
              setColumnSamples(samples);
              
              // If template headers already exist, generate suggested mappings
              if (templateHeaders.length > 0) {
                const { suggestions, scores } = generateFuzzyMappings(templateHeaders, headers);
                setSuggestedMappings(suggestions);
                setMappingScores(scores);
                setMappings(suggestions);
                
                // Reset suggestions reviewed state when loading new data
                setSuggestionsReviewed(false);
              }
              
              // Get unique values for category column if one is selected
              if (enableMultiTabMapping && categoryColumn) {
                updateCategoryValues(headers, dataRows, categoryColumn);
              }
            }
          } catch (error) {
            console.error(`Error processing ${fileType} sheet:`, error);
            setDebugInfo(`Error: ${error.message}`);
          } finally {
            setIsLoading(prev => ({ ...prev, [fileType]: false }));
          }
        };
        
        reader.onerror = () => {
          console.error(`Error reading ${fileType} file for processing`);
          setIsLoading(prev => ({ ...prev, [fileType]: false }));
        };
        
        reader.readAsBinaryString(file);
      };

      // Enhanced fuzzy matching function
      const fuzzyMatch = (str1, str2) => {
        if (!str1 || !str2) return 0;
        
        // Normalize strings: lowercase, remove special chars, trim whitespace
        const cleanStr1 = String(str1).toLowerCase().replace(/[^a-z0-9]/gi, '');
        const cleanStr2 = String(str2).toLowerCase().replace(/[^a-z0-9]/gi, '');
        
        // Exact match after normalization is a perfect score
        if (cleanStr1 === cleanStr2) return 1.0;
        
        // Calculate Levenshtein distance-based similarity
        const len1 = cleanStr1.length;
        const len2 = cleanStr2.length;
        
        // If either string is empty, similarity is 0
        if (len1 === 0 || len2 === 0) return 0;
        
        // Check for containment (one string is part of the other)
        if (cleanStr1.includes(cleanStr2) || cleanStr2.includes(cleanStr1)) {
          // Length ratio determines strength of the match
          const containmentScore = Math.min(len1, len2) / Math.max(len1, len2);
          // Boost score for containment
          return Math.min(1.0, containmentScore + 0.3);
        }
        
        // Character by character matching, giving more weight to matching prefixes
        let matchScore = 0;
        const maxLen = Math.max(len1, len2);
        const minLen = Math.min(len1, len2);
        
        for (let i = 0; i < minLen; i++) {
          // Characters match
          if (cleanStr1[i] === cleanStr2[i]) {
            // Earlier matches are more important (prefix bonus)
            matchScore += 1 - (i / (2 * maxLen));
          }
        }
        
        // Normalize score
        return matchScore / maxLen;
      };

      // Generate suggested mappings based on enhanced fuzzy matching
      const generateFuzzyMappings = (templateHeaders, dataHeaders) => {
        const suggestions = {};
        const scores = {};
        
        templateHeaders.forEach(templateHeader => {
          if (!templateHeader) return;
          
          // Track all matches for this template header
          let matches = [];
          
          dataHeaders.forEach(dataHeader => {
            if (!dataHeader) return;
            
            const score = fuzzyMatch(templateHeader, dataHeader);
            if (score > 0.3) { // Consider any match above 30% similarity
              matches.push({ header: dataHeader, score });
            }
          });
          
          // Sort matches by score (highest first)
          matches.sort((a, b) => b.score - a.score);
          
          // Store scores for all potential matches
          scores[templateHeader] = matches;
          
          // Only use the best match if it's good enough (above 60% similarity)
          if (matches.length > 0 && matches[0].score > 0.6) {
            suggestions[templateHeader] = matches[0].header;
          }
        });
        
        return { suggestions, scores };
      };

      // Handle mapping change
      const handleMappingChange = (templateHeader, dataHeader, tabName = null) => {
        if (enableMultiTabMapping && !useSharedMappings && tabName) {
          // Update tab-specific mappings
          setTabSpecificMappings(prev => {
            const newMappings = { ...prev };
            if (!newMappings[tabName]) {
              newMappings[tabName] = {};
            }
            newMappings[tabName][templateHeader] = dataHeader;
            return newMappings;
          });
        } else {
          // Update shared mappings
          setMappings(prev => ({
            ...prev,
            [templateHeader]: dataHeader
          }));
        }
      };

      // Update category values when category column changes
      const updateCategoryValues = (headers, dataRows, categoryCol) => {
        // Find the index of the category column
        const colIndex = headers.indexOf(categoryCol);
        
        if (colIndex === -1) {
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          return;
        }
        
        // Get unique values from the category column
        const uniqueValues = new Set();
        dataRows.forEach(row => {
          if (row && colIndex < row.length && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== '') {
            uniqueValues.add(String(row[colIndex]));
          }
        });
        
        const valueArray = Array.from(uniqueValues).sort();
        
        // Update state with the unique values
        setCategoryValues(valueArray);
        
        // Initialize worksheet mappings for each category value
        const initialMappings = {};
        valueArray.forEach(value => {
          // If there's a template sheet with a matching name, use that
          const matchingSheet = templateSheets.find(sheet => 
            sheet.toLowerCase() === value.toLowerCase() || 
            sheet.toLowerCase().includes(value.toLowerCase())
          );
          
          initialMappings[value] = matchingSheet || templateSheets[0];
        });
        
        setCategoryWorksheetMappings(initialMappings);
        
        // Set the first category value as the active tab
        if (valueArray.length > 0 && !activeTab) {
          setActiveTab(valueArray[0]);
        }
      };

      // Handle category column change
      const handleCategoryColumnChange = (column) => {
        setCategoryColumn(column);
        
        if (!column) {
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setActiveTab(null);
          return;
        }
        
        // Retrieve the data rows
        if (!data || !data.data || data.data.length <= 1) return;
        
        const dataRows = data.data.slice(1); // Skip header row
        
        updateCategoryValues(data.headers, dataRows, column);
      };

      // Handle worksheet mapping change
      const handleWorksheetMappingChange = (categoryValue, worksheet) => {
        setCategoryWorksheetMappings(prev => ({
          ...prev,
          [categoryValue]: worksheet
        }));
      };

      // Accept all suggestions
      const acceptAllSuggestions = () => {
        setMappings(suggestedMappings);
        setSuggestionsReviewed(true);
      };
      
      // Accept a specific mapping suggestion
      const acceptSuggestion = (templateHeader) => {
        if (suggestedMappings[templateHeader]) {
          setMappings(prev => ({
            ...prev,
            [templateHeader]: suggestedMappings[templateHeader]
          }));
        }
      };
      
      // Clear a specific mapping
      const clearMapping = (templateHeader, tabName = null) => {
        if (enableMultiTabMapping && !useSharedMappings && tabName) {
          setTabSpecificMappings(prev => {
            const newMappings = { ...prev };
            if (newMappings[tabName] && newMappings[tabName][templateHeader]) {
              delete newMappings[tabName][templateHeader];
            }
            return newMappings;
          });
        } else {
          setMappings(prev => {
            const newMappings = { ...prev };
            delete newMappings[templateHeader];
            return newMappings;
          });
        }
      };

      // Validate mappings before proceeding
      const validateMappings = (tabMappings = null) => {
        const missingRequiredFields = [];
        const mappingsToCheck = tabMappings || mappings;
        
        templateHeaders.forEach(header => {
          if (!header) return;
          
          const isRequired = fieldRequirements[header] === 'Required';
          const isMapped = mappingsToCheck[header] && mappingsToCheck[header] !== '';
          
          if (isRequired && !isMapped) {
            missingRequiredFields.push(header);
          }
        });
        
        return {
          valid: missingRequiredFields.length === 0,
          missingFields: missingRequiredFields
        };
      };

      // Map data based on current mappings
      const mapData = () => {
        if (!template || !data) return;
        
        setIsLoading(prev => ({ ...prev, mapping: true }));
        
        try {
          // Get list of missing required fields (but don't block on them)
          const validation = validateMappings();
          if (!validation.valid) {
            console.log(`Note: Missing required fields: ${validation.missingFields.join(', ')}`);
            // We no longer block the process, just note it in the console
          }
          
          if (enableMultiTabMapping) {
            // Handle multi-tab mapping
            const mappedDataByCategory = {};
            
            // Find the index of the category column
            const categoryColIndex = data.headers.indexOf(categoryColumn);
            
            if (categoryColIndex === -1) {
              throw new Error("Category column not found in data headers");
            }
            
            // Group data rows by category
            const groupedData = {};
            
            // Start from row 1 (skip header row)
            for (let i = 1; i < data.data.length; i++) {
              const dataRow = data.data[i];
              
              // Ensure the row has data in the category column
              if (dataRow && categoryColIndex < dataRow.length) {
                const categoryValue = String(dataRow[categoryColIndex] || "");
                
                // Create array for this category if it doesn't exist
                if (!groupedData[categoryValue]) {
                  groupedData[categoryValue] = [];
                }
                
                // Add row to the appropriate category
                groupedData[categoryValue].push(dataRow);
              }
            }
            
            // Process each category group
            Object.keys(groupedData).forEach(categoryValue => {
              const targetWorksheet = categoryWorksheetMappings[categoryValue];
              
              if (!targetWorksheet) {
                console.warn(`No target worksheet defined for category: ${categoryValue}`);
                return;
              }
              
              const rows = groupedData[categoryValue];
              const templateHeadersArr = template.headers;
              const mappedRows = [templateHeadersArr]; // Start with template headers
              
              // Get the correct mappings for this category/tab
              const currentMappings = !useSharedMappings && tabSpecificMappings[categoryValue] 
                ? tabSpecificMappings[categoryValue] 
                : mappings;
              
              // Map each data row
              rows.forEach(dataRow => {
                const mappedRow = new Array(templateHeadersArr.length).fill('');
                
                // For each template header
                templateHeadersArr.forEach((templateHeader, templateColIndex) => {
                  if (!templateHeader) return;
                  
                  const dataHeader = currentMappings[templateHeader];
                  
                  if (dataHeader) {
                    // Find the index of this header in the data
                    const dataColIndex = data.headers.indexOf(dataHeader);
                    
                    if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                      mappedRow[templateColIndex] = dataRow[dataColIndex];
                    }
                  }
                });
                
                mappedRows.push(mappedRow);
              });
              
              // Store mapped data for this category
              mappedDataByCategory[categoryValue] = {
                worksheet: targetWorksheet,
                data: mappedRows
              };
            });
            
            // Set the mapped data with all category mappings
            setMappedData(mappedDataByCategory);
          } else {
            // Standard single-worksheet mapping
            const mappedRows = [];
            const templateHeadersArr = template.headers;
            
            // Start with a row containing template headers
            mappedRows.push(templateHeadersArr);
            
            // For each data row (skip header)
            for (let i = 1; i < data.data.length; i++) {
              const dataRow = data.data[i];
              const mappedRow = new Array(templateHeadersArr.length).fill('');
              
              // For each template header
              templateHeadersArr.forEach((templateHeader, templateColIndex) => {
                if (!templateHeader) return;
                
                const dataHeader = mappings[templateHeader];
                
                if (dataHeader) {
                  // Find the index of this header in the data
                  const dataColIndex = data.headers.indexOf(dataHeader);
                  
                  if (dataColIndex !== -1 && dataRow && dataColIndex < dataRow.length) {
                    mappedRow[templateColIndex] = dataRow[dataColIndex];
                  }
                }
              });
              
              mappedRows.push(mappedRow);
            }
            
            setMappedData(mappedRows);
          }
          
          setStep(3);
        } catch (error) {
          console.error('Error mapping data:', error);
          setDebugInfo(`Error mapping data: ${error.message}`);
        } finally {
          setIsLoading(prev => ({ ...prev, mapping: false }));
        }
      };

      // Export data directly into a copy of the original template
      const exportExcel = () => {
        if (!mappedData || !template || !templateFile) return;
        
        try {
          // Read the template file again to get a fresh copy
          const reader = new FileReader();
          
          reader.onload = (evt) => {
            try {
              const binaryString = evt.target.result;
              // Create a new workbook from the template file
              const workbook = XLSX.read(binaryString, { type: 'binary' });
              
              if (enableMultiTabMapping) {
                // Multi-tab export logic
                Object.keys(mappedData).forEach(categoryValue => {
                  const { worksheet, data: mappedRows } = mappedData[categoryValue];
                  
                  // Check if the worksheet exists in the workbook
                  if (!workbook.SheetNames.includes(worksheet)) {
                    console.warn(`Worksheet ${worksheet} not found in template. Skipping category ${categoryValue}.`);
                    return;
                  }
                  
                  const workbookSheet = workbook.Sheets[worksheet];
                  
                  // Find the header row index (0-based) from the templateHeaderRow (1-based)
                  const headerRowIndex = templateHeaderRow - 1;
                  
                  // For each data row (skip the header in mappedRows[0])
                  for (let dataRowIndex = 1; dataRowIndex < mappedRows.length; dataRowIndex++) {
                    const dataRow = mappedRows[dataRowIndex];
                    // Template row index = header row index + current data row index
                    const targetRowIndex = headerRowIndex + dataRowIndex; 
                    
                    // For each column in the mapped data
                    for (let colIndex = 0; colIndex < dataRow.length; colIndex++) {
                      if (dataRow[colIndex] === undefined || dataRow[colIndex] === null) continue;
                      
                      // Create the cell address in A1 notation
                      const cellRef = XLSX.utils.encode_cell({r: targetRowIndex, c: colIndex});
                      
                      // Get or create the cell
                      if (!workbookSheet[cellRef]) {
                        workbookSheet[cellRef] = { t: 's', v: '' };
                      }
                      
                      // Update the cell value
                      workbookSheet[cellRef].v = dataRow[colIndex];
                      
                      // Try to detect the type of the value and set the cell type
                      if (typeof dataRow[colIndex] === 'number') {
                        workbookSheet[cellRef].t = 'n';
                      } else if (typeof dataRow[colIndex] === 'boolean') {
                        workbookSheet[cellRef].t = 'b';
                      } else if (dataRow[colIndex] instanceof Date) {
                        workbookSheet[cellRef].t = 'd';
                        // Excel uses a different epoch, so convert dates to numbers
                        workbookSheet[cellRef].v = XLSX.SSF.parse_date_code(dataRow[colIndex]);
                      } else {
                        workbookSheet[cellRef].t = 's';
                      }
                    }
                  }
                  
                  // Update the range to include all the data
                  const range = XLSX.utils.decode_range(workbookSheet['!ref'] || 'A1:A1');
                  const lastDataRow = headerRowIndex + mappedRows.length - 1;
                  const lastDataCol = mappedRows[0].length - 1;
                  
                  // Only extend the range if needed
                  if (lastDataRow > range.e.r) range.e.r = lastDataRow;
                  if (lastDataCol > range.e.c) range.e.c = lastDataCol;
                  
                  workbookSheet['!ref'] = XLSX.utils.encode_range(range);
                });
              } else {
                // Standard single-worksheet export
                const sheet = template.sheet;
                const worksheet = workbook.Sheets[sheet];
                
                // Find the header row index (0-based) from the templateHeaderRow (1-based)
                const headerRowIndex = templateHeaderRow - 1;
                
                // For each data row (skip the header in mappedData[0])
                for (let dataRowIndex = 1; dataRowIndex < mappedData.length; dataRowIndex++) {
                  const dataRow = mappedData[dataRowIndex];
                  // Template row index = header row index + current data row index
                  const targetRowIndex = headerRowIndex + dataRowIndex; 
                  
                  // For each column in the mapped data
                  for (let colIndex = 0; colIndex < dataRow.length; colIndex++) {
                    if (dataRow[colIndex] === undefined || dataRow[colIndex] === null) continue;
                    
                    // Create the cell address in A1 notation
                    const cellRef = XLSX.utils.encode_cell({r: targetRowIndex, c: colIndex});
                    
                    // Get or create the cell
                    if (!worksheet[cellRef]) {
                      worksheet[cellRef] = { t: 's', v: '' };
                    }
                    
                    // Update the cell value
                    worksheet[cellRef].v = dataRow[colIndex];
                    
                    // Try to detect the type of the value and set the cell type
                    if (typeof dataRow[colIndex] === 'number') {
                      worksheet[cellRef].t = 'n';
                    } else if (typeof dataRow[colIndex] === 'boolean') {
                      worksheet[cellRef].t = 'b';
                    } else if (dataRow[colIndex] instanceof Date) {
                      worksheet[cellRef].t = 'd';
                      // Excel uses a different epoch, so convert dates to numbers
                      worksheet[cellRef].v = XLSX.SSF.parse_date_code(dataRow[colIndex]);
                    } else {
                      worksheet[cellRef].t = 's';
                    }
                  }
                }
                
                // Update the range to include all the data
                const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1:A1');
                const lastDataRow = headerRowIndex + mappedData.length - 1;
                const lastDataCol = mappedData[0].length - 1;
                
                // Only extend the range if needed
                if (lastDataRow > range.e.r) range.e.r = lastDataRow;
                if (lastDataCol > range.e.c) range.e.c = lastDataCol;
                
                worksheet['!ref'] = XLSX.utils.encode_range(range);
              }
              
              // Generate a filename based on the template
              const filename = templateFile.name.replace(/\.[^/.]+$/, '') + '_filled.xlsx';
              
              // Add a message to the UI
              alert("Export complete! The file will download with your template's formatting preserved.");
              
              // Write the workbook to a file
              XLSX.writeFile(workbook, filename);
            } catch (error) {
              console.error('Error processing template for export:', error);
              setDebugInfo(`Error exporting: ${error.message}`);
            }
          };
          
          reader.onerror = () => {
            console.error('Error reading template file for export');
          };
          
          reader.readAsBinaryString(templateFile);
        } catch (error) {
          console.error('Error exporting Excel file:', error);
        }
      };

      // Continue to mapping step
      const proceedToMapping = () => {
        if (template && data) {
          setStep(2);
        }
      };

      // Toggle requirement row availability
      const toggleRequirementRow = (e) => {
        setRequirementRowAvailable(e.target.checked);
      };
      
      // Toggle multi-tab mapping
      const toggleMultiTabMapping = (e) => {
        const enabled = e.target.checked;
        setEnableMultiTabMapping(enabled);
        
        if (!enabled) {
          setCategoryColumn('');
          setCategoryValues([]);
          setCategoryWorksheetMappings({});
          setActiveTab(null);
          setTabSpecificMappings({});
        }
      };
      
      // Toggle shared mappings
      const toggleSharedMappings = (e) => {
        setUseSharedMappings(e.target.checked);
      };

      // Helper function to check if a header has notes
      const headerHasNotes = (header) => {
        return templateHeaderNotes[header] && templateHeaderNotes[header].trim() !== '';
      };

      // Dynamically check if any notes are available
      const hasAnyNotes = Object.values(templateHeaderNotes).some(note => note && note.trim() !== '');
      
      // Check if any data descriptions are available
      const hasAnyDataDescriptions = Object.values(dataHeaderDescriptions).some(
        desc => desc && desc.trim() !== ''
      );

      // Function to determine if a note needs the "large" class
      const isLargeNote = (note) => {
        return note && note.length > 150;
      };
      
      // Get confidence level label based on score
      const getConfidenceLevel = (score) => {
        if (score >= 0.8) return 'High';
        if (score >= 0.6) return 'Medium';
        return 'Low';
      };
      
      // Get confidence level class based on score
      const getConfidenceClass = (score) => {
        if (score >= 0.8) return 'confidence-high';
        if (score >= 0.6) return 'confidence-medium';
        return 'confidence-low';
      };
      
      // Get the number of unmapped required fields
      const getUnmappedRequiredFieldsCount = (tabName = null) => {
        const currentMappings = tabName && !useSharedMappings && tabSpecificMappings[tabName] 
          ? tabSpecificMappings[tabName] 
          : mappings;
          
        return templateHeaders.filter(header => {
          return (
            header && 
            fieldRequirements[header] === 'Required' && 
            (!currentMappings[header] || currentMappings[header] === '')
          );
        }).length;
      };

      // Get current mappings based on active tab
      const getCurrentMappings = () => {
        if (enableMultiTabMapping && !useSharedMappings && activeTab && tabSpecificMappings[activeTab]) {
          return tabSpecificMappings[activeTab];
        }
        return mappings;
      };

      return (
        <div className={`min-h-screen transition-colors duration-200 ${isDarkMode ? 'dark bg-gray-900' : 'bg-gray-50'}`}>
          <div className="p-4 md:p-6 max-w-5xl mx-auto">
            <h1 className="text-2xl md:text-3xl font-bold mb-6 text-center dark:text-white flex justify-center items-center">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-8 h-8 mr-2 text-excel-500">
                <path d="M18.375 2.25c-1.035 0-1.875.84-1.875 1.875v15.75c0 1.035.84 1.875 1.875 1.875h.75c1.035 0 1.875-.84 1.875-1.875V4.125c0-1.036-.84-1.875-1.875-1.875h-.75zM9.75 8.625c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v11.25c0 1.035-.84 1.875-1.875 1.875h-.75a1.875 1.875 0 01-1.875-1.875V8.625zM3 13.125c0-1.036.84-1.875 1.875-1.875h.75c1.036 0 1.875.84 1.875 1.875v6.75c0 1.035-.84 1.875-1.875 1.875h-.75A1.875 1.875 0 013 19.875v-6.75z" />
              </svg>
              Excel Template Mapper
            </h1>
            
            <div className="mb-8 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm dark:text-gray-200">
              <h2 className="text-lg md:text-xl font-semibold mb-2 text-excel-600 dark:text-excel-400">How it works:</h2>
              <ol className="list-decimal pl-6">
                <li className="mb-1">Upload your Excel template file and select the worksheet, header row, and required fields row (if available)</li>
                <li className="mb-1">Upload your data Excel file and select the worksheet and header row</li>
                <li className="mb-1">Review and adjust the column mappings if needed</li>
                <li className="mb-1">Generate your mapped Excel file</li>
              </ol>
            </div>
            
            <div className="flex mb-6 overflow-x-auto pb-1">
              <div className={`px-4 py-2 rounded-t-lg mr-2 transition-colors duration-150 ${step === 1 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 1: Upload Files
              </div>
              <div className={`px-4 py-2 rounded-t-lg mr-2 transition-colors duration-150 ${step === 2 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 2: Map Columns
              </div>
              <div className={`px-4 py-2 rounded-t-lg transition-colors duration-150 ${step === 3 ? 'bg-excel-500 text-white' : 'bg-gray-200 dark:bg-gray-700 dark:text-gray-300'}`}>
                Step 3: Export
              </div>
            </div>
            
            {step === 1 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <div className="mb-8 border-b pb-6 dark:border-gray-700">
                  <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">1. Template Excel File</h2>
                  
                  <div className="mb-4">
                    <label className="block mb-2 text-gray-700 dark:text-gray-300">Upload Template File</label>
                    <div className="relative">
                      <input
                        type="file"
                        accept=".xlsx, .xls"
                        onChange={(e) => handleFileUpload(e, 'template')}
                        className="block w-full text-base text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded p-2 
                          file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold
                          file:bg-excel-50 file:text-excel-700 dark:file:bg-gray-700 dark:file:text-gray-300
                          hover:file:bg-excel-100 dark:hover:file:bg-gray-600"
                      />
                      {isLoading.template && (
                        <div className="absolute inset-0 bg-white/70 dark:bg-gray-800/70 flex items-center justify-center">
                          <svg className="animate-spin h-5 w-5 text-excel-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {templateSheets.length > 0 && (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Select Worksheet</label>
                        <select
                          value={selectedTemplateSheet}
                          onChange={(e) => setSelectedTemplateSheet(e.target.value)}
                          className="block w-full p-2 text-base border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        >
                          {templateSheets.map((sheet, index) => (
                            <option key={index} value={sheet}>{sheet}</option>
                          ))}
                        </select>
                      </div>
                      
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Header Row Number</label>
                        <input
                          type="number"
                          min="1"
                          value={templateHeaderRow}
                          onChange={(e) => setTemplateHeaderRow(Math.max(1, parseInt(e.target.value) || 1))}
                          className="block w-full p-2 text-base border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        />
                      </div>
                    </div>
                  )}
                  
                  {templateSheets.length > 0 && (
                    <div className="mb-4">
                      <div className="flex items-center mb-2">
                        <input
                          type="checkbox"
                          id="requirementRow"
                          checked={requirementRowAvailable}
                          onChange={toggleRequirementRow}
                          className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                        />
                        <label htmlFor="requirementRow" className="text-gray-700 dark:text-gray-300">
                          Template includes a row indicating required fields
                        </label>
                      </div>
                      
                      {requirementRowAvailable && (
                        <div className="pl-6">
                          <label className="block mb-2 text-gray-700 dark:text-gray-300">Required Fields Row Number</label>
                          <input
                            type="number"
                            min="1"
                            value={templateRequirementRow}
                            onChange={(e) => setTemplateRequirementRow(Math.max(1, parseInt(e.target.value) || 1))}
                            className="block w-full p-2 text-base border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                          />
                          <p className="mt-1 text-sm text-gray-500 dark:text-gray-400">
                            This row should contain indicators like "Required", "Optional", "R", "O", "*", etc.
                          </p>
                        </div>
                      )}
                    </div>
                  )}
                  
                  {templateSheets.length > 0 && (
                    <button
                      onClick={() => processSheet('template')}
                      disabled={isLoading.template}
                      className={`px-4 py-2 rounded transition-colors ${
                        isLoading.template 
                          ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                          : 'bg-excel-500 hover:bg-excel-600 text-white'
                      }`}
                    >
                      {isLoading.template ? (
                        <span className="flex items-center">
                          <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                          Processing...
                        </span>
                      ) : 'Load Template Headers'}
                    </button>
                  )}
                  
                  {templateHeaders.length > 0 && debugInfo && (
                    <div className="mt-2 mb-2 text-gray-500 dark:text-gray-400 text-sm italic">
                      Note: {debugInfo}
                    </div>
                  )}
                  
                  {templateHeaders.length > 0 && (
                    <div className="mt-4">
                      <p className="text-excel-600 dark:text-excel-400">âœ“ Template loaded with {templateHeaders.filter(Boolean).length} columns</p>
                      <div className="mt-2 overflow-x-auto">
                        <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 text-sm rounded-md">
                          <thead>
                            <tr className="bg-gray-50 dark:bg-gray-700">
                              <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Column Name</th>
                              <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Requirement</th>
                              <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Has Validation Message</th>
                            </tr>
                          </thead>
                          <tbody>
                            {templateHeaders.filter(Boolean).map((header, index) => (
                              <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                                <td className="py-1 px-3 border-b dark:border-gray-600">
                                  <div className="tooltip flex items-center">
                                    <span className="has-notes">{header}</span>
                                    {headerHasNotes(header) && (
                                      <>
                                        <span className="info-icon ml-1">i</span>
                                        <span 
                                          className={`tooltip-text ${isLargeNote(templateHeaderNotes[header]) ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: templateHeaderNotes[header] }}
                                        />
                                      </>
                                    )}
                                  </div>
                                </td>
                                <td className={`py-1 px-3 border-b dark:border-gray-600 ${fieldRequirements[header] === 'Required' ? 'text-red-500 dark:text-red-400 font-medium' : 'text-excel-500 dark:text-excel-400'}`}>
                                  {fieldRequirements[header] || 'Optional'}
                                </td>
                                <td className="py-1 px-3 border-b dark:border-gray-600">
                                  {headerHasNotes(header) ? (
                                    <span className="text-excel-500 dark:text-excel-400">Yes</span>
                                  ) : (
                                    <span className="text-gray-400 dark:text-gray-500">No</span>
                                  )}
                                </td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}
                </div>
                
                <div className="mb-6">
                  <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">2. Data Excel File</h2>
                  
                  <div className="mb-4">
                    <label className="block mb-2 text-gray-700 dark:text-gray-300">Upload Data File</label>
                    <div className="relative">
                      <input
                        type="file"
                        accept=".xlsx, .xls"
                        onChange={(e) => handleFileUpload(e, 'data')}
                        className="block w-full text-base text-gray-700 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded p-2 
                          file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold
                          file:bg-excel-50 file:text-excel-700 dark:file:bg-gray-700 dark:file:text-gray-300
                          hover:file:bg-excel-100 dark:hover:file:bg-gray-600"
                      />
                      {isLoading.data && (
                        <div className="absolute inset-0 bg-white/70 dark:bg-gray-800/70 flex items-center justify-center">
                          <svg className="animate-spin h-5 w-5 text-excel-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {dataSheets.length > 0 && (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Select Worksheet</label>
                        <select
                          value={selectedDataSheet}
                          onChange={(e) => setSelectedDataSheet(e.target.value)}
                          className="block w-full p-2 text-base border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        >
                          {dataSheets.map((sheet, index) => (
                            <option key={index} value={sheet}>{sheet}</option>
                          ))}
                        </select>
                      </div>
                      
                      <div>
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Header Row Number</label>
                        <input
                          type="number"
                          min="1"
                          value={dataHeaderRow}
                          onChange={(e) => setDataHeaderRow(Math.max(1, parseInt(e.target.value) || 1))}
                          className="block w-full p-2 text-base border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                        />
                      </div>
                    </div>
                  )}
                  
                  {dataSheets.length > 0 && (
                    <button
                      onClick={() => processSheet('data')}
                      disabled={isLoading.data}
                      className={`px-4 py-2 rounded transition-colors ${
                        isLoading.data 
                          ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                          : 'bg-excel-500 hover:bg-excel-600 text-white'
                      }`}
                    >
                      {isLoading.data ? (
                        <span className="flex items-center">
                          <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                          </svg>
                          Processing...
                        </span>
                      ) : 'Load Data Headers'}
                    </button>
                  )}
                  
                  {dataHeaders.length > 0 && (
                    <div className="mt-4">
                      <p className="text-excel-600 dark:text-excel-400">âœ“ Data loaded with {dataHeaders.filter(Boolean).length} columns</p>
                      <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 max-h-24 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded p-2">
                        Headers: {dataHeaders.filter(Boolean).join(', ')}
                      </div>
                    </div>
                  )}
                </div>
                
                <button
                  disabled={!template || !data}
                  onClick={proceedToMapping}
                  className={`w-full md:w-auto px-4 py-2 rounded transition-colors ${
                    !template || !data 
                      ? 'bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400 cursor-not-allowed' 
                      : 'bg-excel-500 text-white hover:bg-excel-600'
                  }`}
                >
                  Continue to Column Mapping
                </button>
              </div>
            )}
            
            {step === 2 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">Map Template Columns to Data Columns</h2>
                <p className="mb-4 text-gray-600 dark:text-gray-300">
                  We've automatically matched columns based on name similarity. Please review and adjust as needed.
                  <span className="text-red-500 dark:text-red-400 ml-2 font-medium">Required fields must be mapped.</span>
                </p>
                
                {/* Multi-tab mapping option */}
                <div className="mb-6 border dark:border-gray-700 rounded-lg p-4 bg-gray-50 dark:bg-gray-900/50">
                  <div className="flex items-center mb-3">
                    <input
                      type="checkbox"
                      id="enableMultiTabMapping"
                      checked={enableMultiTabMapping}
                      onChange={toggleMultiTabMapping}
                      className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                    />
                    <label htmlFor="enableMultiTabMapping" className="text-gray-700 dark:text-gray-300 font-medium">
                      Enable Multi-Tab Mapping
                    </label>
                  </div>
                  
                  {enableMultiTabMapping && (
                    <div className="pl-6">
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                        Map your data to different worksheets in the template based on a category column.
                      </p>
                      
                      <div className="mb-3">
                        <label className="block mb-2 text-gray-700 dark:text-gray-300">Select Category Column</label>
                        <CustomSelect
                          options={[
                            { value: '', label: '-- Select a column --' },
                            ...dataHeaders.filter(Boolean).map(header => ({
                              value: header,
                              label: header
                            }))
                          ]}
                          value={categoryColumn}
                          onChange={handleCategoryColumnChange}
                          columnSamples={columnSamples}
                          columnDescriptions={dataHeaderDescriptions}
                        />
                      </div>
                      
                      {categoryColumn && categoryValues.length > 0 && (
                        <>
                          <div className="mb-3">
                            <div className="flex items-center justify-between mb-2">
                              <label className="text-gray-700 dark:text-gray-300">Category to Worksheet Mapping</label>
                              <span className="text-sm text-gray-500 dark:text-gray-400">
                                {categoryValues.length} unique values found
                              </span>
                            </div>
                            
                            <div className="border dark:border-gray-700 rounded overflow-hidden">
                              <div className="overflow-y-auto max-h-64">
                                <table className="min-w-full">
                                  <thead className="bg-gray-50 dark:bg-gray-700">
                                    <tr>
                                      <th className="py-2 px-3 border-b dark:border-gray-600 text-left">
                                        Category Value
                                      </th>
                                      <th className="py-2 px-3 border-b dark:border-gray-600 text-left">
                                        Target Worksheet
                                      </th>
                                    </tr>
                                  </thead>
                                  <tbody>
                                    {categoryValues.map((value, index) => (
                                      <tr key={index} className={index % 2 === 0 ? 'bg-white dark:bg-gray-800' : 'bg-gray-50 dark:bg-gray-700/30'}>
                                        <td className="py-2 px-3 border-b dark:border-gray-600">
                                          {value}
                                        </td>
                                        <td className="py-2 px-3 border-b dark:border-gray-600">
                                          <select
                                            value={categoryWorksheetMappings[value] || ''}
                                            onChange={(e) => handleWorksheetMappingChange(value, e.target.value)}
                                            className="block w-full p-1 text-sm border rounded bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                          >
                                            {templateSheets.map((sheet, sheetIndex) => (
                                              <option key={sheetIndex} value={sheet}>{sheet}</option>
                                            ))}
                                          </select>
                                        </td>
                                      </tr>
                                    ))}
                                  </tbody>
                                </table>
                              </div>
                            </div>
                          </div>
                          
                          <div className="mb-3">
                            <div className="flex items-center">
                              <input
                                type="checkbox"
                                id="useSharedMappings"
                                checked={useSharedMappings}
                                onChange={toggleSharedMappings}
                                className="mr-2 h-4 w-4 rounded border-gray-300 text-excel-500 focus:ring-excel-500 dark:border-gray-600 dark:focus:ring-excel-600"
                              />
                              <label htmlFor="useSharedMappings" className="text-gray-700 dark:text-gray-300">
                                Use the same column mappings for all worksheets
                              </label>
                            </div>
                          </div>
                          
                          {!useSharedMappings && (
                            <div className="mb-3">
                              <label className="block mb-2 text-gray-700 dark:text-gray-300">
                                Configure Mappings For:
                              </label>
                              <div className="tab-selector mb-3">
                                {categoryValues.map((value, index) => (
                                  <div
                                    key={index}
                                    className={`tab-item ${activeTab === value ? 'active' : ''}`}
                                    onClick={() => setActiveTab(value)}
                                  >
                                    <div className="flex items-center">
                                      <span>{value}</span>
                                      <span className="badge worksheet-badge ml-2 text-xs">
                                        {categoryWorksheetMappings[value] || 'None'}
                                      </span>
                                    </div>
                                  </div>
                                ))}
                              </div>
                            </div>
                          )}
                        </>
                      )}
                    </div>
                  )}
                </div>
                
                {!suggestionsReviewed && Object.keys(suggestedMappings).length > 0 && (
                  <div className="mapping-suggestion-panel mb-6 dark:bg-blue-950/20">
                    <div className="flex items-center justify-between mb-3">
                      <h3 className="font-medium text-blue-800 dark:text-blue-300">Suggested Column Mappings</h3>
                      <button 
                        onClick={acceptAllSuggestions}
                        className="px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white text-sm rounded transition-colors"
                      >
                        Accept All
                      </button>
                    </div>
                    
                    <div className="overflow-x-auto">
                      <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 text-sm rounded-md">
                        <thead className="bg-gray-50 dark:bg-gray-700">
                          <tr>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Template Column</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Suggested Data Column</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Confidence</th>
                            <th className="py-2 px-3 border-b dark:border-gray-600 text-left">Action</th>
                          </tr>
                        </thead>
                        <tbody>
                          {Object.entries(suggestedMappings).map(([templateHeader, dataHeader], index) => {
                            // Get the match score for this suggestion
                            const matchScores = mappingScores[templateHeader] || [];
                            const matchInfo = matchScores.find(m => m.header === dataHeader);
                            const score = matchInfo ? matchInfo.score : 0;
                            const confidenceLevel = getConfidenceLevel(score);
                            const confidenceClass = getConfidenceClass(score);
                            
                            return (
                              <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="tooltip flex items-center">
                                    <span className="has-notes">{templateHeader}</span>
                                    {headerHasNotes(templateHeader) && (
                                      <>
                                        <span className="info-icon ml-1">i</span>
                                        <span 
                                          className={`tooltip-text ${isLargeNote(templateHeaderNotes[templateHeader]) ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: templateHeaderNotes[templateHeader] }}
                                        />
                                      </>
                                    )}
                                  </div>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="flex items-center">
                                    <span>{dataHeader}</span>
                                    {dataHeaderDescriptions[dataHeader] && (
                                      <div className="tooltip ml-1">
                                        <span className="info-icon text-xs">i</span>
                                        <span 
                                          className={`tooltip-text ${dataHeaderDescriptions[dataHeader] && dataHeaderDescriptions[dataHeader].length > 150 ? 'large' : ''}`}
                                          dangerouslySetInnerHTML={{ __html: dataHeaderDescriptions[dataHeader] }}
                                        />
                                      </div>
                                    )}
                                  </div>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <span className={`mapping-confidence ${confidenceClass}`}>
                                    {confidenceLevel}
                                  </span>
                                </td>
                                <td className="py-2 px-3 border-b dark:border-gray-600">
                                  <div className="flex space-x-2">
                                    <button
                                      onClick={() => acceptSuggestion(templateHeader)}
                                      className="px-2 py-0.5 bg-green-500 hover:bg-green-600 text-white text-sm rounded"
                                      title="Accept this mapping"
                                    >
                                      âœ“
                                    </button>
                                    <button
                                      onClick={() => clearMapping(templateHeader)}
                                      className="px-2 py-0.5 bg-red-500 hover:bg-red-600 text-white text-sm rounded"
                                      title="Reject this mapping"
                                    >
                                      âœ—
                                    </button>
                                  </div>
                                </td>
                              </tr>
                            );
                          })}
                        </tbody>
                      </table>
                    </div>
                    
                    <div className="mt-3">
                      <button 
                        onClick={() => setSuggestionsReviewed(true)}
                        className="text-blue-600 dark:text-blue-400 text-sm hover:underline"
                      >
                        Dismiss suggestions
                      </button>
                    </div>
                  </div>
                )}
                
                <div className="mb-4 flex flex-col sm:flex-row gap-2 text-sm">
                  {hasAnyNotes && (
                    <div className="text-excel-600 dark:text-excel-400 border border-excel-200 dark:border-excel-800 bg-excel-50 dark:bg-excel-900/30 p-3 rounded flex items-start flex-1">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                      </svg>
                      <span><span className="font-medium">Tip:</span> Hover over the "i" icons next to template column names to see input guidance from the Excel template.</span>
                    </div>
                  )}
                  
                  <div className="text-blue-600 dark:text-blue-400 border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/30 p-3 rounded flex items-start flex-1">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9a1 1 0 00-1-1z" clipRule="evenodd" />
                    </svg>
                    <span><span className="font-medium">Tip:</span> Hover over the "i" icons next to data column names to see descriptions, or hover on any cell for 1.5 seconds to see sample data.</span>
                  </div>
                </div>
                
                {enableMultiTabMapping && !useSharedMappings && (
                  <div className="py-2 px-4 bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300 mb-4 rounded-md">
                    Currently configuring mappings for: 
                    <span className="font-medium ml-2">{activeTab}</span>
                    <span className="badge worksheet-badge ml-2">
                      {activeTab && categoryWorksheetMappings[activeTab] ? categoryWorksheetMappings[activeTab] : 'None'}
                    </span>
                  </div>
                )}
                
                <div className="overflow-x-auto mb-6">
                  <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                    <thead className="bg-gray-50 dark:bg-gray-700">
                      <tr>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Template Column</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Requirement</th>
                        <th className="py-2 px-4 border-b dark:border-gray-600 text-left">Data Column</th>
                        {(!enableMultiTabMapping || useSharedMappings) && (
                          <th className="py-2 px-4 border-b dark:border-gray-600 text-left w-16">Actions</th>
                        )}
                      </tr>
                    </thead>
                    <tbody>
                      {templateHeaders.filter(Boolean).map((header, index) => {
                        const currentMappings = enableMultiTabMapping && !useSharedMappings && activeTab && tabSpecificMappings[activeTab]
                          ? tabSpecificMappings[activeTab]
                          : mappings;
                          
                        return (
                          <tr key={index} className={index % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              <div className="tooltip flex items-center">
                                <span className="has-notes">{header}</span>
                                {headerHasNotes(header) && (
                                  <>
                                    <span className="info-icon ml-1">i</span>
                                    <span 
                                      className={`tooltip-text ${isLargeNote(templateHeaderNotes[header]) ? 'large' : ''}`}
                                      dangerouslySetInnerHTML={{ __html: templateHeaderNotes[header] }}
                                    />
                                  </>
                                )}
                              </div>
                            </td>
                            <td className={`py-2 px-4 border-b dark:border-gray-600 ${
                              fieldRequirements[header] === 'Required' 
                                ? 'text-red-500 dark:text-red-400 font-medium' 
                                : 'text-excel-500 dark:text-excel-400'
                            }`}>
                              {fieldRequirements[header] || 'Optional'}
                            </td>
                            <td className="py-2 px-4 border-b dark:border-gray-600">
                              <CustomSelect
                                options={[
                                  { value: '', label: '-- Not Mapped --' },
                                  ...dataHeaders.filter(Boolean).map(dataHeader => ({
                                    value: dataHeader,
                                    label: dataHeader
                                  }))
                                ]}
                                value={currentMappings[header] || ''}
                                onChange={(value) => handleMappingChange(header, value, enableMultiTabMapping && !useSharedMappings ? activeTab : null)}
                                isError={fieldRequirements[header] === 'Required' && (!currentMappings[header] || currentMappings[header] === '')}
                                suggestedValue={suggestedMappings[header] || null}
                                columnSamples={columnSamples}
                                columnDescriptions={dataHeaderDescriptions}
                              />
                            </td>
                            {(!enableMultiTabMapping || useSharedMappings) && (
                              <td className="py-2 px-4 border-b dark:border-gray-600">
                                {currentMappings[header] && (
                                  <button
                                    onClick={() => clearMapping(header)}
                                    className="p-1 bg-red-100 hover:bg-red-200 dark:bg-red-900/30 dark:hover:bg-red-900/50 text-red-700 dark:text-red-400 rounded"
                                    title="Clear this mapping"
                                  >
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                                      <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                                    </svg>
                                  </button>
                                )}
                              </td>
                            )}
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
                
                <div className="mt-6 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                  <button
                    onClick={() => setStep(1)}
                    className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  >
                    Back
                  </button>
                  <button
                    onClick={mapData}
                    disabled={isLoading.mapping}
                    className={`px-4 py-2 rounded transition-colors ${
                      isLoading.mapping 
                        ? 'bg-gray-400 dark:bg-gray-600 cursor-not-allowed' 
                        : 'bg-excel-500 hover:bg-excel-600 text-white'
                    }`}
                  >
                    {isLoading.mapping ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Mapping Data...
                      </span>
                    ) : (
                      <>
                        Map Data
                        {!enableMultiTabMapping && getUnmappedRequiredFieldsCount() > 0 && (
                          <span className="ml-2 bg-red-500 text-white text-xs px-1.5 py-0.5 rounded-full">
                            {getUnmappedRequiredFieldsCount()} unmapped required
                          </span>
                        )}
                        {enableMultiTabMapping && !useSharedMappings && activeTab && getUnmappedRequiredFieldsCount(activeTab) > 0 && (
                          <span className="ml-2 bg-red-500 text-white text-xs px-1.5 py-0.5 rounded-full">
                            {getUnmappedRequiredFieldsCount(activeTab)} unmapped required
                          </span>
                        )}
                      </>
                    )}
                  </button>
                </div>
              </div>
            )}
            
            {step === 3 && (
              <div className="bg-white dark:bg-gray-800 p-4 md:p-6 rounded-lg shadow dark:text-white">
                <h2 className="text-lg font-medium mb-4 text-excel-600 dark:text-excel-400">Data Successfully Mapped</h2>
                
                <div className="mb-6">
                  <p className="text-excel-600 dark:text-excel-400 mb-2 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    {enableMultiTabMapping ? (
                      <>
                        Mapping complete for {Object.keys(mappedData).length} categories across multiple worksheets
                      </>
                    ) : (
                      <>
                        Mapping complete for {mappedData.length - 1} rows of data
                      </>
                    )}
                  </p>
                  
                  {enableMultiTabMapping ? (
                    <div className="mt-4 mb-6">
                      <div className="tab-selector mb-3">
                        {Object.keys(mappedData).map((categoryValue, index) => (
                          <div
                            key={index}
                            className={`tab-item ${activeTab === categoryValue ? 'active' : ''}`}
                            onClick={() => setActiveTab(categoryValue)}
                          >
                            <div className="flex items-center">
                              <span>{categoryValue}</span>
                              <span className="badge worksheet-badge ml-2 text-xs">
                                {mappedData[categoryValue].worksheet}
                              </span>
                              <span className="ml-1 text-xs text-gray-500 dark:text-gray-400">
                                ({mappedData[categoryValue].data.length - 1} rows)
                              </span>
                            </div>
                          </div>
                        ))}
                      </div>
                      
                      {activeTab && mappedData[activeTab] && (
                        <div className="overflow-x-auto">
                          <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                            <thead className="bg-gray-50 dark:bg-gray-700">
                              <tr>
                                {mappedData[activeTab].data[0].map((header, index) => (
                                  <th key={index} className="py-2 px-4 border-b dark:border-gray-600 text-left">
                                    <div className="tooltip flex items-center">
                                      <span className={header && headerHasNotes(header) ? "has-notes" : ""}>
                                        {header || '(Empty Column)'}
                                        {header && fieldRequirements[header] === 'Required' && (
                                          <span className="ml-1 text-red-500 dark:text-red-400">*</span>
                                        )}
                                      </span>
                                      {header && headerHasNotes(header) && (
                                        <>
                                          <span className="info-icon ml-1">i</span>
                                          <span 
                                            className={`tooltip-text ${isLargeNote(templateHeaderNotes[header]) ? 'large' : ''}`}
                                            dangerouslySetInnerHTML={{ __html: templateHeaderNotes[header] }}
                                          />
                                        </>
                                      )}
                                    </div>
                                  </th>
                                ))}
                              </tr>
                            </thead>
                            <tbody>
                              {mappedData[activeTab].data.slice(1, Math.min(6, mappedData[activeTab].data.length)).map((row, rowIndex) => (
                                <tr key={rowIndex} className={rowIndex % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                                  {row.map((cell, cellIndex) => (
                                    <td key={cellIndex} className="py-2 px-4 border-b dark:border-gray-600">
                                      {cell === undefined || cell === null ? '' : String(cell)}
                                    </td>
                                  ))}
                                </tr>
                              ))}
                            </tbody>
                          </table>
                          {mappedData[activeTab].data.length > 6 && (
                            <p className="mt-2 text-gray-500 dark:text-gray-400 text-sm">
                              Showing first 5 rows of {mappedData[activeTab].data.length - 1} total rows for category "{activeTab}"
                            </p>
                          )}
                        </div>
                      )}
                      
                      <div className="mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-900/30 rounded-md text-yellow-800 dark:text-yellow-200">
                        <div className="flex">
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                          </svg>
                          <div>
                            <p className="font-medium mb-1">Multi-tab mapping summary:</p>
                            <ul className="list-disc list-inside text-sm ml-2">
                              <li>
                                {Object.keys(mappedData).length} categories will be mapped to {new Set(Object.values(mappedData).map(item => item.worksheet)).size} different worksheets
                              </li>
                              <li>
                                Total rows to be exported: {Object.values(mappedData).reduce((total, item) => total + item.data.length - 1, 0)}
                              </li>
                              <li>
                                Click on each category tab above to preview the data that will be exported to each worksheet
                              </li>
                            </ul>
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div className="overflow-x-auto mt-4 mb-6">
                      <table className="min-w-full bg-white dark:bg-gray-800 border dark:border-gray-700 rounded-md">
                        <thead className="bg-gray-50 dark:bg-gray-700">
                          <tr>
                            {mappedData[0].map((header, index) => (
                              <th key={index} className="py-2 px-4 border-b dark:border-gray-600 text-left">
                                <div className="tooltip flex items-center">
                                  <span className={header && headerHasNotes(header) ? "has-notes" : ""}>
                                    {header || '(Empty Column)'}
                                    {header && fieldRequirements[header] === 'Required' && (
                                      <span className="ml-1 text-red-500 dark:text-red-400">*</span>
                                    )}
                                  </span>
                                  {header && headerHasNotes(header) && (
                                    <>
                                      <span className="info-icon ml-1">i</span>
                                      <span 
                                        className={`tooltip-text ${isLargeNote(templateHeaderNotes[header]) ? 'large' : ''}`}
                                        dangerouslySetInnerHTML={{ __html: templateHeaderNotes[header] }}
                                      />
                                    </>
                                  )}
                                </div>
                              </th>
                            ))}
                          </tr>
                        </thead>
                        <tbody>
                          {mappedData.slice(1, Math.min(6, mappedData.length)).map((row, rowIndex) => (
                            <tr key={rowIndex} className={rowIndex % 2 === 0 ? 'bg-gray-50 dark:bg-gray-700/30' : 'dark:bg-gray-800'}>
                              {row.map((cell, cellIndex) => (
                                <td key={cellIndex} className="py-2 px-4 border-b dark:border-gray-600">
                                  {cell === undefined || cell === null ? '' : String(cell)}
                                </td>
                              ))}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                      {mappedData.length > 6 && (
                        <p className="mt-2 text-gray-500 dark:text-gray-400 text-sm">Showing first 5 rows of {mappedData.length - 1} total rows</p>
                      )}
                    </div>
                  )}
                </div>
                
                <div className="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                  <button
                    onClick={() => setStep(2)}
                    className="px-4 py-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-700 dark:text-white rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors"
                  >
                    Back to Mapping
                  </button>
                  <button
                    onClick={exportExcel}
                    className="px-4 py-2 bg-excel-500 hover:bg-excel-600 text-white rounded transition-colors flex items-center justify-center"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    {enableMultiTabMapping ? 'Download Multi-Tab Mapped Excel File' : 'Download Mapped Excel File'}
                  </button>
                </div>
              </div>
            )}
            
            <div className="mt-6 text-center text-sm text-gray-500 dark:text-gray-400">
              Excel Template Mapper | Use this tool to map data between different Excel formats
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<ExcelMapper />, document.getElementById('excel-mapper-root'));
  </script>
</body>
</html>
